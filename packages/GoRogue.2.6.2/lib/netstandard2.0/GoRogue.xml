<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GoRogue</name>
    </assembly>
    <members>
        <member name="T:GoRogue.AdjacencyRule">
            <summary>
            Class representing a method for determining which coordinates are adjacent to a given
            coordinate, and which directions those neighbors are in. Cannot be instantiated -- premade
            static instances are provided.
            </summary>
        </member>
        <member name="F:GoRogue.AdjacencyRule.CARDINALS">
            <summary>
            Represents method of determining adjacency where neighbors are considered adjacent if
            they are in a cardinal direction, eg. 4-way (manhattan-based) connectivity.
            </summary>
        </member>
        <member name="F:GoRogue.AdjacencyRule.DIAGONALS">
            <summary>
            Represents method of determining adjacency where neighbors are considered adjacent only
            if they are in a diagonal direction.
            </summary>
        </member>
        <member name="F:GoRogue.AdjacencyRule.EIGHT_WAY">
            <summary>
            Represents method of determining adjacency where all 8 possible neighbors are considered
            adjacent (eg. 8-way connectivity).
            </summary>
        </member>
        <member name="T:GoRogue.AdjacencyRule.Types">
            <summary>
            Enum representing AdjacencyRule types. Each AdjacencyRule instance has a <see cref="F:GoRogue.AdjacencyRule.Type"/> field
            which contains the corresponding value from this enum.  Useful for easy mapping of AdjacencyRule
            types to a primitive type (for cases like a switch statement).
            </summary>
        </member>
        <member name="F:GoRogue.AdjacencyRule.Types.CARDINALS">
            <summary>
            Type for <see cref="F:GoRogue.AdjacencyRule.CARDINALS"/>.
            </summary>
        </member>
        <member name="F:GoRogue.AdjacencyRule.Types.DIAGONALS">
            <summary>
            Type for <see cref="F:GoRogue.AdjacencyRule.DIAGONALS"/>.
            </summary>
        </member>
        <member name="F:GoRogue.AdjacencyRule.Types.EIGHT_WAY">
            <summary>
            Type for <see cref="F:GoRogue.AdjacencyRule.EIGHT_WAY"/>.
            </summary>
        </member>
        <member name="F:GoRogue.AdjacencyRule.Type">
            <summary>
            Enum value representing the method of determining adjacency -- useful for using
            AdjacencyRule types in switch statements.
            </summary>
        </member>
        <member name="M:GoRogue.AdjacencyRule.ToAdjacencyRule(GoRogue.AdjacencyRule.Types)">
            <summary>
            Gets the AdjacencyRule class instance representing the adjacency type specified.
            </summary>
            <param name="adjacencyRuleType">The enum value for the adjacency method.</param>
            <returns>The AdjacencyRule class representing the given adjacency method type.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.DirectionsOfNeighbors">
            <summary>
            Gets directions leading to neighboring locations, according to the current adjacency
            method. Cardinals are returned before any diagonals.
            </summary>
            <returns>Directions that lead to neighboring locations.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.DirectionsOfNeighborsClockwise(GoRogue.Direction)">
            <summary>
            Gets directions leading to neighboring locations, according to the current adjacency
            method. Appropriate directions are returned in clockwise order from the given starting
            direction.
            </summary>
            <param name="startingDirection">The direction to start with.  null or <see cref="P:GoRogue.Direction.NONE"/>
            causes the default starting direction to be used, which is UP for CARDINALS/EIGHT_WAY, and UP_RIGHT
            for diagonals.</param>
            <returns>Directions that lead to neighboring locations.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.DirectionsOfNeighborsCounterClockwise(GoRogue.Direction)">
            <summary>
            Gets directions leading to neighboring locations, according to the current adjacency
            method. Appropriate directions are returned in counter-clockwise order from the given
            starting direction.
            </summary>
            <param name="startingDirection">The direction to start with.  null or <see cref="P:GoRogue.Direction.NONE"/>
            causes the default starting direction to be used, which is UP for CARDINALS/EIGHT_WAY, and UP_LEFT
            for diagonals.</param>
            <returns>Directions that lead to neighboring locations.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.Neighbors(GoRogue.Coord)">
            <summary>
            Gets all neighbors of the specified location, based on the current adjacency method.
            Cardinals are returned before any diagonals.
            </summary>
            <param name="startingLocation">Location to return neighbors for.</param>
            <returns>All neighbors of the given location.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.Neighbors(System.Int32,System.Int32)">
            <summary>
            Gets all neighbors of the specified location, based on the current adjacency method.
            Cardinals are returned before any diagonals.
            </summary>
            <param name="startingX">X-coordinate of location to return neighbors for.</param>
            <param name="startingY">Y-coordinate of location to return neighbors for.</param>
            <returns>All neighbors of the given location.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.NeighborsClockwise(GoRogue.Coord,GoRogue.Direction)">
            <summary>
            Gets all neighbors of the specified location, based on the current adjacency method.
            Neighbors are returned in clockwise order, starting with the neighbor in the given
            starting direction.
            </summary>
            <param name="startingLocation">Location to return neighbors for.</param>
            <param name="startingDirection">
            The neighbor in this direction will be returned first, proceeding clockwise.
            If null or <see cref="P:GoRogue.Direction.NONE"/> is specified, the default starting direction
            is used, which is UP for CARDINALS/EIGHT_WAY, and UP_RIGHT for DIAGONALS.
            </param>
            <returns>All neighbors of the given location.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.NeighborsClockwise(System.Int32,System.Int32,GoRogue.Direction)">
            <summary>
            Gets all neighbors of the specified location, based on the current adjacency method.
            Neighbors are returned in clockwise order, starting with the neighbor in the given
            starting direction.
            </summary>
            <param name="startingX">X-coordinate of location to return neighbors for.</param>
            <param name="startingY">Y-coordinate of location to return neighbors for.</param>
            <param name="startingDirection">
            The neighbor in this direction will be returned first, proceeding clockwise.
            If null or <see cref="P:GoRogue.Direction.NONE"/> is specified, the default starting direction
            is used, which is UP for CARDINALS/EIGHT_WAY, and UP_RIGHT for DIAGONALS.
            </param>
            <returns>All neighbors of the given location.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.NeighborsCounterClockwise(GoRogue.Coord,GoRogue.Direction)">
            <summary>
            Gets all neighbors of the specified location, based on the current adjacency method.
            Neighbors are returned in counter-clockwise order, starting with the neighbor in the given
            starting direction.
            </summary>
            <param name="startingLocation">Location to return neighbors for.</param>
            <param name="startingDirection">
            The neighbor in this direction will be returned first, proceeding counter-clockwise.
            If null or <see cref="P:GoRogue.Direction.NONE"/> is specified, the default starting direction
            is used, which is UP for CARDINALS/EIGHT_WAY, and UP_LEFT for DIAGONALS.
            </param>
            <returns>All neighbors of the given location.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.NeighborsCounterClockwise(System.Int32,System.Int32,GoRogue.Direction)">
            <summary>
            Gets all neighbors of the specified location, based on the current adjacency method.
            Neighbors are returned in counter-clockwise order, starting with the neighbor in the given
            starting direction.
            </summary>
            <param name="startingX">X-coordinate of location to return neighbors for.</param>
            <param name="startingY">Y-coordinate of location to return neighbors for.</param>
            <param name="startingDirection">
            The neighbor in this direction will be returned first, proceeding counter-clockwise.
            If null or <see cref="P:GoRogue.Direction.NONE"/> is specified, the default starting direction
            is used, which is UP for CARDINALS/EIGHT_WAY, and UP_LEFT for DIAGONALS.
            </param>
            <returns>All neighbors of the given location.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.ToString">
            <summary>
            Returns a string representation of the AdjacencyRule.
            </summary>
            <returns>A string representation of the AdjacencyRule.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.Equals(System.Object)">
            <summary>
            Compares the current AdjacencyRule to the object given.
            </summary>
            <param name="obj"/>
            <returns>True if the given object is an AdjacencyRule with the same Type, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.Equals(GoRogue.AdjacencyRule)">
            <summary>
            Compares the current AdjacencyRule to the one given.
            </summary>
            <param name="other"/>
            <returns>True if the given AdjacencyRule has the same Type, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.GetHashCode">
            <summary>
            Returns a hash-value for this object.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.AdjacencyRule.op_Equality(GoRogue.AdjacencyRule,GoRogue.AdjacencyRule)">
            <summary>
            Compares the two AdjacencyRule instances.
            </summary>
            <param name="lhs"/>
            <param name="rhs"/>
            <returns>True if the two given AdjacencyRule instances have the same Type, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.op_Inequality(GoRogue.AdjacencyRule,GoRogue.AdjacencyRule)">
            <summary>
            Compares the two AdjacencyRule instances.
            </summary>
            <param name="lhs"/>
            <param name="rhs"/>
            <returns>True if the two given AdjacencyRule instances do NOT have the same Type, false otherwise.</returns>
        </member>
        <member name="T:GoRogue.BoundedRectangle">
            <summary>
            This class defines a rectanglar area, whose position is automatically "locked" to
            being inside a rectangular bounding box as it is changed. A typical use might be
            keeping track of a camera's view area.
            </summary>
        </member>
        <member name="M:GoRogue.BoundedRectangle.#ctor(GoRogue.Rectangle,GoRogue.Rectangle)">
            <summary>
            Constructor.
            </summary>
            <param name="area">Initial area for the rectangle.</param>
            <param name="boundingBox">Initial bounding box by which to bound the rectangle.</param>
        </member>
        <member name="P:GoRogue.BoundedRectangle.Area">
            <summary>
            The rectangle that is guaranteed to be contained completely within <see cref="P:GoRogue.BoundedRectangle.BoundingBox"/>.
            Although it does not specifically provide a set accessor, this property is returning a
            reference and as such may be assigned to.
            </summary>
        </member>
        <member name="P:GoRogue.BoundedRectangle.BoundingBox">
            <summary>
            The rectangle which <see cref="P:GoRogue.BoundedRectangle.Area"/> is automatically bounded to be within.  Although this
            property does not explicitly provide a set accessor, it is returning a reference so therefore
            the property may be assigned to.
            </summary>
        </member>
        <member name="M:GoRogue.BoundedRectangle.Equals(System.Object)">
            <summary>
            Compares the current BoundedRectangle to the object given.
            </summary>
            <param name="obj"/>
            <returns>True if the given object is a BoundedRectangle that represents the same area, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.BoundedRectangle.Equals(GoRogue.BoundedRectangle)">
            <summary>
            Compares the current BoundedRectangle to the one given.
            </summary>
            <param name="other"/>
            <returns>True if the given BoundedRectangle represents the same area, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.BoundedRectangle.GetHashCode">
            <summary>
            Returns a hash-value for this object.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.BoundedRectangle.op_Equality(GoRogue.BoundedRectangle,GoRogue.BoundedRectangle)">
            <summary>
            Compares the two BoundedRectangle instances.
            </summary>
            <param name="lhs"/>
            <param name="rhs"/>
            <returns>True if the two given BoundedRectangle instances represent the same area, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.BoundedRectangle.op_Inequality(GoRogue.BoundedRectangle,GoRogue.BoundedRectangle)">
            <summary>
            Compares the two BoundedRectangle instances.
            </summary>
            <param name="lhs"/>
            <param name="rhs"/>
            <returns>True if the two given BoundedRectangle instances do NOT represent the same area, false otherwise.</returns>
        </member>
        <member name="T:GoRogue.ComponentContainer">
            <summary>
            A class implementing a flexible, type-based system for adding components to objects.  To utilize it, you can either give your
            object that you want to have components a ComponentContainer field, or if you wish to avoid the extra field to access components,
            you may either inherit from ComponentContainer, or have your object implement <see cref="T:GoRogue.IHasComponents"/>via a backing field of
            type ComponentContainer.
            </summary>
            <remarks>
            The component system is designed to be as efficient as possible at run-time for accessing components and determining if a
            ComponentContainer possesses one or more given types of components, and as well remains flexible and type-safe.
            Components may be of any type, although it is recommended that you _not_ use value-types.  The system also remains accurate
            with respect to types, even when the components added implement interfaces or have an inheritance heirarchy.
            
            For example, suppose we have the following structure:
            <code>
            interface ITickable
            {
                void Tick();
            }
            
            public class PlayerTickable : ITickable
            {
                public void Tick() => Console.WriteLine("Player ticked!");
            }
            </code>
            
            If we then add a component of type PlayerTickable to an object called obj.  obj.GetComponent&lt;PlayerTickable&gt;() will return
            the instance we added, as will obj.GetComponent&lt;ITickable&gt;().  Similarly, obj.HasComponent(typeof(ITickable)) and
            obj.HasComponent(typeof(PlayerTickable)) both return true.
            </remarks>
        </member>
        <member name="M:GoRogue.ComponentContainer.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GoRogue.ComponentContainer.AddComponent(System.Object)">
            <summary>
            Adds the given object as a component.  Throws an exception if that specific instance is already in this ComponentContainer.
            </summary>
            <param name="component">Component to add.</param>
        </member>
        <member name="M:GoRogue.ComponentContainer.RemoveComponent(System.Object)">
            <summary>
            Removes the given component.  Throws an exception if the component does not exist in the ComponentContainer.
            </summary>
            <param name="component">Component to remove.</param>
        </member>
        <member name="M:GoRogue.ComponentContainer.RemoveComponents(System.Object[])">
            <summary>
            Removes the given component(s).  Throws an exception if a component given does not exist in the ComponentContainer.
            </summary>
            <param name="components">One or more component instances to remove.</param>
        </member>
        <member name="M:GoRogue.ComponentContainer.HasComponents(System.Type[])">
            <summary>
            Returns whether or not the current ComponentContainer has all the given types of components.  Types may be specified by
            using typeof(MyComponentType)
            </summary>
            <param name="componentTypes">One or more component types to check for.</param>
            <returns>True if the ComponentContainer has at least one component of each specified type, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.ComponentContainer.HasComponent(System.Type)">
            <summary>
            Returns whether or not the current ComponentContainer has at least one component of the specified type.  Type may be specified
            by using typeof(MyComponentType).
            </summary>
            <param name="componentType">The type of component to check for.</param>
            <returns>True if the ComponentContainer has at least one component of the specified type, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.ComponentContainer.HasComponent``1">
            <summary>
            Returns whether or not the current ComponentContainer has at least one component of type T.
            </summary>
            <typeparam name="T">Type of component to check for.</typeparam>
            <returns>True if the ComponentContainer has at least one component of the specified type, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.ComponentContainer.GetComponent``1">
            <summary>
            Gets the first component of type T found, or default(T) if no component of that type has been added
            to the object.
            </summary>
            <typeparam name="T">Type of component to retrieve.</typeparam>
            <returns>The first component of Type T that was added to the ComponentContainer, or default(T) if no
            components of the given type have been added.</returns>
        </member>
        <member name="M:GoRogue.ComponentContainer.GetComponents``1">
            <summary>
            Gets all components of type T that are attached to the given object.
            </summary>
            <typeparam name="T">Type of components to retrieve.</typeparam>
            <returns>All components of Type T that are in the ComponentContainer.</returns>
        </member>
        <member name="T:GoRogue.Coord">
             <summary>
             A structure that represents a standard 2D grid coordinate.  Provides numerous static functions,
             operators, and implicit converstions that enable common grid/position-related math and operations,
             as well as enable interoperability with position representations from other libraries.
             </summary>
             <remarks>
             Coord instances can be created using the standard Coord c = new Coord(x, y) syntax.  In addition,
             you may create a coord from a c# 7 tuple, like Coord c = (x, y);.  As well, Coord is implicitly convertible
             to position-based types from a few other supported libraries (like MonoGame), so you can even do things like
             Coord c = new Microsoft.Xna.Point(x, y);.  As well, Coord supports C# Deconstrution syntax.
            
             In addition to implicit tuple/custom type converters, Coord provides operators and static helper functions that
             perform common grid math/operations, as well as interoperability with other grid-based classes like
             <see cref="T:GoRogue.Direction"/>  Generally speaking, operators also support interoperability with supported position
             representations from other libraries.  Functions taking a Coord also take any other type which Coord implicitly
             converts to.  Similarly, operator overloads are defined that support things like addition of Coord and supported
             types from other libraries.  For example, since Coord c = myCoord + myCoord2; is valid, so is
             Coord c = myCoord + myMicrosoftXnaPoint and Microsoft.Xna.Point point = myMicrosftXnaPoint + myCoord;.
            
             Coord is designed to be extremely efficient and interoperable with equivalent representations in other libraries,
             so in general, in an environment where you have multiple point representations floating around, it is best to prefer
             Coord where possible, as something that accepts or works with Coord will generally work with other supported types
             as well.
             </remarks>
        </member>
        <member name="F:GoRogue.Coord.NONE">
            <summary>
            Coord value that represents None or no position (since Coord is not a nullable type).
            Typically you would use this constant instead of null.
            </summary>
            <remarks>
            This constant has (x, y) values (int.MinValue, int.MinValue), so a coordinate with those
            x/y values is not considered a valid coordinate by many GoRogue functions.
            </remarks>
        </member>
        <member name="F:GoRogue.Coord.X">
            <summary>
            X-value of the coordinate.
            </summary>
        </member>
        <member name="F:GoRogue.Coord.Y">
            <summary>
            Y-value of the coordinate.
            </summary>
        </member>
        <member name="M:GoRogue.Coord.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="x">X-value for the coordinate.</param>
            <param name="y">Y-value for the coordinate.</param>
        </member>
        <member name="M:GoRogue.Coord.BearingOfLine(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Calculates degree bearing of the line (start =&gt; end), where 0 points in the direction <see cref="P:GoRogue.Direction.UP"/>.
            </summary>
            <param name="start">Position of line starting point.</param>
            <param name="end">Position of line ending point.</param>
            <returns>The degree bearing of the line specified by the two given points.</returns>
        </member>
        <member name="M:GoRogue.Coord.BearingOfLine(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates degree bearing of the line ((startX, startY) =&gt; (endX, endY)), where 0 points
            in the direction <see cref="P:GoRogue.Direction.UP"/>.
            </summary>
            <param name="startX">X-value of the position of line starting point.</param>
            <param name="startY">Y-value of the position of line starting point.</param>
            <param name="endX">X-value of the position of line ending point.</param>
            <param name="endY">Y-value of the position of line ending point.</param>
            <returns>The degree bearing of the line specified by the two given points.</returns>
        </member>
        <member name="M:GoRogue.Coord.BearingOfLine(GoRogue.Coord)">
            <summary>
            Calculates the degree bearing of a line with the given delta-x and delta-y values, where
            0 degreees points in the direction <see cref="P:GoRogue.Direction.UP"/>.
            </summary>
            <param name="deltaChange">
            Vector, where deltaChange.X is the change in x-values across the line, and deltaChange.Y
            is the change in y-values across the line.
            </param>
            <returns>The degree bearing of the line with the given dx and dy values.</returns>
        </member>
        <member name="M:GoRogue.Coord.BearingOfLine(System.Int32,System.Int32)">
            <summary>
            Calculates the degree bearing of a line with the given delta-x and delta-y values, where
            0 degreees points in the direction <see cref="P:GoRogue.Direction.UP"/>.
            </summary>
            <param name="dx">The change in x-values across the line.</param>
            <param name="dy">the change in y-values across the line</param>
            <returns>The degree bearing of the line with the given dx and dy values.</returns>
        </member>
        <member name="M:GoRogue.Coord.EuclideanDistanceMagnitude(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Returns the result of the euclidean distance formula, without the square root -- eg.,
            (c2.X - c1.X) * (c2.X - c1.X) + (c2.Y - c1.Y) * (c2.Y - c1.Y). Use this if you only care
            about the magnitude of the distance -- eg., if you're trying to compare two distances.
            Omitting the square root provides a speed increase.
            </summary>
            <param name="c1">The first point.</param>
            <param name="c2">The second point.</param>
            <returns>
            The "magnitude" of the euclidean distance between the two points -- basically the
            distance formula without the square root.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.EuclideanDistanceMagnitude(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the result of the euclidean distance formula, without the square root -- eg., (x2
            - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1). Use this if you only care about the magnitude
            of the distance -- eg., if you're trying to compare two distances. Omitting the square
            root provides a speed increase.
            </summary>
            <param name="x1">The x-value of the first location.</param>
            <param name="y1">The y-value of the first location.</param>
            <param name="x2">The x-value of the second location.</param>
            <param name="y2">The y-value of the second location.</param>
            <returns>
            The "magnitude" of the euclidean distance between the two points -- basically the
            distance formula without the square root.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.EuclideanDistanceMagnitude(GoRogue.Coord)">
            <summary>
            Returns the result of the euclidean distance formula, without the square root, given the
            dx and dy values between two points -- eg., (deltaChange.X * deltaChange.X) + (deltaChange.Y
            * deltaChange.Y). Use this if you only care about the magnitude of the distance -- eg., if
            you're trying to compare two distances. Omitting the square root provides a speed increase.
            </summary>
            <param name="deltaChange">
            Vector, where deltaChange.X is the change in x-values between the two points, and
            deltaChange.Y is the change in y-values between the two points.
            </param>
            <returns>
            The "magnitude" of the euclidean distance of two locations with the given dx and dy
            values -- basically the distance formula without the square root.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.EuclideanDistanceMagnitude(System.Int32,System.Int32)">
            <summary>
            Returns the result of the euclidean distance formula, without the square root, given the
            dx and dy values between two points -- eg., (dx * dx) + (dy * dy). Use this if you only
            care about the magnitude of the distance -- eg., if you're trying to compare two distances.
            Omitting the square root provides a speed increase.
            </summary>
            <param name="dx">The change in x-values between the two points.</param>
            <param name="dy">The change in y-values between the two points.</param>
            <returns>
            The "magnitude" of the euclidean distance of two locations with the given dx and dy
            values -- basically the distance formula without the square root.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.Midpoint(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Returns the midpoint between the two points.
            </summary>
            <param name="c1">The first point.</param>
            <param name="c2">The second point.</param>
            <returns>The midpoint between <paramref name="c1"/> and <paramref name="c2"/>.</returns>
        </member>
        <member name="M:GoRogue.Coord.Midpoint(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the midpoint between the two points.
            </summary>
            <param name="x1">The x-value of the first location.</param>
            <param name="y1">The y-value of the first location.</param>
            <param name="x2">The x-value of the second location.</param>
            <param name="y2">The y-value of the second location.</param>
            <returns>The midpoint between the two points.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Subtraction(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Returns the coordinate (c1.X - c2.X, c1.Y - c2.Y)
            </summary>
            <param name="c1"></param>
            <param name="c2"></param>
            <returns>The coordinate(<paramref name="c1"/> - <paramref name="c2"/>).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Subtraction(GoRogue.Coord,System.Int32)">
            <summary>
            Subtracts scalar <paramref name="i"/> from the x and y values of <paramref name="c"/>.
            </summary>
            <param name="c"></param>
            <param name="i"></param>
            <returns>The coordinate (c.X - <paramref name="i"/>, c.Y - <paramref name="i"/>)</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Inequality(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            True if either the x-values or y-values are not equal.
            </summary>
            <param name="c1"></param>
            <param name="c2"></param>
            <returns>
            True if either the x-values or y-values are not equal, false if they are both equal.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.op_Multiply(GoRogue.Coord,System.Int32)">
            <summary>
            Multiplies the x and y of <paramref name="c"/> by <paramref name="i"/>.
            </summary>
            <param name="c"></param>
            <param name="i"></param>
            <returns>Coordinate (c.X * <paramref name="i"/>, c.Y * <paramref name="i"/>)</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Multiply(GoRogue.Coord,System.Double)">
            <summary>
            Multiplies the x and y value of <paramref name="c"/> by <paramref name="i"/>, rounding
            the result to the nearest integer.
            </summary>
            <param name="c"></param>
            <param name="i"></param>
            <returns>
            Coordinate (c.X * <paramref name="i"/>, c.Y * <paramref name="i"/>), with the resulting values
            rounded to nearest integer.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.op_Division(GoRogue.Coord,System.Int32)">
            <summary>
            Divides the x and y of <paramref name="c"/> by <paramref name="i"/>, rounding resulting values
            to the nearest integer.
            </summary>
            <param name="c"></param>
            <param name="i"></param>
            <returns>(c.X / <paramref name="i"/>, c.Y / <paramref name="i"/>), with the resulting values rounded to the nearest integer.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Division(GoRogue.Coord,System.Double)">
            <summary>
            Divides the x and y of <paramref name="c"/> by <paramref name="i"/>, rounding resulting values
            to the nearest integer.
            </summary>
            <param name="c"></param>
            <param name="i"></param>
            <returns>(c.X / <paramref name="i"/>, c.Y / <paramref name="i"/>), with the resulting values rounded to the nearest integer.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Addition(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Returns the coordinate (c1.X + c2.X, c1.Y + c2.Y).
            </summary>
            <param name="c1"></param>
            <param name="c2"></param>
            <returns>The coordinate (c1.X + c2.X, c1.Y + c2.Y)</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Addition(GoRogue.Coord,System.Int32)">
            <summary>
            Adds scalar i to the x and y values of <paramref name="c"/>.
            </summary>
            <param name="c"></param>
            <param name="i"></param>
            <returns>Coordinate (c.X + <paramref name="i"/>, c.Y + <paramref name="i"/>.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Addition(GoRogue.Coord,GoRogue.Direction)">
            <summary>
            Translates the given coordinate by one unit in the given direction.
            </summary>
            <param name="c"></param>
            <param name="d"></param>
            <returns>
            Coordinate (c.X + d.DeltaX, c.Y + d.DeltaY)
            </returns>
        </member>
        <member name="M:GoRogue.Coord.op_Equality(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            True if c1.X == c2.X and c1.Y == c2.Y.
            </summary>
            <param name="c1"></param>
            <param name="c2"></param>
            <returns>True if the two coordinates are equal, false if not.</returns>
        </member>
        <member name="M:GoRogue.Coord.ToCoord(System.Int32,System.Int32)">
            <summary>
            Reverses the ToIndex functions, returning the position represented by a given index.
            </summary>
            <param name="index">The index in 1D form.</param>
            <param name="width">The width of the 2D array.</param>
            <returns>The position represented by the 1D index given.</returns>
        </member>
        <member name="M:GoRogue.Coord.ToIndex(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns <paramref name="y"/> * <paramref name="width"/> + <paramref name="x"/>.
            </summary>
            <param name="x">X-value of the coordinate.</param>
            <param name="y">Y-value of the coordinate.</param>
            <param name="width">The width of the 2D array, used to do the math to calculate index.</param>
            <returns>The 1D index of this Coord.</returns>
        </member>
        <member name="M:GoRogue.Coord.ToXValue(System.Int32,System.Int32)">
            <summary>
            Reverses the ToIndex functions, returning only the X-value for the given index.
            </summary>
            <param name="index">The index in 1D form.</param>
            <param name="width">The width of the 2D array.</param>
            <returns>The X-value for the location represented by the given index.</returns>
        </member>
        <member name="M:GoRogue.Coord.ToYValue(System.Int32,System.Int32)">
            <summary>
            Reverses the ToIndex functions, returning only the Y-value for the given index.
            </summary>
            <param name="index">The index in 1D form.</param>
            <param name="width">The width of the 2D array.</param>
            <returns>The Y-value for the location represented by the given index.</returns>
        </member>
        <member name="M:GoRogue.Coord.Equals(System.Object)">
            <summary>
            Same as operator == in this case; returns false if <paramref name="obj"/> is not a Coord.
            </summary>
            <param name="obj">The object to compare the current Coord to.</param>
            <returns>
            True if <paramref name="obj"/> is a Coord instance, and the two coordinates are equal, false otherwise.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.GetHashCode">
            <summary>
            Returns a hash code for the Coord. The important parts: it should be fairly fast and it
            does not collide often.
            </summary>
            <remarks>
            This hashing algorithm uses a seperate bit-mixing algorithm for <see cref="F:GoRogue.Coord.X"/> and
            <see cref="F:GoRogue.Coord.Y"/>, with X and Y each multiplied by a differet large integer, then xors
            the mixed values, does a right shift, and finally multiplies by an overflowing prime
            number.  This hashing algorithm should produce an exceptionally low collision rate for
            coordinates between (0, 0) and (255, 255).
            </remarks>
            <returns>The hash-code for the Coord.</returns>
        </member>
        <member name="M:GoRogue.Coord.ToIndex(System.Int32)">
            <summary>
            Returns a value that can be used to uniquely index this location 1D array.
            </summary>
            <param name="width">The width of the 2D map/array this location is referring to --
            used to do the math to calculate index.</param>
            <returns>The 1D index of this Coord.</returns>
        </member>
        <member name="M:GoRogue.Coord.ToString">
            <summary>
            Returns representation (X, Y).
            </summary>
            <returns>String (X, Y)</returns>
        </member>
        <member name="M:GoRogue.Coord.Translate(System.Int32,System.Int32)">
            <summary>
            Translates the coordinate by the given dx and dy values.
            </summary>
            <param name="dx">Delta x to add to coordinate.</param>
            <param name="dy">Delta y to add to coordinate.</param>
            <returns>The coordinate (<see cref="F:GoRogue.Coord.X"/> + <paramref name="dx"/>, <see cref="F:GoRogue.Coord.Y"/> + <paramref name="dy"/>)</returns>
        </member>
        <member name="M:GoRogue.Coord.Translate(GoRogue.Coord)">
            <summary>
            Returns the coordinate resulting from adding dx to the X-value of the coordinate, and dy
            to the Y-value of the coordinate.
            </summary>
            <param name="deltaChange">
            Vector where deltaChange.X represents the delta-x value and deltaChange.Y represents the
            delta-y value.
            </param>
            <returns>The coordinate (<see cref="F:GoRogue.Coord.X"/> + deltaChange.X, <see cref="F:GoRogue.Coord.Y"/> + deltaChange.Y)</returns>
        </member>
        <member name="M:GoRogue.Coord.Equals(GoRogue.Coord)">
            <summary>
            True if the given coordinate has equal x and y values to the current one.
            </summary>
            <param name="other">Coordinate to compare.</param>
            <returns>True if the two coordinates are equal, false if not.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Implicit(GoRogue.Coord)~Microsoft.Xna.Framework.Point">
            <summary>
            Implicitly converts a Coord to an equivalent MonoGame point.
            </summary>
            <param name="c" />
            <returns />
        </member>
        <member name="M:GoRogue.Coord.op_Implicit(Microsoft.Xna.Framework.Point)~GoRogue.Coord">
            <summary>
            Implicitly converts a MonoGame Point to an equivalent Coord.
            </summary>
            <param name="p" />
            <returns />
        </member>
        <member name="M:GoRogue.Coord.op_Addition(Microsoft.Xna.Framework.Point,GoRogue.Coord)">
            <summary>
            Adds the x and y values of a Coord to a MonoGame Point.
            </summary>
            <param name="p" />
            <param name="c" />
            <returns>A MonoGame Point (p.X + c.X, p.Y + c.Y).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Addition(GoRogue.Coord,Microsoft.Xna.Framework.Point)">
            <summary>
            Adds the x and y values of a MonoGame Point to a Coord.
            </summary>
            <param name="c" />
            <param name="p" />
            <returns>A Coord (c.X + p.X, c.Y + p.Y).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Subtraction(Microsoft.Xna.Framework.Point,GoRogue.Coord)">
            <summary>
            Subtracts the x and y values of a Coord from a MonoGame Point.
            </summary>
            <param name="p" />
            <param name="c" />
            <returns>A MonoGame Point (p.X - c.X, p.Y - c.Y).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Subtraction(GoRogue.Coord,Microsoft.Xna.Framework.Point)">
            <summary>
            Subtracts the x and y values of a MonoGame Point from a Coord.
            </summary>
            <param name="c" />
            <param name="p" />
            <returns>A Coord (c.X - p.X, c.Y - p.Y).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Equality(GoRogue.Coord,Microsoft.Xna.Framework.Point)">
            <summary>
            True if the two point's X and Y values are equal.
            </summary>
            <param name="c1"></param>
            <param name="p2"></param>
            <returns>True if the two coordinates are equal, false if not.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Inequality(GoRogue.Coord,Microsoft.Xna.Framework.Point)">
            <summary>
            True if either the x-values or y-values are not equal.
            </summary>
            <param name="c1"></param>
            <param name="p2"></param>
            <returns>
            True if either the x-values or y-values are not equal, false if they are both equal.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.op_Equality(Microsoft.Xna.Framework.Point,GoRogue.Coord)">
            <summary>
            True if the two point's X and Y values are equal.
            </summary>
            <param name="p1"></param>
            <param name="c2"></param>
            <returns>True if the two coordinates are equal, false if not.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Inequality(Microsoft.Xna.Framework.Point,GoRogue.Coord)">
            <summary>
            True if either the x-values or y-values are not equal.
            </summary>
            <param name="p1"></param>
            <param name="c2"></param>
            <returns>
            True if either the x-values or y-values are not equal, false if they are both equal.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.op_Implicit(GoRogue.Coord)~System.Drawing.Point">
            <summary>
            Implicitly converts a Coord to an equivalent System.Drawing.Point.
            </summary>
            <param name="c" />
            <returns />
        </member>
        <member name="M:GoRogue.Coord.op_Implicit(System.Drawing.Point)~GoRogue.Coord">
            <summary>
            Implicitly converts a System.Drawing.Point to an equivalent Coord.
            </summary>
            <param name="p" />
            <returns />
        </member>
        <member name="M:GoRogue.Coord.op_Implicit(GoRogue.Coord)~System.Drawing.PointF">
            <summary>
            Implicitly converts a Coord to an equivalent System.Drawing.PointF.
            </summary>
            <param name="c" />
            <returns />
        </member>
        <member name="M:GoRogue.Coord.op_Implicit(GoRogue.Coord)~System.Drawing.Size">
            <summary>
            Implicitly converts a Coord to an equivalent System.Drawing.Size.
            </summary>
            <param name="c" />
            <returns />
        </member>
        <member name="M:GoRogue.Coord.op_Implicit(System.Drawing.Size)~GoRogue.Coord">
            <summary>
            Implicitly converts a System.Drawing.Size to an equivalent Coord.
            </summary>
            <param name="s" />
            <returns />
        </member>
        <member name="M:GoRogue.Coord.op_Implicit(GoRogue.Coord)~System.Drawing.SizeF">
            <summary>
            Implicitly converts a Coord to an equivalent System.Drawing.SizeF.
            </summary>
            <param name="c" />
            <returns />
        </member>
        <member name="M:GoRogue.Coord.op_Addition(System.Drawing.Point,GoRogue.Coord)">
            <summary>
            Adds the x and y values of a Coord to a System.Drawing.Point.
            </summary>
            <param name="p" />
            <param name="c" />
            <returns>A System.Drawing.Point (p.X + c.X, p.Y + c.Y).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Addition(GoRogue.Coord,System.Drawing.Point)">
            <summary>
            Adds the x and y values of a System.Drawing.Point to a Coord.
            </summary>
            <param name="c" />
            <param name="p" />
            <returns>A Coord (c.X + p.X, c.Y + p.Y).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Addition(System.Drawing.PointF,GoRogue.Coord)">
            <summary>
            Adds the x and y values of a Coord to a System.Drawing.PointF.
            </summary>
            <param name="p" />
            <param name="c" />
            <returns>A System.Drawing.PointF (p.X + c.X, p.Y + c.Y).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Subtraction(System.Drawing.Point,GoRogue.Coord)">
            <summary>
            Subtracts the x and y values of a Coord from a System.Drawing.Point.
            </summary>
            <param name="p" />
            <param name="c" />
            <returns>A System.Drawing.Point (p.X - c.X, p.Y - c.Y).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Subtraction(GoRogue.Coord,System.Drawing.Point)">
            <summary>
            Subtracts the x and y values of a System.Drawing.Point from a Coord.
            </summary>
            <param name="c" />
            <param name="p" />
            <returns>A Coord (c.X - p.X, c.Y - p.Y).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Subtraction(System.Drawing.PointF,GoRogue.Coord)">
            <summary>
            Subtracts the x and y values of a Coord from a System.Drawing.PointF.
            </summary>
            <param name="p" />
            <param name="c" />
            <returns>A System.Drawing.PointF (p.X - c.X, p.Y - c.Y).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Addition(System.Drawing.Size,GoRogue.Coord)">
            <summary>
            Adds the x and y values of a Coord to a System.Drawing.Size.
            </summary>
            <param name="s" />
            <param name="c" />
            <returns>A System.Drawing.Size (s.Width + c.X, s.Height + c.Y).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Addition(GoRogue.Coord,System.Drawing.Size)">
            <summary>
            Adds the x and y values of a System.Drawing.Size to a Coord.
            </summary>
            <param name="c" />
            <param name="s" />
            <returns>A Coord (c.X + s.Width, c.Y + s.Height).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Addition(System.Drawing.SizeF,GoRogue.Coord)">
            <summary>
            Adds the x and y values of a Coord to a System.Drawing.SizeF.
            </summary>
            <param name="s" />
            <param name="c" />
            <returns>A System.Drawing.SizeF (s.Width + c.X, s.Height + c.Y).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Subtraction(System.Drawing.Size,GoRogue.Coord)">
            <summary>
            Subtracts the x and y values of a Coord from a System.Drawing.Size.
            </summary>
            <param name="s" />
            <param name="c" />
            <returns>A System.Drawing.Size (s.Width - c.X, s.Height - c.Y).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Subtraction(GoRogue.Coord,System.Drawing.Size)">
            <summary>
            Subtracts the x and y values of a System.Drawing.Size from a Coord.
            </summary>
            <param name="c" />
            <param name="s" />
            <returns>A Coord (c.X - s.Width, c.Y - s.Height).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Subtraction(System.Drawing.SizeF,GoRogue.Coord)">
            <summary>
            Subtracts the x and y values of a Coord from a System.Drawing.SizeF.
            </summary>
            <param name="s" />
            <param name="c" />
            <returns>A System.Drawing.SizeF (s.Width - c.X, s.Height - c.Y).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Equality(GoRogue.Coord,System.Drawing.Point)">
            <summary>
            True if the two point's X and Y values are equal.
            </summary>
            <param name="c1"></param>
            <param name="p2"></param>
            <returns>True if the two coordinates are equal, false if not.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Inequality(GoRogue.Coord,System.Drawing.Point)">
            <summary>
            True if either the x-values or y-values are not equal.
            </summary>
            <param name="c1"></param>
            <param name="p2"></param>
            <returns>
            True if either the x-values or y-values are not equal, false if they are both equal.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.op_Equality(System.Drawing.Point,GoRogue.Coord)">
            <summary>
            True if the two point's X and Y values are equal.
            </summary>
            <param name="p1"></param>
            <param name="c2"></param>
            <returns>True if the two coordinates are equal, false if not.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Inequality(System.Drawing.Point,GoRogue.Coord)">
            <summary>
            True if either the x-values or y-values are not equal.
            </summary>
            <param name="p1"></param>
            <param name="c2"></param>
            <returns>
            True if either the x-values or y-values are not equal, false if they are both equal.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.op_Equality(GoRogue.Coord,System.Drawing.PointF)">
            <summary>
            True if the two point's X and Y values are equal.
            </summary>
            <param name="c1"></param>
            <param name="p2"></param>
            <returns>True if the two coordinates are equal, false if not.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Inequality(GoRogue.Coord,System.Drawing.PointF)">
            <summary>
            True if either the x-values or y-values are not equal.
            </summary>
            <param name="c1"></param>
            <param name="p2"></param>
            <returns>
            True if either the x-values or y-values are not equal, false if they are both equal.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.op_Equality(System.Drawing.PointF,GoRogue.Coord)">
            <summary>
            True if the two point's X and Y values are equal.
            </summary>
            <param name="p1"></param>
            <param name="c2"></param>
            <returns>True if the two coordinates are equal, false if not.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Inequality(System.Drawing.PointF,GoRogue.Coord)">
            <summary>
            True if either the x-values or y-values are not equal.
            </summary>
            <param name="p1"></param>
            <param name="c2"></param>
            <returns>
            True if either the x-values or y-values are not equal, false if they are both equal.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.op_Equality(GoRogue.Coord,System.Drawing.Size)">
            <summary>
            True if the point's x/y values equal the size's width/height values.
            </summary>
            <param name="c"></param>
            <param name="size"></param>
            <returns>True if the given Coord and Size are equivalent, false if not.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Inequality(GoRogue.Coord,System.Drawing.Size)">
            <summary>
            True if either the x/Width values or the y/Height values do not match.
            </summary>
            <param name="c"></param>
            <param name="size"></param>
            <returns>
            True if either the x/Width values or the y/Height values are not equal, false if they are both equal.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.op_Equality(System.Drawing.Size,GoRogue.Coord)">
            <summary>
            True if the size's width/height values equal the point's x/y values.
            </summary>
            <param name="size"></param>
            <param name="c"></param>
            <returns>True if the given Size and Coord are equivalent, false if not.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Inequality(System.Drawing.Size,GoRogue.Coord)">
            <summary>
            True if either the Width/x values or the Height/y values do not match.
            </summary>
            <param name="size"></param>
            <param name="c"></param>
            <returns>
            True if either the Width/x values or the Height/y values are not equal, false if they are both equal.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.op_Equality(GoRogue.Coord,System.Drawing.SizeF)">
            <summary>
            True if the point's x/y values equal the size's width/height values.
            </summary>
            <param name="c"></param>
            <param name="size"></param>
            <returns>True if the given Coord and SizeF are equivalent, false if not.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Inequality(GoRogue.Coord,System.Drawing.SizeF)">
            <summary>
            True if either the x/Width values or the y/Height values do not match.
            </summary>
            <param name="c"></param>
            <param name="size"></param>
            <returns>
            True if either the x/Width values or the y/Height values are not equal, false if they are both equal.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.op_Equality(System.Drawing.SizeF,GoRogue.Coord)">
            <summary>
            True if the size's width/height values equal the point's x/y values.
            </summary>
            <param name="size"></param>
            <param name="c"></param>
            <returns>True if the given SizeF and Coord are equivalent, false if not.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Inequality(System.Drawing.SizeF,GoRogue.Coord)">
            <summary>
            True if either the Width/x values or the Height/y values do not match.
            </summary>
            <param name="size"></param>
            <param name="c"></param>
            <returns>
            True if either the Width/x values or the Height/y values are not equal, false if they are both equal.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.Deconstruct(System.Int32@,System.Int32@)">
            <summary>
            Adds support for C# Deconstruction syntax.
            </summary>
            <param name="x" />
            <param name="y" />
        </member>
        <member name="M:GoRogue.Coord.op_Implicit(GoRogue.Coord)~System.ValueTuple{System.Int32,System.Int32}">
            <summary>
            Implicitly converts a Coord to an equivalent tuple of two integers.
            </summary>
            <param name="c" />
            <returns />
        </member>
        <member name="M:GoRogue.Coord.op_Implicit(System.ValueTuple{System.Int32,System.Int32})~GoRogue.Coord">
            <summary>
            Implicitly converts a tuple of two integers to an equivalent Coord.
            </summary>
            <param name="tuple" />
            <returns />
        </member>
        <member name="M:GoRogue.Coord.op_Addition(System.ValueTuple{System.Int32,System.Int32},GoRogue.Coord)">
            <summary>
            Adds the x and y values of a Coord to the corresponding values of a tuple of two integers.
            </summary>
            <param name="tuple" />
            <param name="c" />
            <returns>A tuple (tuple.x + c.X, tuple.y + c.Y).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Addition(GoRogue.Coord,System.ValueTuple{System.Int32,System.Int32})">
            <summary>
            Adds the x and y values of a tuple of two integers to a Coord.
            </summary>
            <param name="c" />
            <param name="tuple" />
            <returns>A Coord (c.X + tuple.x, c.Y + tuple.y).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Subtraction(System.ValueTuple{System.Int32,System.Int32},GoRogue.Coord)">
            <summary>
            Subtracts the x and y values of a Coord from a tuple of two integers.
            </summary>
            <param name="tuple" />
            <param name="c" />
            <returns>A tuple (tuple.x - c.X, tuple.y - c.Y).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Subtraction(GoRogue.Coord,System.ValueTuple{System.Int32,System.Int32})">
            <summary>
            Subtracts the x and y values of a tuple of two integers from a Coord.
            </summary>
            <param name="c" />
            <param name="tuple" />
            <returns>A Coord (c.X - tuple.x, c.Y - tuple.y).</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Equality(GoRogue.Coord,System.ValueTuple{System.Int32,System.Int32})">
            <summary>
            True if the two point's x and y values are equal.
            </summary>
            <param name="c"></param>
            <param name="tuple"></param>
            <returns>True if the two positions are equal, false if not.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Inequality(GoRogue.Coord,System.ValueTuple{System.Int32,System.Int32})">
            <summary>
            True if either the x-values or y-values are not equal.
            </summary>
            <param name="c"></param>
            <param name="tuple"></param>
            <returns>
            True if either the x-values or y-values are not equal, false if they are both equal.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.op_Equality(System.ValueTuple{System.Int32,System.Int32},GoRogue.Coord)">
            <summary>
            True if the two point's x and y values are equal.
            </summary>
            <param name="tuple"></param>
            <param name="c"></param>
            <returns>True if the two positions are equal, false if not.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Inequality(System.ValueTuple{System.Int32,System.Int32},GoRogue.Coord)">
            <summary>
            True if either the x-values or y-values are not equal.
            </summary>
            <param name="tuple"></param>
            <param name="c"></param>
            <returns>
            True if either the x-values or y-values are not equal, false if they are both equal.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.Equals(System.ValueTuple{System.Int32,System.Int32})">
            <summary>
            True if the given position has equal x and y values to the current one.
            </summary>
            <param name="other">Point to compare.</param>
            <returns>True if the two positions are equal, false if not.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Dice">
            <summary>
            The most important <see cref="N:GoRogue.DiceNotation"/> class -- contains functions to roll dice, and to retrieve an
            <see cref="T:GoRogue.DiceNotation.IDiceExpression"/> instance representing a given expression.
            </summary>
        </member>
        <member name="F:GoRogue.DiceNotation.Dice.DiceParser">
            <summary>
            The parser that will be used to parse dice expressions given to the <see cref="M:GoRogue.DiceNotation.Dice.Parse(System.String)"/> and <see cref="M:GoRogue.DiceNotation.Dice.Roll(System.String,Troschuetz.Random.IGenerator)"/>
            functions. If you want to use a custom parser, you can assign an instance to this field.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Dice.Parse(System.String)">
            <summary>
            Uses the <see cref="T:GoRogue.DiceNotation.IParser"/> specified in the <see cref="F:GoRogue.DiceNotation.Dice.DiceParser"/> variable to produce an <see cref="T:GoRogue.DiceNotation.IDiceExpression"/>
            instance representing the given dice expression.
            </summary>
            <remarks>
            Generally speaking, dice-parsing via the standard <see cref="M:GoRogue.DiceNotation.Dice.Roll(System.String,Troschuetz.Random.IGenerator)"/> method is extremely fast.  However, if
            you are repeating a dice roll many times, in a case where maximum performance is absolutely necessary, there is some benefit to
            retrieving an <see cref="T:GoRogue.DiceNotation.IDiceExpression"/> instance instead
            of using the Roll function, and calling that expressions's <see cref="M:GoRogue.DiceNotation.IDiceExpression.Roll(Troschuetz.Random.IGenerator)"/> method whenever a result
            is required.
            </remarks>
            <param name="expression">The string dice expression to parse.</param>
            <returns>An <see cref="T:GoRogue.DiceNotation.IDiceExpression"/> instance representing the parsed string.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Dice.Roll(System.String,Troschuetz.Random.IGenerator)">
            <summary>
            Uses the <see cref="T:GoRogue.DiceNotation.IParser"/> specified in the <see cref="F:GoRogue.DiceNotation.Dice.DiceParser"/> variable to parse the given dice expression,
            roll it, and return the result.  This is the standard method for rolling dice.
            </summary>
            <remarks>
            This method is convenient and typically very fast, however technically, parsing is computationally
            more expensive than evaluation. If a dice expression will be rolled many times in a situation where
            maximum performance is required, it is more efficient to use the <see cref="M:GoRogue.DiceNotation.Dice.Parse(System.String)"/> method
            once, and use the resulting <see cref="T:GoRogue.DiceNotation.IDiceExpression"/> instance to roll the expression each time it
            is needed.
            </remarks>
            <param name="expression">The string dice expression to parse.</param>
            <param name="random">
            RNG to use to perform the roll. If null is specified, the default RNG is used.
            </param>
            <returns>The result of evaluating the dice expression given.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.DiceExpression">
            <summary>
            The default class for representing a parsed dice expression.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.DiceExpression.#ctor(GoRogue.DiceNotation.Terms.ITerm)">
            <summary>
            Constructor. Takes the last term in the dice expression (the root of the expression tree).
            </summary>
            <param name="termToEvaluate">
            The root of the expression tree -- by evaluating this term, all others will be evaluated recursively.
            </param>
        </member>
        <member name="M:GoRogue.DiceNotation.DiceExpression.MaxRoll">
            <summary>
            Returns the maximum possible result of the dice expression.
            </summary>
            <returns>The maximum possible result of the dice expression.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.DiceExpression.MinRoll">
            <summary>
            Returns the minimum possible result of the dice expression.
            </summary>
            <returns>The minimum possible result of the dice expression.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.DiceExpression.Roll(Troschuetz.Random.IGenerator)">
            <summary>
            Rolls the expression using the RNG given, returning the result.
            </summary>
            <param name="rng">The RNG to use. If null is specified, the default RNG is used.</param>
            <returns>The result obtained by rolling the dice expression.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.DiceExpression.ToString">
            <summary>
            Returns a parenthesized string representing the dice expression in dice notation
            </summary>
            <returns>A paranethesized string representing the expression.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Exceptions.ImpossibleDieException">
            <summary>
            Exception that is thrown when a die is attempted to be constructed with an invalid number of sides.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.ImpossibleDieException.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.ImpossibleDieException.#ctor(System.String)">
            <summary>
            Constructor, taking a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.ImpossibleDieException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor, taking a specified error message and the exception that caused this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter
            is not a null reference, the current exception is raised in a catch block that handles
            the inner exception.
            </param>
        </member>
        <member name="T:GoRogue.DiceNotation.Exceptions.InvalidChooseException">
            <summary>
            Exception that is thrown when a dice term is constructed with a 'k' choose operation to keep
            an invalid number of dice.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidChooseException.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidChooseException.#ctor(System.String)">
            <summary>
            Constructor, taking a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidChooseException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor, taking a specified error message and a reference to the inner exception that
            is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter
            is not a null reference, the current exception is raised in a catch block that handles
            the inner exception.
            </param>
        </member>
        <member name="T:GoRogue.DiceNotation.Exceptions.InvalidMultiplicityException">
            <summary>
            Exception that is thrown when a dice term is constructed with a negative number of dice.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidMultiplicityException.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidMultiplicityException.#ctor(System.String)">
            <summary>
            Constructor, taking a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidMultiplicityException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor, taking a specified error message and a reference to the inner exception that
            is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter
            is not a null reference, the current exception is raised in a catch block that handles
            the inner exception.
            </param>
        </member>
        <member name="T:GoRogue.DiceNotation.Exceptions.InvalidSyntaxException">
            <summary>
            Exception that is thrown when a the syntax of a dice notation string is determined to be invalid.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidSyntaxException.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidSyntaxException.#ctor(System.String)">
            <summary>
            Constructor, taking a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidSyntaxException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor, taking a specified error message and a reference to the inner exception that
            is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter
            is not a null reference, the current exception is raised in a catch block that handles
            the inner exception.
            </param>
        </member>
        <member name="T:GoRogue.DiceNotation.IDiceExpression">
            <summary>
            Interface for class representing a parsed dice expression. Returned by <see cref="T:GoRogue.DiceNotation.IParser"/> implementations.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.IDiceExpression.MaxRoll">
            <summary>
            Returns the maximum possible result of the dice expression (the highest it could be).
            </summary>
            <remarks>
            Typically this can be implemented by calling <see cref="M:GoRogue.DiceNotation.IDiceExpression.Roll(Troschuetz.Random.IGenerator)"/> and passing in a <see cref="T:GoRogue.Random.MaxRandom"/> instance.
            </remarks>
            <returns>The maxiumum possible value that could be returned by this dice expression.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.IDiceExpression.MinRoll">
            <summary>
            Returns the minimum possible result of the dice expression (the lowest it could be).
            </summary>
            <remarks>
            Typically this can be implemented by calling <see cref="M:GoRogue.DiceNotation.IDiceExpression.Roll(Troschuetz.Random.IGenerator)"/> and passing in a <see cref="T:GoRogue.Random.MinRandom"/> instance.
            </remarks>
            <returns>The miniumum possible value that could be returned by this dice expression.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.IDiceExpression.Roll(Troschuetz.Random.IGenerator)">
            <summary>
            Rolls the expression using the RNG given, returning the result.
            </summary>
            <param name="rng">The RNG to use. If null is specified, the default RNG is used.</param>
            <returns>The result obtained by rolling the dice expression.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.IParser">
            <summary>
            Interface for a class that parses a string representing a dice expression into an
            <see cref="T:GoRogue.DiceNotation.IDiceExpression"/> instance.  You might implement this if you need to implement a custom
            dice parser.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.IParser.Parse(System.String)">
            <summary>
            Parses the dice expression spcified into an <see cref="T:GoRogue.DiceNotation.IDiceExpression"/> instance.
            </summary>
            <param name="expression">The expression to parse.</param>
            <returns>
            An <see cref="T:GoRogue.DiceNotation.IDiceExpression"/> representing the given expression, that can "roll" the expression on command.
            </returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Parser">
            <summary>
            Default class for parsing a string representing a dice expression into an <see cref="T:GoRogue.DiceNotation.IDiceExpression"/> instance.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Parser.Parse(System.String)">
            <summary>
            Parses the dice expression spcified into an <see cref="T:GoRogue.DiceNotation.IDiceExpression"/> instance.
            </summary>
            <remarks>
            Breaks the dice expression into postfix form, and evaluates the postfix expression to the
            degree necessary to produce the appropriate chain of <see cref="T:GoRogue.DiceNotation.Terms.ITerm"/> instances.
            </remarks>
            <param name="expression">The expression to parse.</param>
            <returns>
            An <see cref="T:GoRogue.DiceNotation.IDiceExpression"/> representing the given expression, that can "roll" the expression on command.
            </returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.AddTerm">
            <summary>
            Term representing the addition operator -- adds two terms together.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.AddTerm.#ctor(GoRogue.DiceNotation.Terms.ITerm,GoRogue.DiceNotation.Terms.ITerm)">
            <summary>
            Constructor. Takes the two terms to add.
            </summary>
            <param name="term1">Left-hand side.</param>
            <param name="term2">Right-hand side.</param>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.AddTerm.Term1">
            <summary>
            First term (left-hand side).
            </summary>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.AddTerm.Term2">
            <summary>
            Second term (right-hand side).
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.AddTerm.GetResult(Troschuetz.Random.IGenerator)">
            <summary>
            Adds its two terms together, evaluating those two terms as necessary.
            </summary>
            <param name="rng">The rng to use, passed to other terms.</param>
            <returns>The result of adding <see cref="P:GoRogue.DiceNotation.Terms.AddTerm.Term1"/> and <see cref="P:GoRogue.DiceNotation.Terms.AddTerm.Term2"/>.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.AddTerm.ToString">
            <summary>
            Converts to a parenthesized string.
            </summary>
            <returns>A parenthesized string representing the term.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.ConstantTerm">
            <summary>
            Base term -- represents a numerical constant.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.ConstantTerm.#ctor(System.Int32)">
            <summary>
            Constructor. Takes the numerical constant it represents.
            </summary>
            <param name="value">The numerical value this term represents.</param>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.ConstantTerm.GetResult(Troschuetz.Random.IGenerator)">
            <summary>
            Returns the numerical constant it represents. RNG is unused.
            </summary>
            <param name="rng">(Unused) rng.</param>
            <returns>The numerical constant this term represents.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.ConstantTerm.ToString">
            <summary>
            Returns a string representation of this constant.
            </summary>
            <returns>The numerical constant being represented, as a string.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.DiceTerm">
            <summary>
            Represents a dice term, eg 1d4 or 2d6.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.DiceTerm.#ctor(GoRogue.DiceNotation.Terms.ITerm,GoRogue.DiceNotation.Terms.ITerm)">
            <summary>
            Constructor. Takes the terms representing multiplicity and number of sides.
            </summary>
            <param name="multiplicity">
            Term representing the number of dice being rolled -- 2d6 has multiplicity 2.
            </param>
            <param name="sides">
            Term representing the number of sides the dice have -- 2d6 has 6 sides.
            </param>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.DiceTerm.DiceResults">
            <summary>
            An enumerable of integers representing the result of each dice roll. The expression 2d6
            rolls 2 dice, and as such this enumerable would be of length 2 and contain the result of
            each individual die.
            </summary>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.DiceTerm.LastMultiplicity">
            <summary>
            The result of evaluating the <see cref="P:GoRogue.DiceNotation.Terms.DiceTerm.Multiplicity"/> term that was used during the last call to <see cref="M:GoRogue.DiceNotation.Terms.DiceTerm.GetResult(Troschuetz.Random.IGenerator)"/>.
            </summary>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.DiceTerm.LastSidedness">
            <summary>
            The result of evaluating the <see cref="P:GoRogue.DiceNotation.Terms.DiceTerm.Sides"/> term that was used during the last call to <see cref="M:GoRogue.DiceNotation.Terms.DiceTerm.GetResult(Troschuetz.Random.IGenerator)"/>.
            </summary>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.DiceTerm.Multiplicity">
            <summary>
            Term representing the number of dice being rolled -- 2d6 has multiplicity 2.
            </summary>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.DiceTerm.Sides">
            <summary>
            Term representing the number of sides the dice have -- 2d6 has 6 sides.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.DiceTerm.GetResult(Troschuetz.Random.IGenerator)">
            <summary>
            Rolls the dice, returning the sum.
            </summary>
            <param name="rng">The RNG to use for rolling,</param>
            <returns>The sum of the roll.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.DiceTerm.ToString">
            <summary>
            Gets a parenthesized string representation of the dice term, eg (2d6).
            </summary>
            <returns>A parenthesized representation of the term.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.DivideTerm">
            <summary>
            Term representing the division operator -- divides the first term by the second.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.DivideTerm.#ctor(GoRogue.DiceNotation.Terms.ITerm,GoRogue.DiceNotation.Terms.ITerm)">
            <summary>
            Constructor. Takes the two terms to divide.
            </summary>
            <param name="term1">The first term (left-hand side).</param>
            <param name="term2">The second term (right-hand side).</param>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.DivideTerm.Term1">
            <summary>
            The first term (left-hand side).
            </summary>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.DivideTerm.Term2">
            <summary>
            The second term (right-hand side).
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.DivideTerm.GetResult(Troschuetz.Random.IGenerator)">
            <summary>
            Divides the first term by the second, evaluating those two terms as necessary.
            </summary>
            <param name="rng">The rng to used -- passed to other terms.</param>
            <returns>The result of evaluating <see cref="P:GoRogue.DiceNotation.Terms.DivideTerm.Term1"/> / <see cref="P:GoRogue.DiceNotation.Terms.DivideTerm.Term2"/>.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.DivideTerm.ToString">
            <summary>
            Returns a parenthesized string representing the operation.
            </summary>
            <returns>A parenthesized string representing the operation.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.ITerm">
            <summary>
            Interface for an evaluatable term of a dice expression.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.ITerm.GetResult(Troschuetz.Random.IGenerator)">
            <summary>
            Evaluates the term and returns the result.
            </summary>
            <param name="rng">The rng to use.</param>
            <returns>The result of evaluating the term.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.KeepTerm">
            <summary>
            Term represnting the keep operator -- keeping only the n highest dice from a dice term.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.KeepTerm.#ctor(GoRogue.DiceNotation.Terms.ITerm,GoRogue.DiceNotation.Terms.DiceTerm)">
            <summary>
            Constructor. Takes a term representing the number of dice to keep, and the dice term to
            operate on.
            </summary>
            <param name="keep">Term representing the number of dice to keep.</param>
            <param name="diceTerm">The dice term to operate on.</param>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.KeepTerm.GetResult(Troschuetz.Random.IGenerator)">
            <summary>
            Evaluates the term (as well as the dice expression), returning the sum of the highest n
            rolls in the dice term.
            </summary>
            <param name="rng">The rng to use -- passed to the dice term being operated on.</param>
            <returns>
            The sum of the highest n rolls of the dice term being operated on, where n is equal to
            the value of the keep variable taken in the constructor.
            </returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.KeepTerm.ToString">
            <summary>
            Returns a parenthesized string representing the term -- eg (4d6k3) or (2d6k2)
            </summary>
            <returns>A parenthesized string representing the term</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.MultiplyTerm">
            <summary>
            Term representing the multiplication operator -- multiplies <see cref="P:GoRogue.DiceNotation.Terms.MultiplyTerm.Term1"/> and <see cref="P:GoRogue.DiceNotation.Terms.MultiplyTerm.Term2"/>.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.MultiplyTerm.#ctor(GoRogue.DiceNotation.Terms.ITerm,GoRogue.DiceNotation.Terms.ITerm)">
            <summary>
            Constructor. Takes the terms that will be multiplied.
            </summary>
            <param name="term1">The first term (left-hand side).</param>
            <param name="term2">The second term (left-hand side).</param>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.MultiplyTerm.Term1">
            <summary>
            The first term (left-hand side).
            </summary>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.MultiplyTerm.Term2">
            <summary>
            The second term (right-hand side).
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.MultiplyTerm.GetResult(Troschuetz.Random.IGenerator)">
            <summary>
            Multiplies the first term by the second, evaluating those two terms as necessary.
            </summary>
            <param name="rng">The rng to used -- passed to other terms.</param>
            <returns>The result of evaluating <see cref="P:GoRogue.DiceNotation.Terms.MultiplyTerm.Term1"/> * <see cref="P:GoRogue.DiceNotation.Terms.MultiplyTerm.Term2"/>.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.MultiplyTerm.ToString">
            <summary>
            Returns a parenthesized string representing the term.
            </summary>
            <returns>A parenthesized string representing the term.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.SubtractTerm">
            <summary>
            Term representing the subtraction operator -- subtracts the second term from the first.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.SubtractTerm.#ctor(GoRogue.DiceNotation.Terms.ITerm,GoRogue.DiceNotation.Terms.ITerm)">
            <summary>
            Constructor. Takes the two terms to subtract.
            </summary>
            <param name="term1">The first term (left-hand side).</param>
            <param name="term2">The second term (right-hand side).</param>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.SubtractTerm.Term1">
            <summary>
            The first term (left-hand side).
            </summary>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.SubtractTerm.Term2">
            <summary>
            The second term (right-hand side).
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.SubtractTerm.GetResult(Troschuetz.Random.IGenerator)">
            <summary>
            Subtracts the second term from the first, evaluating those two terms as necessary.
            </summary>
            <param name="rng">The rng to used -- passed to other terms.</param>
            <returns>The result of evaluating <see cref="P:GoRogue.DiceNotation.Terms.SubtractTerm.Term1"/> - <see cref="P:GoRogue.DiceNotation.Terms.SubtractTerm.Term2"/>.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.SubtractTerm.ToString">
            <summary>
            Returns a parenthesized string representing the operation.
            </summary>
            <returns>A parenthesized string representing the operation.</returns>
        </member>
        <member name="T:GoRogue.Direction">
            <summary>
            Represents the concept of a "direction" on a grid, and "defines" the coordinate plane GoRogue
            uses via the <see cref="P:GoRogue.Direction.YIncreasesUpward"/> flag. Interacts with Coord and other
            supported library's equivalent types to allow easy translation of positions in a direction, and
            contains numerous helper functions for retrieving directions in various orders, getting direction
            closest to a line, etc.
            </summary>
            <remarks>
            The static <see cref="P:GoRogue.Direction.YIncreasesUpward"/> flag defines the way that many GoRogue algorithms
            interpret the coordinate plane.  By default, this flag is false, meaning that the y-value of positions
            is assumed to DECREASE as you proceed in the direction defined by <see cref="P:GoRogue.Direction.UP"/>, and
            increase as you go downward.  If the coordinate plane is displayed on the screen, the origin would be
            the top left corner.  This default setting matches the typical console/computer graphic definition of the
            coordinate plane.  Setting the flag to true inverts this, so that the y-value of positions INCREASES
            as you proceed in the direction defined by <see cref="P:GoRogue.Direction.UP"/>.  This places the origin in the bottom
            left corner, and matches a typical mathmatical definition of a euclidean coordinate plane, as well as the scene
            coordinate plane defined by Unity and other game engines.
            </remarks>
        </member>
        <member name="M:GoRogue.Direction.Equals(System.Object)">
            <summary>
            Compares the current Direction to the object given.
            </summary>
            <param name="obj"/>
            <returns>True if the given object is a Direction with the same Type/dx/dy values, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.Direction.Equals(GoRogue.Direction)">
            <summary>
            Compares the current Direction to the one given.
            </summary>
            <param name="other"/>
            <returns>True if the given Direction has the same type and delta-y/delta-x values, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.Direction.GetHashCode">
            <summary>
            Returns a hash-value for this object.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.Direction.op_Equality(GoRogue.Direction,GoRogue.Direction)">
            <summary>
            Compares the two Direction instances.
            </summary>
            <param name="lhs"/>
            <param name="rhs"/>
            <returns>True if the two given Direction instances have the same Type and delta values, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.Direction.op_Inequality(GoRogue.Direction,GoRogue.Direction)">
            <summary>
            Compares the two BoundedRectangle instances.
            </summary>
            <param name="lhs"/>
            <param name="rhs"/>
            <returns>True if the two given Direction instances do NOT have the same Type and delta values, false otherwise.</returns>
        </member>
        <member name="T:GoRogue.Direction.Types">
            <summary>
            Enum representing Direction types. Each Direction instance has a <see cref="F:GoRogue.Direction.Type"/> field
            which contains the corresponding value from this enum.  Useful for easy mapping of Direction
            types to a primitive type (for cases like a switch statement).
            </summary>
        </member>
        <member name="F:GoRogue.Direction.Types.UP">
            <summary>
            Type for <see cref="P:GoRogue.Direction.UP"/>.
            </summary>
        </member>
        <member name="F:GoRogue.Direction.Types.UP_RIGHT">
            <summary>
            Type for <see cref="P:GoRogue.Direction.UP_RIGHT"/>.
            </summary>
        </member>
        <member name="F:GoRogue.Direction.Types.RIGHT">
            <summary>
            Type for <see cref="P:GoRogue.Direction.RIGHT"/>.
            </summary>
        </member>
        <member name="F:GoRogue.Direction.Types.DOWN_RIGHT">
            <summary>
            Type for <see cref="P:GoRogue.Direction.DOWN_RIGHT"/>.
            </summary>
        </member>
        <member name="F:GoRogue.Direction.Types.DOWN">
            <summary>
            Type for <see cref="P:GoRogue.Direction.DOWN"/>.
            </summary>
        </member>
        <member name="F:GoRogue.Direction.Types.DOWN_LEFT">
            <summary>
            Type for <see cref="P:GoRogue.Direction.DOWN_LEFT"/>.
            </summary>
        </member>
        <member name="F:GoRogue.Direction.Types.LEFT">
            <summary>
            Type for <see cref="P:GoRogue.Direction.LEFT"/>.
            </summary>
        </member>
        <member name="F:GoRogue.Direction.Types.UP_LEFT">
            <summary>
            Type for <see cref="P:GoRogue.Direction.UP_LEFT"/>.
            </summary>
        </member>
        <member name="F:GoRogue.Direction.Types.NONE">
            <summary>
            Type for <see cref="P:GoRogue.Direction.NONE"/>.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.DOWN">
            <summary>
            Down direction.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.DOWN_LEFT">
            <summary>
            Down-left direction.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.DOWN_RIGHT">
            <summary>
            Down-right direction.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.LEFT">
            <summary>
            Left direction.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.NONE">
            <summary>
            No direction.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.RIGHT">
            <summary>
            Right direction.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.UP">
            <summary>
            Up direction.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.UP_LEFT">
            <summary>
            Up-left direction.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.UP_RIGHT">
            <summary>
            Up-right direction.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.YIncreasesUpward">
            <summary>
            Whether or not a positive y-value indicates an upward change. If true, Directions with an
            upwards component represent a positive change in y-value, and ones with downward components
            represent a negative change in y-value.  Setting this to false (which is the default) inverts
            this.
            </summary>
        </member>
        <member name="F:GoRogue.Direction.DeltaX">
            <summary>
            Change in x-value represented by this direction.
            </summary>
        </member>
        <member name="F:GoRogue.Direction.DeltaY">
            <summary>
            Change in y-value represented by this direction.
            </summary>
        </member>
        <member name="F:GoRogue.Direction.Type">
            <summary>
            Enum type corresponding to direction being represented.
            </summary>
        </member>
        <member name="M:GoRogue.Direction.GetCardinalDirection(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Returns the cardinal direction that most closely matches the degree heading of the given
            line. Rounds clockwise if the heading is exactly on a diagonal direction. Similar to
            <see cref="M:GoRogue.Direction.GetDirection(GoRogue.Coord,GoRogue.Coord)"/>, except this function returns only cardinal directions.
            </summary>
            <param name="start">Starting coordinate of the line.</param>
            <param name="end">Ending coordinate of the line.</param>
            <returns>
            The cardinal direction that most closely matches the heading indicated by the given line.
            </returns>
        </member>
        <member name="M:GoRogue.Direction.GetCardinalDirection(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the cardinal direction that most closely matches the degree heading of the given
            line. Rounds clockwise if the heading is exactly on a diagonal direction. Similar to
            <see cref="M:GoRogue.Direction.GetDirection(System.Int32,System.Int32,System.Int32,System.Int32)"/>, except this function returns only cardinal directions.
            </summary>
            <param name="startX">X-coordinate of the starting position of the line.</param>
            <param name="startY">Y-coordinate of the starting position of the line.</param>
            <param name="endX">X-coordinate of the ending position of the line.</param>
            <param name="endY">Y-coordinate of the ending position of the line.</param>
            <returns>
            The cardinal direction that most closely matches the heading indicated by the given line.
            </returns>
        </member>
        <member name="M:GoRogue.Direction.GetCardinalDirection(GoRogue.Coord)">
            <summary>
            Returns the cardinal direction that most closely matches the degree heading of a line
            with the given delta-change values. Rounds clockwise if exactly on a diagonal. Similar to
            <see cref="M:GoRogue.Direction.GetDirection(GoRogue.Coord)"/>, except this function returns only cardinal directions.
            </summary>
            <param name="deltaChange">
            Vector representing the change in x and change in y across the line (deltaChange.X is the
            change in x, deltaChange.Y is the change in y).
            </param>
            <returns>
            The cardinal direction that most closely matches the degree heading of the given line.
            </returns>
        </member>
        <member name="M:GoRogue.Direction.GetCardinalDirection(System.Int32,System.Int32)">
            <summary>
            Returns the cardinal direction that most closely matches the degree heading of a line
            with the given dx and dy values. Rounds clockwise if exactly on a diagonal direction.
            Similar to <see cref="M:GoRogue.Direction.GetDirection(System.Int32,System.Int32)"/>, except this function returns only cardinal directions.
            </summary>
            <param name="dx">The change in x-values across the line.</param>
            <param name="dy">The change in x-values across the line.</param>
            <returns>
            The cardinal direction that most closely matches the degree heading of the given line.
            </returns>
        </member>
        <member name="M:GoRogue.Direction.GetDirection(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Returns the direction that most closely matches the degree heading of the given line.
            Rounds clockwise if the heading is exactly between two directions.
            </summary>
            <param name="start">Starting coordinate of the line.</param>
            <param name="end">Ending coordinate of the line.</param>
            <returns>
            The direction that most closely matches the heading indicated by the given line.
            </returns>
        </member>
        <member name="M:GoRogue.Direction.GetDirection(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the direction that most closely matches the degree heading of the given line.
            Rounds clockwise if the heading is exactly between two directions.
            </summary>
            <param name="startX">X-coordinate of the starting position of the line.</param>
            <param name="startY">Y-coordinate of the starting position of the line.</param>
            <param name="endX">X-coordinate of the ending position of the line.</param>
            <param name="endY">Y-coordinate of the ending position of the line.</param>
            <returns>
            The direction that most closely matches the heading indicated by the given line.
            </returns>
        </member>
        <member name="M:GoRogue.Direction.GetDirection(GoRogue.Coord)">
            <summary>
            Returns the direction that most closely matches the degree heading of a line with the
            given delta-change values. Rounds clockwise if the heading is exactly between two directions.
            </summary>
            <param name="deltaChange">
            Vector representing the change in x and change in y across the line (deltaChange.X is the
            change in x, deltaChange.Y is the change in y).
            </param>
            <returns>
            The direction that most closely matches the heading indicated by the given input.
            </returns>
        </member>
        <member name="M:GoRogue.Direction.GetDirection(System.Int32,System.Int32)">
            <summary>
            Returns the direction that most closely matches the degree heading of a line with the
            given dx and dy values. Rounds clockwise if the heading is exactly between two directions.
            </summary>
            <param name="dx">The change in x-values across the line.</param>
            <param name="dy">The change in y-values across the line.</param>
            <returns>
            The direction that most closely matches the heading indicated by the given input.
            </returns>
        </member>
        <member name="M:GoRogue.Direction.op_Subtraction(GoRogue.Direction,System.Int32)">
            <summary>
            Moves the direction counter-clockwise <paramref name="i"/> times.
            </summary>
            <param name="d"/>
            <param name="i"/>
            <returns>
            The given direction moved counter-clockwise <paramref name="i"/> times.
            </returns>
        </member>
        <member name="M:GoRogue.Direction.op_Decrement(GoRogue.Direction)">
            <summary>
            Moves the direction counter-clockwise by one.
            </summary>
            <param name="d"/>
            <returns>The direction one unit counterclockwise of <paramref name="d"/>.</returns>
        </member>
        <member name="M:GoRogue.Direction.op_Addition(GoRogue.Direction,System.Int32)">
            <summary>
            Moves the direction clockwise <paramref name="i"/> times.
            </summary>
            <param name="d"/>
            <param name="i"/>
            <returns>
            The given direction moved clockwise <paramref name="i"/> times.
            </returns>
        </member>
        <member name="M:GoRogue.Direction.op_Increment(GoRogue.Direction)">
            <summary>
            Moves the direction clockwise by one.
            </summary>
            <param name="d"/>
            <returns>The direction one unit clockwise of <paramref name="d"/>.</returns>
        </member>
        <member name="M:GoRogue.Direction.ToDirection(GoRogue.Direction.Types)">
            <summary>
            Gets the Direction class instance representing the direction type specified.
            </summary>
            <param name="directionType">The enum value for the direction.</param>
            <returns>The direction class representing the given direction.</returns>
        </member>
        <member name="M:GoRogue.Direction.ToString">
            <summary>
            Writes the string (eg. "UP", "UP_RIGHT", etc.) for the direction.
            </summary>
            <returns>String representation of the direction.</returns>
        </member>
        <member name="M:GoRogue.Direction.op_Addition(Microsoft.Xna.Framework.Point,GoRogue.Direction)">
            <summary>
            Translates the given position by one unit in the given direction.
            </summary>
            <param name="p"/>
            <param name="d"/>
            <returns>
            Position (p.X + d.DeltaX, p.Y + d.DeltaY).
            </returns>
        </member>
        <member name="M:GoRogue.Direction.op_Addition(System.Drawing.Point,GoRogue.Direction)">
            <summary>
            Translates the given position by one unit in the given direction.
            </summary>
            <param name="p"/>
            <param name="d"/>
            <returns>
            Position (p.X + d.DeltaX, p.Y + d.DeltaY).
            </returns>
        </member>
        <member name="M:GoRogue.Direction.op_Addition(System.ValueTuple{System.Int32,System.Int32},GoRogue.Direction)">
            <summary>
            Translates the given position by one unit in the given direction.
            </summary>
            <param name="tuple"/>
            <param name="d"/>
            <returns>
            Tuple (tuple.y + d.DeltaX, tuple.y + d.DeltaY).
            </returns>
        </member>
        <member name="T:GoRogue.DisjointSet">
            <summary>
            Basic representation of a disjoint set data structure.
            </summary>
            <remarks>
            For reasons pertaining to optimization, this disjoint set implementation does not use
            generics, and instead holds integer values, which MUST be exactly all integer values in range
            [0, num_items_in_set - 1].  Thus, you will need to assign appropriate IDs to objects you intend
            to add and map them appropriately.
            </remarks>
        </member>
        <member name="M:GoRogue.DisjointSet.#ctor(System.Int32)">
            <summary>
            Constructor. The disjoint set will contain all values in range [0, <paramref name="size"/> - 1].
            </summary>
            <param name="size">(Max) size of the disjoint set.</param>
        </member>
        <member name="P:GoRogue.DisjointSet.Count">
            <summary>
            Number of distinct sets.
            </summary>
        </member>
        <member name="M:GoRogue.DisjointSet.AsReadOnly">
            <summary>
            Returns a read-only representation of the disjoint set.
            </summary>
            <returns>A read-only representation of the disjoint set.</returns>
        </member>
        <member name="M:GoRogue.DisjointSet.Find(System.Int32)">
            <summary>
            Returns the parent of the set containing <paramref name="obj"/>, performing path compression
            as the search is completed.
            </summary>
            <param name="obj">Object to search for.</param>
            <returns>The parent of the object given.</returns>
        </member>
        <member name="M:GoRogue.DisjointSet.InSameSet(System.Int32,System.Int32)">
            <summary>
            Returns true if the two objects specified are in the same set.
            </summary>
            <param name="obj1"/>
            <param name="obj2"/>
            <returns>True if the two objects are in the same set, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.DisjointSet.MakeUnion(System.Int32,System.Int32)">
            <summary>
            Performs a union of the sets containing the two objects specified. After this operation,
            every element in the sets containing the two objects specified will be part of one larger set.
            </summary>
            <remarks>If the two elements are already in the same set, nothing is done.</remarks>
            <param name="obj1"/>
            <param name="obj2"/>
        </member>
        <member name="M:GoRogue.DisjointSet.ToString">
            <summary>
            Returns a string representation of the DisjointSet, showing parents and all elements in
            their set.
            </summary>
            <returns>A string representation of the DisjointSet.</returns>
        </member>
        <member name="T:GoRogue.Distance">
            <summary>
            Class representing methods of calculating distance on a grid. You cannot create instances of this
            class using a constructor -- instead this class contains static instances representing the
            various distance calculations.
            </summary>
            <remarks>
            Provides functions that calculate the distance between two points according to the distance
            measurement being used. Instances of Distance are also implicitly convertible to <see cref="T:GoRogue.AdjacencyRule"/>
            types (since an adjacency method is implied by a distance calculation), and they may also be explicitly
            casted to the appropriate 2D <see cref="T:GoRogue.Radius"/> types.
            </remarks>
        </member>
        <member name="F:GoRogue.Distance.CHEBYSHEV">
            <summary>
            Represents chebyshev distance (equivalent to 8-way movement with no extra cost for diagonals).
            </summary>
        </member>
        <member name="F:GoRogue.Distance.EUCLIDEAN">
            <summary>
            Represents euclidean distance (equivalent to 8-way movement with ~1.41 movement cost for diagonals).
            </summary>
        </member>
        <member name="F:GoRogue.Distance.MANHATTAN">
            <summary>
            Represents manhattan distance (equivalent to 4-way, cardinal-only movement).
            </summary>
        </member>
        <member name="F:GoRogue.Distance.Type">
            <summary>
            Enum value representing the method of calcuating distance -- useful for using
            Distance types in switch statements.
            </summary>
        </member>
        <member name="T:GoRogue.Distance.Types">
            <summary>
            Enum representing Distance types. Each Distance instance has a <see cref="F:GoRogue.Distance.Type"/> field
            which contains the corresponding value from this enum.  Useful for easy mapping of Distance
            types to a primitive type (for cases like a switch statement).
            </summary>
        </member>
        <member name="F:GoRogue.Distance.Types.MANHATTAN">
            <summary>
            Enum type for <see cref="F:GoRogue.Distance.MANHATTAN"/>.
            </summary>
        </member>
        <member name="F:GoRogue.Distance.Types.EUCLIDEAN">
            <summary>
            Enum type for <see cref="F:GoRogue.Distance.EUCLIDEAN"/>.
            </summary>
        </member>
        <member name="F:GoRogue.Distance.Types.CHEBYSHEV">
            <summary>
            Enum type for <see cref="F:GoRogue.Distance.CHEBYSHEV"/>.
            </summary>
        </member>
        <member name="M:GoRogue.Distance.op_Explicit(GoRogue.Distance)~GoRogue.Radius">
            <summary>
            Allows explicit casting to <see cref="T:GoRogue.Radius"/> type.
            </summary>
            <remarks>
            The 2D radius shape corresponding to the definition of a radius according to the distance calculation
            casted will be returned.
            </remarks>
            <param name="distance"/>
        </member>
        <member name="M:GoRogue.Distance.op_Implicit(GoRogue.Distance)~GoRogue.AdjacencyRule">
            <summary>
            Allows implicit casting to the <see cref="T:GoRogue.AdjacencyRule"/> type. 
            </summary>
            <remarks>
            The adjacency rule corresponding to the definition of a adjacency according to the
            distance calculation casted will be returned.
            </remarks>
            <param name="distance"/>
        </member>
        <member name="M:GoRogue.Distance.ToDistance(GoRogue.Distance.Types)">
            <summary>
            Gets the Distance class instance representing the distance type specified.
            </summary>
            <param name="distanceType">The enum value for the distance calculation method.</param>
            <returns>The Distance class representing the given distance calculation.</returns>
        </member>
        <member name="M:GoRogue.Distance.Calculate(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the distance between the two (3D) points specified.
            </summary>
            <param name="startX">X-Coordinate of the starting point.</param>
            <param name="startY">Y-Coordinate of the starting point.</param>
            <param name="startZ">Z-Coordinate of the starting point.</param>
            <param name="endX">X-Coordinate of the ending point.</param>
            <param name="endY">Y-Coordinate of the ending point.</param>
            <param name="endZ">Z-Coordinate of the ending point.</param>
            <returns>The distance between the two points.</returns>
        </member>
        <member name="M:GoRogue.Distance.Calculate(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns the distance between the two (3D) points specified.
            </summary>
            <param name="startX">X-Coordinate of the starting point.</param>
            <param name="startY">Y-Coordinate of the starting point.</param>
            <param name="startZ">Z-Coordinate of the starting point.</param>
            <param name="endX">X-Coordinate of the ending point.</param>
            <param name="endY">Y-Coordinate of the ending point.</param>
            <param name="endZ">Z-Coordinate of the ending point.</param>
            <returns>The distance between the two points.</returns>
        </member>
        <member name="M:GoRogue.Distance.Calculate(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the distance between the two (2D) points specified.
            </summary>
            <param name="startX">X-Coordinate of the starting point.</param>
            <param name="startY">Y-Coordinate of the starting point.</param>
            <param name="endX">X-Coordinate of the ending point.</param>
            <param name="endY">Y-Coordinate of the ending point.</param>
            <returns>The distance between the two points.</returns>
        </member>
        <member name="M:GoRogue.Distance.Calculate(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Returns the distance between the two (2D) points specified.
            </summary>
            <param name="start">Starting point.</param>
            <param name="end">Ending point.</param>
            <returns>The distance between the two points.</returns>
        </member>
        <member name="M:GoRogue.Distance.Calculate(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns the distance between the two (2D) points specified.
            </summary>
            <param name="startX">X-Coordinate of the starting point.</param>
            <param name="startY">Y-Coordinate of the starting point.</param>
            <param name="endX">X-Coordinate of the ending point.</param>
            <param name="endY">Y-Coordinate of the ending point.</param>
            <returns>The distance between the two points.</returns>
        </member>
        <member name="M:GoRogue.Distance.Calculate(GoRogue.Coord)">
            <summary>
            Returns the distance between two locations, given the change in X and change in Y value
            (specified by the X and Y values of the given vector).
            </summary>
            <param name="deltaChange">The delta-x and delta-y between the two locations.</param>
            ///
            <returns>The distance between two locations withe the given delta-change values.</returns>
        </member>
        <member name="M:GoRogue.Distance.Calculate(System.Int32,System.Int32)">
            <summary>
            Returns the distance between two locations, given the change in X and change in Y value.
            </summary>
            <param name="dx">The delta-x between the two locations.</param>
            <param name="dy">The delta-y between the two locations.</param>
            <returns>The distance between two locations with the given delta-change values.</returns>
        </member>
        <member name="M:GoRogue.Distance.Calculate(System.Double,System.Double)">
            <summary>
            Returns the distance between two locations, given the change in X and change in Y value.
            </summary>
            <param name="dx">The delta-x between the two locations.</param>
            <param name="dy">The delta-y between the two locations.</param>
            <returns>The distance between two locations with the given delta-change values.</returns>
        </member>
        <member name="M:GoRogue.Distance.Calculate(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the distance between two locations, given the change in X, Y, and Z value.
            </summary>
            <param name="dx">The delta-x between the two locations.</param>
            <param name="dy">The delta-y between the two locations.</param>
            <param name="dz">The delta-z between the two locations.</param>
            <returns>The distance between the locations with the given delta-change values.</returns>
        </member>
        <member name="M:GoRogue.Distance.Calculate(System.Double,System.Double,System.Double)">
            <summary>
            Returns the distance between two locations, given the change in X, Y, and Z value.
            </summary>
            <param name="dx">The delta-x between the two locations.</param>
            <param name="dy">The delta-y between the two locations.</param>
            <param name="dz">The delta-z between the two locations.</param>
            <returns>The distance between two locations with the given delta-change values.</returns>
        </member>
        <member name="M:GoRogue.Distance.Equals(System.Object)">
            <summary>
            Compares the current Distance to the object given.
            </summary>
            <param name="obj"/>
            <returns>True if the given object is a Distance with the same Type, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.Distance.Equals(GoRogue.Distance)">
            <summary>
            Compares the current Distance to the one given.
            </summary>
            <param name="other"/>
            <returns>True if the given Distance has the same Type, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.Distance.GetHashCode">
            <summary>
            Returns a hash-value for this object.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.Distance.op_Equality(GoRogue.Distance,GoRogue.Distance)">
            <summary>
            Compares the two Distance instances.
            </summary>
            <param name="lhs"/>
            <param name="rhs"/>
            <returns>True if the two given Distance instances have the same Type, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.Distance.op_Inequality(GoRogue.Distance,GoRogue.Distance)">
            <summary>
            Compares the two Distance instances.
            </summary>
            <param name="lhs"/>
            <param name="rhs"/>
            <returns>True if the two given Distance instances do NOT have the same Type, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.Distance.ToString">
            <summary>
            Returns a string representation of the distance calculation method represented.
            </summary>
            <returns>A string representation of the distance method represented.</returns>
        </member>
        <member name="T:GoRogue.EffectArgs">
            <summary>
            Default argument for any effect. Any class that is used as the template argument for an
            effect must inherit from this class.
            </summary>
            <remarks>
            These arguments allow cancellation of the triggering of a chain of effects when triggered by
            an <see cref="T:GoRogue.EffectTrigger`1"/>, as detailed in that class's documentation.
            </remarks>
        </member>
        <member name="F:GoRogue.EffectArgs.CancelTrigger">
            <summary>
            Whether or not the <see cref="T:GoRogue.EffectTrigger`1"/> should stop calling all subsequent effect's
            <see cref="M:GoRogue.Effect`1.Trigger(`0)"/> functions. See EffectTrigger's documentation for details.
            </summary>
        </member>
        <member name="M:GoRogue.EffectArgs.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:GoRogue.Effect`1">
             <summary>
             Class designed to represent any sort of in-game effect. This could be anything from a simple
             physical damage effect to a heal effect or permanent effects.  These might include AOE effects,
             damage over time effects, or even potentially a special effect that simply boosts a stat.
             </summary>
             <remarks>
             Effectively, the class is nothing more than a basis for the concept of something that
             happens, potentially instantaneously or potentially one or more times on a certain event
             (beginning of a turn, end of a turn, on taking damage, etc). The standard way to use the
             Effect class is to create a subclass of Effect, that at the very least implements the
             <see cref="M:GoRogue.Effect`1.OnTrigger(`0)"/> function, which should accomplish whatever the effect should
             do when it is triggered. The subclass can specify what parameter(s) the OnTrigger function
             needs to take in via the class's type parameter. If multiple arguments are needed, one should create
             a class that subclasses <see cref="T:GoRogue.EffectArgs"/> that contains all the parameters, and the effect subclass
             should then take an instance of the EffectArgs subclass as the single parameter. If no arguments are needed,
             then one may pass null as the parameter to Trigger.
            
             The concept of a duration is also built into the interface, and is considered to be in arbitrary units.  The duration
             concept is designed to be used with <see cref="T:GoRogue.EffectTrigger`1"/> instances, and has no effect when an effect is not
             utilized with an EffectTrigger.  The duration is interpreted as simply the number of times the effect's
             <see cref="M:GoRogue.Effect`1.Trigger(`0)"/>) function will be called before it will be removed from an EffectTrigger. If the effect
             is instantaneous, eg. it happens only when Trigger is called, on no particular event (such as a simple instant damage
             effect), then the duration specified in the constructor should be the static class constant
             <see cref="F:GoRogue.Effect`1.INSTANT"/>. If the effect is meant to have an infinite duration, or the effect wears off on some
             condition other than time passing, the duration may be set to <see cref="F:GoRogue.Effect`1.INFINITE"/>, and then manipulated
             appropriately to 0 when the effect has expired.
            
             More explanation of Effects and EffectTriggers, and usage examples, can be found at the GoRogue documentation site
             <a href="https://chris3606.github.io/GoRogue/articles">here</a>.
             </remarks>
             <typeparam name="TriggerArgs">
             The type of the parameter that will be specified to the <see cref="M:GoRogue.Effect`1.Trigger(`0)"/> function when called.
             </typeparam>
        </member>
        <member name="F:GoRogue.Effect`1.INFINITE">
            <summary>
            The value one should specify as the effect duration for an infinite effect, eg. an effect
            that will never expire or whose expiration time is arbitrary (for example, based on a condition
            other than the passing of time).
            </summary>
        </member>
        <member name="F:GoRogue.Effect`1.INSTANT">
            <summary>
            The value one should specify as the effect duaration for an instantaneous effect, eg. an
            effect that only occurs when Trigger is manually called, and thus cannot be added to an 
            <see cref="T:GoRogue.EffectTrigger`1"/>.
            </summary>
        </member>
        <member name="P:GoRogue.Effect`1.Name">
            <summary>
            The name of the effect.
            </summary>
        </member>
        <member name="P:GoRogue.Effect`1.Duration">
            <summary>
            The duration of the effect.
            </summary>
            <remarks>
            When the duration reaches 0, the Effect will be automatically removed from an <see cref="T:GoRogue.EffectTrigger`1"/>.
            The duration can be changed from a subclass, which can be used in <see cref="M:GoRogue.Effect`1.OnTrigger(`0)"/> to
            cause an effect to be "cancelled", eg. immediately expire, or to extend/reduce its duration.
            </remarks>
        </member>
        <member name="E:GoRogue.Effect`1.Expired">
            <summary>
            Event that fires as soon as the effect is about to expire. Fires after the
            <see cref="M:GoRogue.Effect`1.OnTrigger(`0)"/> function has been called but before it is
            removed from any <see cref="T:GoRogue.EffectTrigger`1"/> instances.
            </summary>
        </member>
        <member name="M:GoRogue.Effect`1.#ctor(System.String,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="name">Name for the effect.</param>
            <param name="startingDuration">Starting duration for the effect.</param>
        </member>
        <member name="M:GoRogue.Effect`1.Trigger(`0)">
            <summary>
            Should be called on instantaneous effects to trigger the effect.
            </summary>
            <remarks>
            Any effect that has INSTANT duration or duration 0 when this function is called
            will still have its <see cref="M:GoRogue.Effect`1.OnTrigger(`0)"/> function called.
            </remarks>
            <param name="args">Parameters that are passed to <see cref="M:GoRogue.Effect`1.OnTrigger(`0)"/>.
            Can be null.</param>
        </member>
        <member name="M:GoRogue.Effect`1.OnTrigger(`0)">
            <summary>
            Implement to take whatever action(s) the effect is supposed to accomplish.
            This function is called automatically when <see cref="M:GoRogue.Effect`1.Trigger(`0)"/> is called.
            </summary>
            <param name="e">Class containing all arguments <see cref="M:GoRogue.Effect`1.OnTrigger(`0)"/> requires to function.</param>
        </member>
        <member name="M:GoRogue.Effect`1.ToString">
            <summary>
            Returns a string of the effect's name and duration.
            </summary>
            <returns>String representation of the effect.</returns>
        </member>
        <member name="T:GoRogue.EffectTrigger`1">
             <summary>
             Represents an "event" that can automatically trigger and manage one or more
             <see cref="T:GoRogue.Effect`1"/> instances, and acts as part of the implementation of
             duration in Effect.
             </summary>
             <remarks>
             EffectTrigger's primary purpose is to represent an event that can trigger one or more effects, and
             automatically remove those effects from the list when their duration reaches 0.  Each EffectTrigger
             instance can have one or more (non-instantaneous) effects added to it. All Effects must take the same
             type of argument to their <see cref="M:GoRogue.Effect`1.Trigger(`0)"/>
             function, as specified by this class's type parameter.
            
             Each time the <see cref="M:GoRogue.EffectTrigger`1.TriggerEffects(`0)"/> function is called, every Effect has its
             Trigger function called (provided its duration is not 0). Each Effect may, via the TriggerArgs
             <see cref="F:GoRogue.EffectArgs.CancelTrigger"/> member, stop the effect from
             being sent to subsequent effects in the EffectTrigger's list. Once either all effects in the list
             have had their Trigger function called, or some effect has cancelled the triggering, any effect
             whose duration has reached 0 is removed from the EffectTrigger automatically.
             
             Typically, one instance of this class is created per "event" that can trigger effects, and then the
             instance's TriggerEffects function is called whenever that event happens. For example, in a
             typical roguelike, all damageable creatures might have an instance of this class called
             OnDamageTakenEffects. Any effect that should trigger when that creature takes damage would then be
             added to that creature's OnDamageTakenEffects EffectTrigger. The TakeDamage function of that
             creature would then need to call OnDamageTakenEffects.TriggerEffects(...). In this way, all effects
             added to the OnDamageTakenEffects EffectTrigger would be triggered automatically whenever the
             creature takes damage.
            
             For some complex game mechanics, it may be desireable to control how effects stack, the order they appear
             in the effects list of EffectTriggers, etc. In these cases, subclassing EffectTrigger and overriding the
             add and remove functions can allow this functionality.
             </remarks>
             <typeparam name="TriggerArgs">
             The type of argument that must be accepted by the <see cref="M:GoRogue.Effect`1.Trigger(`0)"/> 
             function of any Effect added to this EffectTrigger.
             </typeparam>
        </member>
        <member name="M:GoRogue.EffectTrigger`1.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:GoRogue.EffectTrigger`1.Effects">
            <summary>
            List of all effects that are part of this EffectTrigger.
            </summary>
        </member>
        <member name="M:GoRogue.EffectTrigger`1.Add(GoRogue.Effect{`0})">
            <summary>
            Adds the given effect to this EffectTrigger, provided the effect's duration is not 0. If
            the effect's duration is 0, an ArgumentException is thrown.
            </summary>
            <param name="effect">The effect to add to this trigger.</param>
        </member>
        <member name="M:GoRogue.EffectTrigger`1.Remove(GoRogue.Effect{`0})">
            <summary>
            Removes the given effect from this EffectTrigger.
            </summary>
            <param name="effect">The effect to remove</param>
        </member>
        <member name="M:GoRogue.EffectTrigger`1.ToString">
            <summary>
            Yields a string representation of each effect that has been added to the effect trigger.
            </summary>
            <returns>
            A string representation of each effect that has been added to the effect trigger.
            </returns>
        </member>
        <member name="M:GoRogue.EffectTrigger`1.TriggerEffects(`0)">
            <summary>
            Calls the <see cref="M:GoRogue.Effect`1.Trigger(`0)"/> function of each effect
            in the <see cref="P:GoRogue.EffectTrigger`1.Effects"/> list (as long as its duration is not 0), then
            removes any effect that has duration 0.
            </summary>
            <remarks>
            The argument given is passed along to the <see cref="M:GoRogue.Effect`1.Trigger(`0)"/>
            function of each effect that has Trigger called. If some effect sets the <see cref="F:GoRogue.EffectArgs.CancelTrigger"/>
            flag in the argument to true, the loop will be broken and no subsequent effects in the list will have
            Trigger called. After either this occurs or all effects have had Trigger called, any effect in the list
            that has a duration of 0 is automatically removed from the list.  It is valid to pass null
            as the argument to this function, if the effects need no actual parameters.
            </remarks>
            <param name="args">Argument to pass to the <see cref="M:GoRogue.Effect`1.Trigger(`0)"/> function
            of each effect.</param>
        </member>
        <member name="T:GoRogue.Factory.BlueprintConfig">
            <summary>
            Base class for a settings object that contains parameters to pass to the Create function of a factory.
            </summary>
        </member>
        <member name="F:GoRogue.Factory.BlueprintConfig.Empty">
            <summary>
            Represents no arguments -- pass as the config parameter to Create if there are no parameters you wish to pass.
            </summary>
        </member>
        <member name="T:GoRogue.Factory.Factory`2">
            <summary>
            A factory that produces a type of object based on a blueprint and a set of configuration parameters.
            </summary>
            <typeparam name="TBlueprintConfig">The type of parameter passed to the <see cref="M:GoRogue.Factory.Factory`2.Create(System.String,`0)"/> function each time an object is created.</typeparam>
            <typeparam name="TProduced">The type of object this factory creates.</typeparam>
        </member>
        <member name="M:GoRogue.Factory.Factory`2.Add(GoRogue.Factory.IBlueprint{`0,`1})">
            <summary>
            Adds a blueprint to the factory.
            </summary>
            <param name="blueprint">The blueprint to add.</param>
        </member>
        <member name="M:GoRogue.Factory.Factory`2.Create(System.String,`0)">
            <summary>
            Creates a <typeparamref name="TProduced"/> object using the blueprint with the given factory id, and the given settings object.
            </summary>
            <param name="factoryId">The factory id of a blueprint.</param>
            <param name="blueprintConfig">A settings object passed to the Create function of the blueprint.</param>
            <returns>A new object.</returns>
        </member>
        <member name="M:GoRogue.Factory.Factory`2.BlueprintExists(System.String)">
            <summary>
            Checks if a blueprint exists.
            </summary>
            <param name="factoryId">The blueprint to check for.</param>
            <returns>Returns true when the specified <paramref name="factoryId"/> exists; otherwise false.</returns>
        </member>
        <member name="M:GoRogue.Factory.Factory`2.GetBlueprint(System.String)">
            <summary>
            Gets a blueprint by identifier.
            </summary>
            <param name="factoryId">The blueprint identifier to get.</param>
            <returns>The blueprint of the object.</returns>
            <exception cref="T:GoRogue.Factory.ItemNotDefinedException">Thrown if the factory identifier does not exist.</exception>
        </member>
        <member name="M:GoRogue.Factory.Factory`2.GetEnumerator">
            <summary>
            Gets an enumerator of all of the blueprints in the factory.
            </summary>
            <returns>An enumeration of the blueprints.</returns>
        </member>
        <member name="M:GoRogue.Factory.Factory`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator of all of the blueprints in the factory.
            </summary>
            <returns>An enumeration of the blueprints.</returns>
        </member>
        <member name="T:GoRogue.Factory.ItemNotDefinedException">
            <summary>
            Exception thrown by <see cref="T:GoRogue.Factory.Factory`2"/> objects when a blueprint that doesn't exist is used.
            </summary>
        </member>
        <member name="M:GoRogue.Factory.ItemNotDefinedException.#ctor(System.String)">
            <summary>
            Creates an exception.
            </summary>
            <param name="factoryId">Factory id that caused the error.</param>
        </member>
        <member name="T:GoRogue.Factory.Factory`1">
            <summary>
            A factory that produces a type of object based on a blueprint.
            </summary>
            <typeparam name="TProduced">The type of object this factory creates.</typeparam>
        </member>
        <member name="M:GoRogue.Factory.Factory`1.Create(System.String)">
            <summary>
            Creates a <typeparamref name="TProduced"/> object using the blueprint with the given factory id.
            </summary>
            <param name="factoryId">The factory id of a blueprint.</param>
            <returns>A new object.</returns>
        </member>
        <member name="T:GoRogue.Factory.IBlueprint`2">
            <summary>
            Defines how to create a <typeparamref name="TProduced"/> object.
            </summary>
            <typeparam name="TBlueprintConfig">The type of the parameter to pass to the <see cref="M:GoRogue.Factory.IBlueprint`2.Create(`0)"/> function.</typeparam>
            <typeparam name="TProduced">The type of object to create.</typeparam>
        </member>
        <member name="P:GoRogue.Factory.IBlueprint`2.Id">
            <summary>
            A unique identifier of this factory definition.
            </summary>
        </member>
        <member name="M:GoRogue.Factory.IBlueprint`2.Create(`0)">
            <summary>
            Creates a <typeparamref name="TProduced"/> object.
            </summary>
            <param name="config">Configuration parameters used to create the object.</param>
            <returns>The created object.</returns>
        </member>
        <member name="T:GoRogue.Factory.IFactoryObject">
            <summary>
            Interface that can optionally be implemented by objects created via a <see cref="T:GoRogue.Factory.Factory`2"/>.  The <see cref="P:GoRogue.Factory.IFactoryObject.DefinitionId"/> property
            will be automatically set to the ID of the blueprint used to create the object when the Factory's Create function is called.
            </summary>
        </member>
        <member name="P:GoRogue.Factory.IFactoryObject.DefinitionId">
            <summary>
            The identifier of the <see cref="T:GoRogue.Factory.IBlueprint`2"/> that created this object. Do not set manually -- <see cref="T:GoRogue.Factory.Factory`2"/>
            will automatically set this field when the object is created.
            </summary>
        </member>
        <member name="T:GoRogue.Factory.SimpleBlueprint`1">
            <summary>
            A simple <see cref="T:GoRogue.Factory.IBlueprint`2"/> that can be used when no configuration object is necessary to create the object.
            Implements <see cref="T:GoRogue.Factory.IBlueprint`2"/>.
            </summary>
            <typeparam name="TProduced">The type of object to create.</typeparam>
        </member>
        <member name="P:GoRogue.Factory.SimpleBlueprint`1.Id">
            <summary>
            A unique identifier of this factory definition.
            </summary>
        </member>
        <member name="M:GoRogue.Factory.SimpleBlueprint`1.#ctor(System.String)">
            <summary>
            Creates a SimpleBlueprint with the given blueprint id.
            </summary>
            <param name="id">ID for the blueprint.</param>
        </member>
        <member name="M:GoRogue.Factory.SimpleBlueprint`1.Create(GoRogue.Factory.BlueprintConfig)">
            <summary>
            Calls <see cref="M:GoRogue.Factory.SimpleBlueprint`1.Create"/>.
            </summary>
            <param name="config">Unused.</param>
            <returns>The created object.</returns>
        </member>
        <member name="M:GoRogue.Factory.SimpleBlueprint`1.Create">
            <summary>
            Creates a <typeparamref name="TProduced"/> object.
            </summary>
            <returns>The created object.</returns>
        </member>
        <member name="T:GoRogue.FOV">
             <summary>
             Implements the capability to calculate a grid-based field of view for a map.
             </summary>
             <remarks>
             Generally, this class can be used to calculate and expose the results of a field of view
             calculation for a map.  In includes many options pertaining to the shape and size of the
             field of view (including options for an infinite-radius field of view).  As well, for
             non-infinite size fields of view, the result contains built-in linear distance falloff for
             the sake of creating lighting/color/fidelity differences based on distance from the center.
            
             Like most GoRogue algorithms, FOV takes as a construction parameter an IMapView representing the map. 
             Specifically, it takes an <see cref="T:GoRogue.MapViews.IMapView`1"/>, where true indicates that a tile should be
             considered transparent, eg. not blocking to line of sight, and false indicates that a tile should be
             considered opaque, eg. blocking to line of sight.
            
             The field of view can then be calculated by calling one of the various Calculate overloads.
            
             The result of the calculation is exposed in two different forms.  First, the values are exposed to you
             via indexers -- the FOV class itself implements <see cref="T:GoRogue.MapViews.IMapView`1"/>, where a value of 1.0
             represents the center of the field of view calculation, and 0.0 indicates a location that is not inside
             the resulting field of view at all.  Values in between are representative of linear falloff based on
             distance from the source.
             
             Alternatievly, if the distance from the source is irrelevant, FOV also provides the result of the calculation
             via <see cref="P:GoRogue.FOV.BooleanFOV"/>, which is an <see cref="T:GoRogue.MapViews.IMapView`1"/> where a value of true indicates
             that a location is within field of view, and a value of false indicates it is ouside of the field of view.
             </remarks>
        </member>
        <member name="P:GoRogue.FOV.BooleanFOV">
            <summary>
            A view of the calculation results in boolean form, where true indicates a location is inside
            field of view, and false indicates it is not.
            </summary>
        </member>
        <member name="M:GoRogue.FOV.#ctor(GoRogue.MapViews.IMapView{System.Boolean})">
            <summary>
            Constructor.
            </summary>
            <param name="fovMap">
            The values used to calculate field of view. Values of true are considered
            non-blocking (transparent) to line of sight, while false values are considered
            to be blocking.
            </param>
        </member>
        <member name="P:GoRogue.FOV.CurrentFOV">
            <summary>
            IEnumerable of only positions that are currently inside field of view.
            </summary>
        </member>
        <member name="P:GoRogue.FOV.Height">
            <summary>
            Height of the map view.
            </summary>
        </member>
        <member name="P:GoRogue.FOV.NewlySeen">
            <summary>
            IEnumerable of positions that ARE in field of view as of the most current Calculate
            call, but were NOT in field of view after the previous time Calculate was called.
            </summary>
        </member>
        <member name="P:GoRogue.FOV.NewlyUnseen">
            <summary>
            IEnumerable of positions that are NOT in field of view as of the most current Calculate call,
            but WERE in field of view after the previous time Calculate was called.
            </summary>
        </member>
        <member name="P:GoRogue.FOV.Width">
            <summary>
            Width of map view.
            </summary>
        </member>
        <member name="P:GoRogue.FOV.Item(System.Int32)">
            <summary>
            Returns the field of view value for the given position.
            </summary>
            <param name="index1D">Position to return the field of view value for, as a 1D-index-style value.</param>
            <returns>The field of view value for the given position.</returns>
        </member>
        <member name="P:GoRogue.FOV.Item(GoRogue.Coord)">
            <summary>
            Returns the field of view value for the given position.
            </summary>
            <param name="position">The position to return the field of view value for.</param>
            <returns>The field of view value for the given position.</returns>
        </member>
        <member name="P:GoRogue.FOV.Item(System.Int32,System.Int32)">
            <summary>
            Returns the field of view value for the given position.
            </summary>
            <param name="x">X-coordinate of the position to return the FOV value for.</param>
            <param name="y">Y-coordinate of the position to return the FOV value for.</param>
            <returns>The field of view value for the given position.</returns>
        </member>
        <member name="M:GoRogue.FOV.AsReadOnly">
            <summary>
            Returns a read-only representation of the field of view.
            </summary>
            <returns>This FOV object, as an <see cref="T:GoRogue.IReadOnlyFOV"/> instance.</returns>
        </member>
        <member name="M:GoRogue.FOV.Calculate(System.Int32,System.Int32,System.Double)">
            <summary>
            Calculates FOV given an origin point and a radius. If no radius is specified, simply
            calculates with a radius of maximum integer value, which is effectively infinite. Radius
            is computed as a circle around the source (type <see cref="F:GoRogue.Radius.CIRCLE"/>).
            </summary>
            <param name="startX">Coordinate x-value of the origin.</param>
            <param name="startY">Coordinate y-value of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of the field of view if completely unobstructed.
            If no radius is specified, it is effectively infinite.
            </param>
        </member>
        <member name="M:GoRogue.FOV.Calculate(GoRogue.Coord,System.Double)">
            <summary>
            Calculates FOV given an origin point and a radius. If no radius is specified,
            simply calculates with a radius of maximum integer value, which is effectively infinite.
            Radius is computed as a circle around the source (type <see cref="F:GoRogue.Radius.CIRCLE"/>).
            </summary>
            <param name="start">Position of origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of the field of view if completely unobstructed.
            If no radius is specified, it is effectively infinite.
            </param>
        </member>
        <member name="M:GoRogue.FOV.Calculate(System.Int32,System.Int32,System.Double,GoRogue.Distance)">
            <summary>
            Calculates FOV given an origin point, a radius, and radius shape.
            </summary>
            <param name="startX">Coordinate x-value of the origin.</param>
            <param name="startY">Coordinate y-value of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of the field of view if completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:GoRogue.Distance"/>, eg. <see cref="T:GoRogue.Radius"/>).
            </param>
        </member>
        <member name="M:GoRogue.FOV.Calculate(GoRogue.Coord,System.Double,GoRogue.Distance)">
            <summary>
            Calculates FOV given an origin point, a radius, and a radius shape.
            </summary>
            <param name="start">Coordinate of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of the field of view if completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:GoRogue.Distance"/>, eg. <see cref="T:GoRogue.Radius"/>).
            </param>
        </member>
        <member name="M:GoRogue.FOV.Calculate(System.Int32,System.Int32,System.Double,GoRogue.Distance,System.Double,System.Double)">
            <summary>
            Calculates FOV given an origin point, a radius, a radius shape, and the given field of view
            restrictions <paramref name="angle"/> and <paramref name="span"/>.  The resulting field of view,
            if unobstructed, will be a cone defined by the angle and span given.
            </summary>
            <param name="startX">Coordinate x-value of the origin.</param>
            <param name="startY">Coordinate y-value of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of the field of view if completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:GoRogue.Distance"/>, eg. <see cref="T:GoRogue.Radius"/>).
            </param>
            <param name="angle">
            The angle in degrees that specifies the outermost center point of the field of view cone. 0 degrees
            points right.
            </param>
            <param name="span">
            The angle, in degrees, that specifies the full arc contained in the field of view cone --
            <paramref name="angle"/> / 2 degrees are included on either side of the cone's center line.
            </param>
        </member>
        <member name="M:GoRogue.FOV.Calculate(GoRogue.Coord,System.Double,GoRogue.Distance,System.Double,System.Double)">
            <summary>
            Calculates FOV given an origin point, a radius, a radius shape, and the given field of view
            restrictions <paramref name="angle"/> and <paramref name="span"/>.  The resulting field of view,
            if unobstructed, will be a cone defined by the angle and span given.
            </summary>
            <param name="start">Coordinate of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of the field of view if completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:GoRogue.Distance"/>, eg. <see cref="T:GoRogue.Radius"/>).
            </param>
            <param name="angle">
            The angle in degrees that specifies the outermost center point of the field of view cone. 0 degrees
            points right.
            </param>
            <param name="span">
            The angle, in degrees, that specifies the full arc contained in the field of view cone --
            <paramref name="angle"/> / 2 degrees are included on either side of the span line.
            </param>
        </member>
        <member name="M:GoRogue.FOV.ToString(System.Char,System.Char)">
            <summary>
            ToString overload that customizes the characters used to represent the map.
            </summary>
            <param name="normal">The character used for any location not in FOV.</param>
            <param name="sourceValue">The character used for any location that is in FOV.</param>
            <returns>The string representation of FOV, using the specified characters.</returns>
        </member>
        <member name="M:GoRogue.FOV.ToString(System.Int32)">
            <summary>
            Returns a string representation of the map, with the actual values in the FOV, rounded to
            the given number of decimal places.
            </summary>
            <param name="decimalPlaces">The number of decimal places to round to.</param>
            <returns>A string representation of FOV, rounded to the given number of decimal places.</returns>
        </member>
        <member name="M:GoRogue.FOV.ToString">
            <summary>
            Returns a string representation of the map, where any location not in FOV is represented
            by a '-' character, and any position in FOV is represented by a '+'.
            </summary>
            <returns>A (multi-line) string representation of the FOV.</returns>
        </member>
        <member name="T:GoRogue.GameFramework.Components.IGameObjectComponent">
            <summary>
            Optional interface for components that are attached to an <see cref="T:GoRogue.GameFramework.IGameObject"/>.  While the implementation of this interface is not
            required for IGameObject components, if <see cref="T:GoRogue.GameFramework.GameObject"/>'s implementation of IHasComponents is used, the <see cref="P:GoRogue.GameFramework.Components.IGameObjectComponent.Parent"/> field
            is automatically kept up to date as you call <see cref="M:GoRogue.GameFramework.GameObject.AddComponent(System.Object)"/>/<see cref="M:GoRogue.IHasComponents.RemoveComponent(System.Object)"/>
            on objects that implement this interface.  A component implmenting this interface cannot be added to multiple GameObjects
            at once.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Components.IGameObjectComponent.Parent">
            <summary>
            The object to which this component is attached, or null if it is not attached.  Should not be set manually, as this is taken
            care of by <see cref="M:GoRogue.GameFramework.GameObject.AddComponent(System.Object)"/>/<see cref="M:GoRogue.IHasComponents.RemoveComponent(System.Object)"/>
            </summary>
        </member>
        <member name="T:GoRogue.GameFramework.GameObject">
            <summary>
            Base class for any object that has a grid position and can be added to a <see cref="T:GoRogue.GameFramework.Map"/>.  Implements basic attributes generally common to all objects
            on a map, as well as properties/methods that the Map class needs to function.  It also implements <see cref="T:GoRogue.IHasComponents"/>, which means you can attach
            components to it.  In cases where this class cannot be inherited from, have your class implement <see cref="T:GoRogue.GameFramework.IGameObject"/> via a private GameObject field.
            </summary>
            <remarks>
            This class is designed to serve as a base class for your own game objects in your game.  It implements basic common functionality such as
            walkability and transparency, provides some infrastructure that allows it to be added to instances of <see cref="T:GoRogue.GameFramework.Map"/>, and implements the
            framework for GoRogue's component system.  It also implements the necessary functionality that allows GameObjects to be added to an
            <see cref="T:GoRogue.ISpatialMap`1"/> implementation.
            
            Generally, you would create one or more classes (say, MyGameObject or MyTerrain), that derives from this one (GameObject), or implement
            <see cref="T:GoRogue.GameFramework.IGameObject"/> by composition using a private field of this class, and use that as
            the base class for your game's objects.  There is an example of doing this <a href="https://chris3606.github.io/GoRogue/articles/game-framework.html#implementing-igameobject">here</a>.
            If you utilize the component system, a subclass of GameObject isn't strictly necessary, as you could just construct basic GameObject instances and add
            components to them.  In either case, a <see cref="T:GoRogue.GameFramework.Map"/> instance can be used to store these objects efficiently. As well, Map provides functionality that will allow you to retrieve your
            objects as references of their derived type (MyGameObject or MyTerrain, in the example above), meaning that you can implement any common, game-specific functionality you need and have
            easy access to that information when objects are retrieved from the map.  This also means that if you prefer an inheritance-based approach, you can simply not utilize
            the component system, and you are still able to use these Map functions to differentiate functionality.
            
            Although the component system will accept items of any type as components, there is an optional <see cref="T:GoRogue.GameFramework.Components.IGameObjectComponent"/> interface that GoRogue provides,
            that has a field for the parent, eg. the IGameObject that it is attached to.  This field is automatically kept up to date as you add/remove components
            if you implement this interface for your components.
            </remarks>
        </member>
        <member name="P:GoRogue.GameFramework.GameObject.Position">
            <summary>
            The position of this object on the grid. Any time this value is changed, the <see cref="E:GoRogue.GameFramework.GameObject.Moved"/> event is fired.
            </summary>
            <remarks>
            This property may be overriden to implement custom functionality, however it is highly recommended
            that you call the base set in the overridden setter, as it performs collision detection.
            </remarks>
        </member>
        <member name="E:GoRogue.GameFramework.GameObject.Moved">
            <summary>
            Event fired whenever this object's grid position is successfully changed.  Fired regardless of whether
            the object is part of a <see cref="T:GoRogue.GameFramework.Map"/>.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.GameObject.IsWalkable">
            <summary>
            Whether or not the object is to be considered "walkable", eg. whether or not the square it resides
            on can be traversed by other, non-walkable objects on the same <see cref="T:GoRogue.GameFramework.Map"/>.  Effectively, whether or not this
            object collides.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.GameObject.IsTransparent">
            <summary>
            Whether or not the object is considered "transparent", eg. whether or not light passes through it
            for the sake of calculating the FOV of a <see cref="T:GoRogue.GameFramework.Map"/>.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.GameObject.IsStatic">
            <summary>
            Whether or not the object is "static".  Static objects CANNOT be moved, and only static objects may
            be placed on layer 0 of a <see cref="T:GoRogue.GameFramework.Map"/>.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.GameObject.ID">
            <summary>
            ID of the object.  Used for the sake of putting instances of this class in an <see cref="T:GoRogue.ISpatialMap`1"/> implementation,
            and is NOT guaranteed to be entirely unique, though this can be modified by overriding the <see cref="M:GoRogue.GameFramework.GameObject.GenerateID"/>
            function.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.GameObject.Layer">
            <summary>
            Layer of a <see cref="T:GoRogue.GameFramework.Map"/> that this object will reside on.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.GameObject.CurrentMap">
            <summary>
            The current <see cref="T:GoRogue.GameFramework.Map"/> which this object resides on.  Returns null if the object has not been added to a map.
            A GameObject is allowed to reside on only one map.
            </summary>
        </member>
        <member name="M:GoRogue.GameFramework.GameObject.#ctor(GoRogue.Coord,System.Int32,GoRogue.GameFramework.IGameObject,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="position">Position to start the object at.</param>
            <param name="layer">The layer of of a <see cref="T:GoRogue.GameFramework.Map"/> the object is assigned to.</param>
            <param name="parentObject">Object holding this GameObject instance. If you are inheriting from GameObject,
            or using a backing field of type GameObject to implement <see cref="T:GoRogue.GameFramework.IGameObject"/>, for example, you would pass <see langword="this"/> at construction.
            Otherwise, if you are simply instantiating base GameObject instances and adding them to a <see cref="T:GoRogue.GameFramework.Map"/>, you would pass null.</param>
            <param name="isStatic">Whether or not the object can be moved (true if the object CANNOT be moved,
            false otherwise).</param>
            <param name="isWalkable">Whether or not the object is to be considered "walkable", eg. whether or not the square it resides
            on can be traversed by other, non-walkable objects on the same <see cref="T:GoRogue.GameFramework.Map"/>.  Effectively, whether or not this
            object collides.</param>
            <param name="isTransparent">Whether or not the object is considered "transparent", eg. whether or not light passes through it
            for the sake of calculating the FOV of a <see cref="T:GoRogue.GameFramework.Map"/>.</param>
        </member>
        <member name="M:GoRogue.GameFramework.GameObject.MoveIn(GoRogue.Direction)">
            <summary>
            Attempts to move the object in the given direction, and returns true if the object was successfully
            moved, false otherwise.
            </summary>
            <param name="direction">The direction in which to try to move the object.</param>
            <returns>True if the object was successfully moved, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.GameObject.GenerateID">
            <summary>
            Function used at construction to assign an ID to the object.
            </summary>
            <remarks>
            The default implementation simply assigns a random number in range of valid uints. This
            is sufficiently distinct for the purposes of placing the objects in an <see cref="T:GoRogue.ISpatialMap`1"/>
            implementation, however obviously does NOT guarantee true uniqueness. If uniqueness or some other
            implementation is required, override this function to return an appropriate ID. Keep in
            mind a relatively high degree of uniqueness is necessary for efficient placement in an
            ISpatialMap implementation.
            </remarks>
            <returns>An ID to assign to the current object.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.GameObject.OnMapChanged(GoRogue.GameFramework.Map)">
            <summary>
            Internal use only, do not call manually!  Must, at minimum, update the <see cref="P:GoRogue.GameFramework.GameObject.CurrentMap"/> field of the
            GameObject to reflect the change.
            </summary>
            <param name="newMap">New map to which the GameObject has been added.</param>
        </member>
        <member name="M:GoRogue.GameFramework.GameObject.AddComponent(System.Object)">
            <summary>
            Adds the given object as a component.  Throws an exception if that specific instance is already attached to this GameObject.
            </summary>
            <param name="component">Component to add.</param>
        </member>
        <member name="M:GoRogue.GameFramework.GameObject.RemoveComponents(System.Object[])">
            <summary>
            Removes the given component(s) from the GameObject.  Throws an exception if a component given is not attached to
            the GameObject.
            </summary>
            <param name="components">One or more component instances to remove.</param>
        </member>
        <member name="T:GoRogue.GameFramework.IGameObject">
            <summary>
            An interface that defines the entire public interface of <see cref="T:GoRogue.GameFramework.GameObject"/>.  Generally, you should NOT implement these functions
            yourself, however it can be used in conjunction with a private, backing field of type GameObject to store items in a map, where that
            object cannot directly inherit from GameObject.
            </summary>
            <remarks>
            Generally, you will never implement the items in this interface manually, but rather do so through a private, backing field of type
            <see cref="T:GoRogue.GameFramework.GameObject"/>. There is an example of this type of implementation
            <a href="https://chris3606.github.io/GoRogue/articles/game-framework.html#implementing-igameobject">here</a>.
            </remarks>
        </member>
        <member name="P:GoRogue.GameFramework.IGameObject.CurrentMap">
            <summary>
            The current <see cref="T:GoRogue.GameFramework.Map"/> which this object resides on.  Returns null if the object has not been added to a map.
            An IGameObject is allowed to reside on only one map.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.IGameObject.IsStatic">
            <summary>
            Whether or not the object is "static".  Static objects CANNOT be moved, and only static objects may
            be placed on layer 0 of a <see cref="T:GoRogue.GameFramework.Map"/>.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.IGameObject.IsTransparent">
            <summary>
            Whether or not the object is considered "transparent", eg. whether or not light passes through it
            for the sake of calculating the FOV of a <see cref="T:GoRogue.GameFramework.Map"/>.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.IGameObject.IsWalkable">
            <summary>
            Whether or not the object is to be considered "walkable", eg. whether or not the square it resides
            on can be traversed by other, non-walkable objects on the same <see cref="T:GoRogue.GameFramework.Map"/>.  Effectively, whether or not this
            object collides.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.IGameObject.Position">
            <summary>
            The position of this object on the grid. Any time this value is changed, the <see cref="E:GoRogue.GameFramework.IGameObject.Moved"/> event is fired.
            </summary>
            <remarks>
            This property may be overriden to implement custom functionality, however it is highly recommended
            that you call the base set in the overridden setter, as it performs collision detection.
            </remarks>
        </member>
        <member name="E:GoRogue.GameFramework.IGameObject.Moved">
            <summary>
            Event fired whenever this object's grid position is successfully changed.  Fired regardless of whether
            the object is part of a <see cref="T:GoRogue.GameFramework.Map"/>.
            </summary>
        </member>
        <member name="M:GoRogue.GameFramework.IGameObject.MoveIn(GoRogue.Direction)">
            <summary>
            Attempts to move the object in the given direction, and returns true if the object was successfully
            moved, false otherwise.
            </summary>
            <param name="direction">The direction in which to try to move the object.</param>
            <returns>True if the object was successfully moved, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.IGameObject.OnMapChanged(GoRogue.GameFramework.Map)">
            <summary>
            Internal use only, do not call manually!  Must, at minimum, update the <see cref="P:GoRogue.GameFramework.IGameObject.CurrentMap"/> field of the
            IGameObject to reflect the change.
            </summary>
            <param name="newMap">New map to which the IGameObject has been added.</param>
        </member>
        <member name="T:GoRogue.GameFramework.Map">
            <summary>
            Base class for a map that consists of one or more objects of base type <see cref="T:GoRogue.GameFramework.IGameObject"/>.  It implements basic functionality to manage and access these
            objects, as well as commonly needed functionality like tile exploration, FOV, and pathfinding.  It also provides methods to easily access these objects as
            instances of some derived type, that can be used to access functionality you've implemented in a subclass.
            </summary>
            <remarks>
            A Map consists of <see cref="T:GoRogue.GameFramework.IGameObject"/> instances on one or more layers.  These layers are numbered, from the lowest layer of 0 upward.  Each Map contains
            at minimum a "terrain" layer.  This is considered to be layer 0.  All objects added to this layer must have their <see cref="P:GoRogue.GameFramework.IGameObject.IsStatic"/> flag set to true,
            and must reside on layer 0.
            
            A map will typically also have some other layers, for non-terrain objects like monsters, items, etc.  The number of these layers present
            on the map, along with which of all the layers participate in collision detection, etc., can be specified in the constructor.
            
            While this class has some flexibility, it does, unlike the rest of the library, tend to impose itself on your architecture.  In cases where this is
            undesireable, each component of this map class exists as a separate component (layer masking, the SpatialMap(s) storing the entity layers, FOV, and pathfinding
            all exist as their own (more flexible) components).  This class is not intended to cover every possible use case, but instead may act as an example or starting
            point in the case where you would like to use the components in a different way or within a different architecture.
            </remarks>
        </member>
        <member name="P:GoRogue.GameFramework.Map.Terrain">
            <summary>
            Terrain of the map.  Terrain at each location may be set via the <see cref="M:GoRogue.GameFramework.Map.SetTerrain(GoRogue.GameFramework.IGameObject)"/> function.
            </summary>
        </member>
        <member name="F:GoRogue.GameFramework.Map.Explored">
            <summary>
            Whether or not each tile is considered explored.  Tiles start off unexplored, and become explored as soon as they are within
            a calculated FOV.  This ArrayMap may also have values set to it, to easily allow for serialization or wizard-mode like functionality.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.Entities">
            <summary>
            <see cref="T:GoRogue.IReadOnlyLayeredSpatialMap`1"/> of all entities (non-terrain objects) on the map.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.LayerMasker">
            <summary>
            <see cref="P:GoRogue.GameFramework.Map.LayerMasker"/> that should be used to create layer masks for this Map.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.LayersBlockingWalkability">
            <summary>
            Layer mask that contains only layers that block walkability.  A non-walkable <see cref="T:GoRogue.GameFramework.IGameObject"/> can only be added to this
            map if the layer it resides on is contained within this layer mask.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.LayersBlockingTransparency">
            <summary>
            Layer mask that contains only layers that block transparency.  A non-transparent <see cref="T:GoRogue.GameFramework.IGameObject"/> can only be added to this
            map if the layer it is on is contained within this layer mask.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.TransparencyView">
            <summary>
            <see cref="T:GoRogue.MapViews.IMapView`1"/> representing transparency values for each tile.  Each location returns true if the location is transparent
            (there are no non-transparent objects at that location), and false otherwise.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.WalkabilityView">
            <summary>
            <see cref="T:GoRogue.MapViews.IMapView`1"/> representing walkability values for each tile.  Each location is true if the location is walkable (there are
            no non-walkable objects at that location), and false otherwise.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.FOV">
            <summary>
            Current FOV results for the map.  Calculate FOV via the Map's CalculateFOV functions.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.AStar">
            <summary>
            A* pathfinder for the map.  By default, uses <see cref="P:GoRogue.GameFramework.Map.WalkabilityView"/> to determine which locations can be reached,
            and calculates distance based on the <see cref="T:GoRogue.Distance"/> passed to the Map in the constructor.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.DistanceMeasurement">
            <summary>
            <see cref="T:GoRogue.Distance"/> measurement used for pathing and measuring distance on the map.
            </summary>
        </member>
        <member name="E:GoRogue.GameFramework.Map.ObjectAdded">
            <summary>
            Event that is fired whenever some object is added to the map.
            </summary>
        </member>
        <member name="E:GoRogue.GameFramework.Map.ObjectRemoved">
            <summary>
            Event that is fired whenever some object is removed from the map.
            </summary>
        </member>
        <member name="E:GoRogue.GameFramework.Map.ObjectMoved">
            <summary>
            Event that is fired whenever some object that is part of the map is successfully moved.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.Height">
            <summary>
            Height of the map, in grid spaces.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.Width">
            <summary>
            Width of the map, in grid spaces.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.Item(System.Int32)">
            <summary>
            Gets all objects at the given location, from the highest layer (layer with the highest number) down.
            </summary>
            <param name="index1D">Location to retrieve objects for, specified as a 1D array-style index.</param>
            <returns>All objects at the given location, in order from highest layer to lowest layer.</returns>
        </member>
        <member name="P:GoRogue.GameFramework.Map.Item(GoRogue.Coord)">
            <summary>
            Gets all objects at the given location, from the highest layer (layer with the highest number) down.
            </summary>
            <param name="pos">The position to retrieve objects for.</param>
            <returns>All objects at the given location, in order from highest layer to lowest layer.</returns>
        </member>
        <member name="P:GoRogue.GameFramework.Map.Item(System.Int32,System.Int32)">
            <summary>
            Gets all objects at the given location, from the highest layer (layer with the highest number) down.
            </summary>
            <param name="x">X-value of the position to retrieve objects for.</param>
            <param name="y">Y-value of the position to retrieve objects for.</param>
            <returns>All objects at the given location, in order from highest layer to lowest layer.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.#ctor(System.Int32,System.Int32,System.Int32,GoRogue.Distance,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Constructor.  Constructs terrain map as <see cref="T:GoRogue.MapViews.ArrayMap`1"/>; with the given width/height.
            </summary>
            <param name="width">Width of the map.</param>
            <param name="height">Height of the map.</param>
            <param name="numberOfEntityLayers">Number of non-terrain layers for the map.</param>
            <param name="distanceMeasurement"><see cref="T:GoRogue.Distance"/> measurement to use for pathing/measuring distance on the map.</param>
            <param name="layersBlockingWalkability">Layer mask containing those layers that should be allowed to have items that block walkability.
            Defaults to all layers.</param>
            <param name="layersBlockingTransparency">Layer mask containing those layers that should be allowed to have items that block FOV.
            Defaults to all layers.</param>
            <param name="entityLayersSupportingMultipleItems">Layer mask containing those layers that should be allowed to have multiple objects at the same
            location on the same layer.  Defaults to no layers.</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map.#ctor(GoRogue.MapViews.ISettableMapView{GoRogue.GameFramework.IGameObject},System.Int32,GoRogue.Distance,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Constructor.  Constructs map with the given terrain layer, determining width/height based on the width/height of that terrain layer.
            </summary>
            <remarks>
            Because of the way polymorphism works for custom classes in C#, the <paramref name="terrainLayer"/> parameter MUST be of type
            <see cref="T:GoRogue.MapViews.ISettableMapView`1"/>, rather than <see cref="T:GoRogue.MapViews.ISettableMapView`1"/> where T is a type that derives from or implements
            <see cref="T:GoRogue.GameFramework.IGameObject"/>.  If you need to use a map view storing type T rather than IGameObject, use the
            <see cref="M:GoRogue.GameFramework.Map.CreateMap``1(GoRogue.MapViews.ISettableMapView{``0},System.Int32,GoRogue.Distance,System.UInt32,System.UInt32,System.UInt32)"/> function to create the map.
            </remarks>
            <param name="terrainLayer">The <see cref="T:GoRogue.MapViews.ISettableMapView`1"/> that represents the terrain layer for this map.  After the
            map has been created, you should use the <see cref="M:GoRogue.GameFramework.Map.SetTerrain(GoRogue.GameFramework.IGameObject)"/> function to modify the values in this map view, rather
            than setting the values via the map view itself -- if you re-assign the value at a location via the map view, the
            <see cref="E:GoRogue.GameFramework.Map.ObjectAdded"/>/<see cref="E:GoRogue.GameFramework.Map.ObjectRemoved"/> events are NOT guaranteed to be called, and many invariants of map may not be properly
            enforced.</param>
            <param name="numberOfEntityLayers">Number of non-terrain layers for the map.</param>
            <param name="distanceMeasurement"><see cref="T:GoRogue.Distance"/> measurement to use for pathing/measuring distance on the map.</param>
            <param name="layersBlockingWalkability">Layer mask containing those layers that should be allowed to have items that block walkability.
            Defaults to all layers.</param>
            <param name="layersBlockingTransparency">Layer mask containing those layers that should be allowed to have items that block FOV.
            Defaults to all layers.</param>
            <param name="entityLayersSupportingMultipleItems">Layer mask containing those layers that should be allowed to have multiple objects at the same
            location on the same layer.  Defaults to no layers.</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetTerrain(GoRogue.Coord)">
            <summary>
            Gets the terrain object at the given location, or null if no terrain is set to that location.
            </summary>
            <param name="position">The position to get the terrain for.</param>
            <returns>The terrain at the given postion, or null if no terrain exists at that location.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetTerrain``1(GoRogue.Coord)">
            <summary>
            Gets the terrain object at the given location, as a value of type TerrainType.  Returns null if no terrain is set, or the terrain
            cannot be casted to the type specified.
            </summary>
            <typeparam name="TerrainType">Type to check for/return the terrain as.</typeparam>
            <param name="position">The position to get the terrain for.</param>
            <returns>The terrain at the given postion, or null if either no terrain exists at that location or the terrain was not castable to type
            TerrainType.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetTerrain(System.Int32,System.Int32)">
            <summary>
            Gets the terrain object at the given location, or null if no terrain is set to that location.
            </summary>
            <param name="x">X-value of the position to get the terrain for.</param>
            <param name="y">Y-value of the position to get the terrain for.</param>
            <returns>The terrain at the given postion, or null if no terrain exists at that location.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetTerrain``1(System.Int32,System.Int32)">
            <summary>
            Gets the terrain object at the given location, as a value of type TerrainType.  Returns null if no terrain is set, or the terrain
            cannot be casted to the type specified.
            </summary>
            <typeparam name="TerrainType">Type to return the terrain as.</typeparam>
            <param name="x">X-value of the position to get the terrain for.</param>
            <param name="y">Y-value of the position to get the terrain for.</param>
            <returns>The terrain at the given postion, or null if either no terrain exists at that location or the terrain was not castable to type
            TerrainType.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.SetTerrain(GoRogue.GameFramework.IGameObject)">
            <summary>
            Sets the terrain at the given objects location to the given object, overwriting any terrain already present there.
            </summary>
            <param name="terrain">Terrain to replace the current terrain with. <paramref name="terrain"/> must have its 
            <see cref="P:GoRogue.GameFramework.IGameObject.IsStatic"/> flag set to true and its <see cref="P:GoRogue.IHasLayer.Layer"/> must be 0, or an exception will be thrown.</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map.ApplyTerrainOverlay``1(GoRogue.MapViews.IMapView{``0},System.Func{GoRogue.Coord,``0,GoRogue.GameFramework.IGameObject})">
            <summary>
            Sets all terrain on the map to the result of running the given translator on the value in <paramref name="overlay"/> at the
            corresponding position.  Useful, for example, for applying the map view resulting from map generation to a Map as terrain.
            </summary>
            <typeparam name="T">Type of values exposed by map view to translate.  Generally inferred by the compiler.</typeparam>
            <param name="overlay">Map view to translate.</param>
            <param name="translator">Function that translates values of the type that <paramref name="overlay"/> exposes to values of type IGameObject.</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map.ApplyTerrainOverlay(GoRogue.MapViews.IMapView{GoRogue.GameFramework.IGameObject})">
            <summary>
            Sets all terrain on the current map to be equal to the corresponding values from the map view you pass in.  Equivalent to
            calling <see cref="M:GoRogue.GameFramework.Map.SetTerrain(GoRogue.GameFramework.IGameObject)"/> once on each object in the map view you pass in.  If translation between
            the overlay and IGameObject is required, see the overloads of this function that take a translation function.
            </summary>
            <param name="overlay">
            Map view specifying the terrain apply to the map. Must have identical dimensions to the current map.
            </param>
        </member>
        <member name="M:GoRogue.GameFramework.Map.AddEntity(GoRogue.GameFramework.IGameObject)">
            <summary>
            Adds the given entity (non-terrain object) to its recorded location, removing it from the map it is currently a part of.  Returns true if the
            entity was added, and false otherwise (eg., collision detection would not allow it, etc.)
            </summary>
            <param name="entity">Entity to add.</param>
            <returns>True if the entity was successfully added to the map, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetEntity``1(GoRogue.Coord,System.UInt32)">
            <summary>
            Gets the first (non-terrain) entity encountered at the given position that can be casted to the specified type, moving from the highest existing
            layer in the layer mask downward. Layer mask defaults to all layers. null is returned if no entities of the specified type are found, or if
            there are no entities at the location.
            </summary>
            <typeparam name="EntityType">Type of entities to return.</typeparam>
            <param name="position">Position to check get entity for.</param>
            <param name="layerMask">Layer mask for which layers can return an entity.  Defaults to all layers.</param>
            <returns>The first entity encountered, moving from the highest existing layer in the layer mask downward, or null if there are no entities of
            the specified type are found.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetEntity``1(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Gets the first (non-terrain) entity encountered at the given position that can be casted to the specified type, moving from the highest existing
            layer in the layer mask downward. Layer mask defaults to all layers. null is returned if no entities of the specified type are found, or if
            there are no entities at the location.
            </summary>
            <typeparam name="EntityType">Type of entities to return.</typeparam>
            <param name="x">X-value of the position to get entity for.</param>
            <param name="y">Y-value of the position to get entity for.</param>
            <param name="layerMask">Layer mask for which layers can return an entity.  Defaults to all layers.</param>
            <returns>The first entity encountered, moving from the highest existing layer in the layer mask downward, or null if there are no entities of
            the specified type are found.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetEntities``1(GoRogue.Coord,System.UInt32)">
            <summary>
            Gets all (non-terrain) entities encountered at the given position that are castable to type EntityType, in order from the highest existing layer
            in the layer mask downward.  Layer mask defaults to all layers.
            </summary>
            <typeparam name="EntityType">Type of entities to return.</typeparam>
            <param name="position">Position to get entities for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>All entities encountered at the given position that are castable to the given type, in order from the highest existing layer
            in the mask downward.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetEntities``1(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Gets all (non-terrain) entities encountered at the given position that are castable to type EntityType, in order from the highest existing layer
            in the layer mask downward.  Layer mask defaults to all layers.
            </summary>
            <typeparam name="EntityType">Type of entities to return.</typeparam>
            <param name="x">X-value of the position to get entities for.</param>
            <param name="y">Y-value of the position to get entities for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>All entities encountered at the given position that are castable to the given type, in order from the highest existing layer
            in the mask downward.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.RemoveEntity(GoRogue.GameFramework.IGameObject)">
            <summary>
            Removes the given entity (non-terrain object) from the map, returning true if it was successfully removed, and false otherwise.
            </summary>
            <param name="entity">The entity to remove from the map.</param>
            <returns>True if the entity was removed successfully, false otherwise (eg, the entity was not part of this map).</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetObject(GoRogue.Coord,System.UInt32)">
            <summary>
            Gets the first object encountered at the given position, moving from the highest existing layer in the layer mask downward.  Layer mask defaults
            to all layers.
            </summary>
            <param name="position">Position to get object for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>The first object encountered, moving from the highest existing layer in the layer mask downward.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetObject``1(GoRogue.Coord,System.UInt32)">
            <summary>
            Gets the first object encountered at the given position that can be casted to the type specified, moving from the highest existing layer in the
            layer mask downward. Layer mask defaults to all layers.  null is returned if no objects of the specified type are found, or if there are no
            objects at the location.
            </summary>
            <typeparam name="ObjectType">Type of objects to return.</typeparam>
            <param name="position">Position to get object for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>The first object encountered, moving from the highest existing layer in the layer mask downward, or null if there are no objects of
            the specified type are found.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetObject(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Gets the first object encountered at the given position that can be casted to the specified type, moving from the highest existing layer in the
            layer mask downward. Layer mask defaults to all layers. null is returned if no objects of the specified type are found, or if there are no
            objects at the location.
            </summary>
            <param name="x">X-value of the position to get object for.</param>
            <param name="y">Y-value of the position to get object for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>The first object encountered, moving from the highest existing layer in the layer mask downward.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetObject``1(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Gets the first object encountered at the given position that can be casted to the specified type, moving from the highest existing layer in the
            layer mask downward. Layer mask defaults to all layers. null is returned if no objects of the specified type are found, or if there are no
            objects at the location.
            </summary>
            <typeparam name="ObjectType">Type of objects to return.</typeparam>
            <param name="x">X-value of the position to get object for.</param>
            <param name="y">Y-value of the position to get object for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>The first object encountered, moving from the highest existing layer in the layer mask downward, or null if there are no objects of
            the specified type are found.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetObjects(GoRogue.Coord,System.UInt32)">
            <summary>
            Gets all objects encountered at the given position, in order from the highest existing layer in the layer mask downward.  Layer mask defaults
            to all layers.
            </summary>
            <param name="position">Position to get objects for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>All objects encountered at the given position, in order from the highest existing layer in the mask downward.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetObjects``1(GoRogue.Coord,System.UInt32)">
            <summary>
            Gets all objects encountered at the given position that are castable to type ObjectType, in order from the highest existing layer in the layer
            mask downward. Layer mask defaults to all layers.
            </summary>
            <typeparam name="ObjectType">Type of objects to return.</typeparam>
            <param name="position">Position to get objects for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>All objects encountered at the given position that are castable to the given type, in order from the highest existing layer
            in the mask downward.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetObjects(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Gets all objects encountered at the given position, in order from the highest existing layer in the layer mask downward.  Layer mask defaults
            to all layers.
            </summary>
            <param name="x">X-value of the position to get objects for.</param>
            <param name="y">Y-value of the position to get objects for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>All objects encountered at the given position, in order from the highest existing layer in the mask downward.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetObjects``1(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Gets all objects encountered at the given position that are castable to type ObjectType, in order from the highest existing layer in the layer
            mask downward. Layer mask defaults to all layers.
            </summary>
            <typeparam name="ObjectType">Type of objects to return.</typeparam>
            <param name="x">X-value of the position to get objects for.</param>
            <param name="y">Y-value of the position to get objects for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>All objects encountered at the given position that are castable to the given type, in order from the highest existing layer
            in the mask downward.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.CalculateFOV(GoRogue.Coord,System.Double)">
            <summary>
            Calculates FOV with the given center point and radius (of shape circle), and stores the result in the <see cref="P:GoRogue.GameFramework.Map.FOV"/> property.  All tiles
            that are in the resulting FOV are marked as explored.  This function calls the virtual overload
            <see cref="M:GoRogue.GameFramework.Map.CalculateFOV(System.Int32,System.Int32,System.Double,GoRogue.Distance)"/>, so if you need to override this functionality, override that overload instead.
            </summary>
            <param name="position">The center point of the new FOV to calculate.</param>
            <param name="radius">The radius of the FOV.  Defaults to infinite.</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map.CalculateFOV(System.Int32,System.Int32,System.Double)">
            <summary>
            Calculates FOV with the given center point and radius (of shape circle), and stores the result in the <see cref="P:GoRogue.GameFramework.Map.FOV"/> property.  All tiles
            that are in the resulting FOV are marked as explored.  This function calls the virtual overload
            <see cref="M:GoRogue.GameFramework.Map.CalculateFOV(System.Int32,System.Int32,System.Double,GoRogue.Distance)"/>, so if you need to override this functionality, override that overload instead.
            </summary>
            <param name="x">X-value of the center point for the new FOV to calculate.</param>
            <param name="y">Y-value of the center point for the new FOV to calculate.</param>
            <param name="radius">The radius of the FOV.  Defaults to infinite.</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map.CalculateFOV(GoRogue.Coord,System.Double,GoRogue.Distance)">
            <summary>
            Calculates FOV with the given center point and radius, and stores the result in the <see cref="P:GoRogue.GameFramework.Map.FOV"/> property.  All tiles that are in the
            resulting FOV are marked as explored.  This function calls the virtual overload
            <see cref="M:GoRogue.GameFramework.Map.CalculateFOV(System.Int32,System.Int32,System.Double,GoRogue.Distance)"/>, so if you need to override this functionality, override that overload instead.
            </summary>
            <param name="position">The center point of the new FOV to calculate.</param>
            <param name="radius">The radius of the FOV.  Defaults to infinite.</param>
            <param name="radiusShape">The shape of the FOV to calculate.  Can be specified as either <see cref="T:GoRogue.Distance"/> or <see cref="T:GoRogue.Radius"/> types
            (they are implicitly convertible).</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map.CalculateFOV(System.Int32,System.Int32,System.Double,GoRogue.Distance)">
            <summary>
            Calculates FOV with the given center point and radius, and stores the result in the <see cref="P:GoRogue.GameFramework.Map.FOV"/> property.  All tiles that are in the
            resulting FOV are marked as explored.  Other non-angle-based overloads call this one, so if you need to override functionality, override
            this function.
            </summary>
            <param name="x">X-value of the center point for the new FOV to calculate.</param>
            <param name="y">Y-value of the center point for the new FOV to calculate.</param>
            <param name="radius">The radius of the FOV.  Defaults to infinite.</param>
            <param name="radiusShape">The shape of the FOV to calculate.  Can be specified as either <see cref="T:GoRogue.Distance"/> or <see cref="T:GoRogue.Radius"/> types
            (they are implicitly convertible).</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map.CalculateFOV(GoRogue.Coord,System.Double,GoRogue.Distance,System.Double,System.Double)">
            <summary>
            Calculates FOV with the given center point and radius, restricted to the given angle and span, and stores the result in the <see cref="P:GoRogue.GameFramework.Map.FOV"/>
            property. All tiles that are in the resulting FOV are marked as explored.  This function calls the virtual overload
            <see cref="M:GoRogue.GameFramework.Map.CalculateFOV(System.Int32,System.Int32,System.Double,GoRogue.Distance,System.Double,System.Double)"/>, so if you need to override this functionality, override that
            overload instead.
            </summary>
            <param name="position">The center point of the new FOV to calculate.</param>
            <param name="radius">The radius of the FOV.  Defaults to infinite.</param>
            <param name="radiusShape">The shape of the FOV to calculate.  Can be specified as either <see cref="T:GoRogue.Distance"/> or <see cref="T:GoRogue.Radius"/> types
            (they are implicitly convertible).</param>
            <param name="angle">The angle in degrees the FOV cone faces.  0 degrees points right.</param>
            <param name="span">The angle in degrees specifying the full arc of the FOV cone.  span/2 degrees on either side of the given angle are included
            in the cone.</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map.CalculateFOV(System.Int32,System.Int32,System.Double,GoRogue.Distance,System.Double,System.Double)">
            <summary>
            Calculates FOV with the given center point and radius, restricted to the given angle and span, and stores the result in the <see cref="P:GoRogue.GameFramework.Map.FOV"/>
            property.  All tiles that are in the resulting FOV are marked as explored.  Other angle-based overloads call this one, so if you need to
            override functionality, override this function.
            </summary>
            <param name="x">X-value of the center point for the new FOV to calculate.</param>
            <param name="y">Y-value of the center point for the new FOV to calculate.</param>
            <param name="radius">The radius of the FOV.  Defaults to infinite.</param>
            <param name="radiusShape">The shape of the FOV to calculate.  Can be specified as either <see cref="T:GoRogue.Distance"/> or <see cref="T:GoRogue.Radius"/> types
            (they are implicitly convertible).</param>
            <param name="angle">The angle in degrees the FOV cone faces.  0 degrees points right.</param>
            <param name="span">The angle in degrees specifying the full arc of the FOV cone.  span/2 degrees on either side of the given angle are included
            in the cone.</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map.CreateMap``1(GoRogue.MapViews.ISettableMapView{``0},System.Int32,GoRogue.Distance,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Effectively a helper-constructor.  Constructs a map using an <see cref="T:GoRogue.MapViews.ISettableMapView`1"/> for the terrain map, where type T can
            be any type that implements <see cref="T:GoRogue.GameFramework.IGameObject"/>.  Note that a Map that is constructed using this function will throw an
            <see cref="T:System.InvalidCastException"/> if any IGameObject is given to <see cref="M:GoRogue.GameFramework.Map.SetTerrain(GoRogue.GameFramework.IGameObject)"/> that cannot be casted to type T.
            </summary>
            <remarks>
            Suppose you have a class MyTerrain that inherits from BaseClass and implements <see cref="T:GoRogue.GameFramework.IGameObject"/>.  This construction function allows
            you to construct your map using an <see cref="T:GoRogue.MapViews.ISettableMapView`1"/> instance as the terrain map, which you cannot do with the regular
            constructor since <see cref="T:GoRogue.MapViews.ISettableMapView`1"/> does not satisfy the constructor's type requirement of
            <see cref="T:GoRogue.MapViews.ISettableMapView`1"/>.
            
            Since this function under the hood creates a <see cref="T:GoRogue.MapViews.SettableTranslationMap`2"/> that translates to/from IGameObject as needed,
            any change made using the map's <see cref="M:GoRogue.GameFramework.Map.SetTerrain(GoRogue.GameFramework.IGameObject)"/> function will be reflected both in the map and in the original
            ISettableMapView.
            </remarks>
            <typeparam name="T">The type of terrain that will be stored in the created Map.  Can be any type that implements <see cref="T:GoRogue.GameFramework.IGameObject"/>.</typeparam>
            <param name="terrainLayer">The <see cref="T:GoRogue.MapViews.ISettableMapView`1"/> that represents the terrain layer for this map.  After the
            map has been created, you should use the <see cref="M:GoRogue.GameFramework.Map.SetTerrain(GoRogue.GameFramework.IGameObject)"/> function to modify the values in this map view, rather
            than setting the values via the map view itself -- if you re-assign the value at a location via the map view, the
            <see cref="E:GoRogue.GameFramework.Map.ObjectAdded"/>/<see cref="E:GoRogue.GameFramework.Map.ObjectRemoved"/> events are NOT guaranteed to be called, and many invariants of map may not be properly
            enforced.</param>
            <param name="numberOfEntityLayers">Number of non-terrain layers for the map.</param>
            <param name="distanceMeasurement"><see cref="T:GoRogue.Distance"/> measurement to use for pathing/measuring distance on the map.</param>
            <param name="layersBlockingWalkability">Layer mask containing those layers that should be allowed to have items that block walkability.
            Defaults to all layers.</param>
            <param name="layersBlockingTransparency">Layer mask containing those layers that should be allowed to have items that block FOV.
            Defaults to all layers.</param>
            <param name="entityLayersSupportingMultipleItems">Layer mask containing those layers that should be allowed to have multiple objects at the same
            location on the same layer.  Defaults to no layers.</param>
            <returns>A new Map whose terrain is created using the given terrainLayer, and with the given parameters.</returns>
        </member>
        <member name="T:GoRogue.IDGenerator">
            <summary>
            Class designed as a helper for situations where you need to generate and assign a unique
            integer to each instance of a class, eg. for a class implementing <see cref="T:GoRogue.IHasID"/>.
            </summary>
            <remarks>
            The class may be initialized with a starting unsigned integer -- if none is given, 0 is the default
            starting point. To assign an ID, call <see cref="M:GoRogue.IDGenerator.UseID"/>, and assign the value that it returns.
            This class is NOT thread-safe on its own -- if it needs to be, you can simply use a lock to wrap
            any calls to UseID.
            </remarks>
        </member>
        <member name="M:GoRogue.IDGenerator.#ctor(System.UInt32)">
            <summary>
            Constructor.
            </summary>
            <param name="startingInt">
            Unsigned integer to start at (one that will be returned first time <see cref="M:GoRogue.IDGenerator.UseID"/> is called).
            Defaults to 0.
            </param>
        </member>
        <member name="M:GoRogue.IDGenerator.UseID">
            <summary>
            Call every time you wish to "assign" an ID. The integer returned will never be returned
            again (each integer returned by this function will be unique).
            </summary>
            <returns>The ID that has been assigned.</returns>
        </member>
        <member name="T:GoRogue.IHasComponents">
            <summary>
            Interface for an object that has components that can be added, removed, checked for, and retrieved by type.  Typically,
            you would implement this via a backing field of type <see cref="T:GoRogue.ComponentContainer"/>, which implements the logic for
            these functions.
            </summary>
        </member>
        <member name="M:GoRogue.IHasComponents.AddComponent(System.Object)">
            <summary>
            Adds the given object as a component.  Throws ArgumentException if the specific instance has already been added.
            </summary>
            <param name="component">Component to add.</param>
        </member>
        <member name="M:GoRogue.IHasComponents.GetComponent``1">
            <summary>
            Gets the first component of type T that was added, or default(T) if no component of that type has
            been added.
            </summary>
            <typeparam name="T">Type of component to retrieve.</typeparam>
            <returns>The first component of Type T that was attached, or default(T) if no components of the given type
            have been attached.</returns>
        </member>
        <member name="M:GoRogue.IHasComponents.GetComponents``1">
            <summary>
            Gets all components of type T that are added.
            </summary>
            <typeparam name="T">Type of components to retrieve.</typeparam>
            <returns>All components of Type T that are attached.</returns>
        </member>
        <member name="M:GoRogue.IHasComponents.HasComponent(System.Type)">
            <summary>
            Returns whether or not there is at least one component of the specified type attached.  Type may be specified
            by using typeof(MyComponentType).
            </summary>
            <param name="componentType">The type of component to check for.</param>
            <returns>True if the implementer has at least one component of the specified type, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.IHasComponents.HasComponent``1">
            <summary>
            Returns whether or not there is at least one component of type T attached.
            </summary>
            <typeparam name="T">Type of component to check for.</typeparam>
            <returns>True if the implemented has at least one component of the specified type attached, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.IHasComponents.HasComponents(System.Type[])">
            <summary>
            Returns whether or not the implementer has at least one of all of the given types of components attached.  Types may be specified by
            using typeof(MyComponentType)
            </summary>
            <param name="componentTypes">One or more component types to check for.</param>
            <returns>True if the implementer has at least one component of each specified type, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.IHasComponents.RemoveComponent(System.Object)">
            <summary>
            Removes the given component.  Throws an exception if the component isn't attached.
            </summary>
            <param name="component">Component to remove.</param>
        </member>
        <member name="M:GoRogue.IHasComponents.RemoveComponents(System.Object[])">
            <summary>
            Removes the given component(s).  Throws an exception if a component given isn't attached.
            </summary>
            <param name="components">One or more component instances to remove.</param>
        </member>
        <member name="T:GoRogue.IHasID">
             <summary>
             Interface for a class that has an ID value, typically used for items in a spatial map, or generally
             for purposes of hashing.
             </summary>
             <remarks>
             The ID assigned should be unique or close to unique over all instances of the class (to avoid hash collisions).
             A typical implementation could be simply randomly generating the ID value.  To assign completely unique IDs, an
             <see cref="T:GoRogue.IDGenerator"/> can be used:
             <example>
             <code>
             class SomeClass : IHasID
             {
                 // Static instance used to assign IDs to ANY new SomeClass instance
                 private static IDGenerator generator = new IDGenerator();
                 public uint ID { get; }
            
                 public SomeClass(...)
                 {
                     ID = generator.UseID();
                 }
             }
             </code>
             </example>
             </remarks>
        </member>
        <member name="P:GoRogue.IHasID.ID">
            <summary>
            ID assigned to this object.
            </summary>
        </member>
        <member name="T:GoRogue.IHasLayer">
            <summary>
            Interface to be implemented by objects that will be added to a <see cref="T:GoRogue.LayeredSpatialMap`1"/>.
            </summary>
        </member>
        <member name="P:GoRogue.IHasLayer.Layer">
            <summary>
            The layer on which the object should reside. Higher numbers indicate layers closer to the
            "top".
            </summary>
            <remarks>
            This value is assumed to remain constant while the object is within a data structure
            that uses this interface -- if it is modified, that data structure will become out of sync.
            </remarks>
        </member>
        <member name="T:GoRogue.IReadOnlyDisjointSet">
            <summary>
            Read-only representation of <see cref="T:GoRogue.DisjointSet"/>
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyDisjointSet.Count">
            <summary>
            Number of distinct sets.
            </summary>
        </member>
        <member name="M:GoRogue.IReadOnlyDisjointSet.Find(System.Int32)">
            <summary>
            Returns the parent of the set containing <paramref name="obj"/>, performing path compression as search is completed.
            </summary>
            <param name="obj">Object to search for.</param>
            <returns>The parent of the object given.</returns>
        </member>
        <member name="M:GoRogue.IReadOnlyDisjointSet.InSameSet(System.Int32,System.Int32)">
            <summary>
            Returns true if the two objects specified are in the same set.
            </summary>
            <param name="obj1"/>
            <param name="obj2"/>
            <returns>True if the two objects are in the same set, false otherwise.</returns>
        </member>
        <member name="T:GoRogue.IReadOnlyFOV">
            <summary>
            Read-only interface of the <see cref="T:GoRogue.FOV"/> class.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyFOV.BooleanFOV">
            <summary>
            A view of the calculation results in boolean form, where true indicates a location is in
            field of view, and false indicates it is not.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyFOV.CurrentFOV">
            <summary>
            IEnumerable of only positions currently in the field of view.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyFOV.NewlySeen">
            <summary>
            IEnumerable of positions that ARE in field of view as of the most current Calculate call, but were
            NOT in field of view after the previous time Calculate was called.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyFOV.NewlyUnseen">
            <summary>
            IEnumerable of positions that are NOT in field of view as of the most current Calculate call, but
            WERE in field of view after the previous time Calculate was called.
            </summary>
        </member>
        <member name="T:GoRogue.IReadOnlyLayeredSpatialMap`1">
            <summary>
            Interface implementing only the read-only functions for <see cref="T:GoRogue.LayeredSpatialMap`1"/>/
            <see cref="T:GoRogue.AdvancedLayeredSpatialMap`1"/>.
            </summary>
            <typeparam name="T">
            Type of element stored in the layered spatial map -- must implement <see cref="T:GoRogue.IHasLayer"/>.
            </typeparam>
        </member>
        <member name="P:GoRogue.IReadOnlyLayeredSpatialMap`1.LayerMasker">
            <summary>
            Object used to get layer masks as they pertain to this spatial map.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyLayeredSpatialMap`1.Layers">
            <summary>
            Gets read-only spatial maps representing each layer. To access a specific layer, instead
            use <see cref="M:GoRogue.IReadOnlyLayeredSpatialMap`1.GetLayer(System.Int32)"/>.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyLayeredSpatialMap`1.NumberOfLayers">
            <summary>
            Gets the number of layers contained in the spatial map.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyLayeredSpatialMap`1.StartingLayer">
            <summary>
            Starting index for layers contained in this spatial map.
            </summary>
        </member>
        <member name="M:GoRogue.IReadOnlyLayeredSpatialMap`1.AsReadOnly">
            <summary>
            Returns a read-only reference to the spatial map. Convenient for "safely" exposing the
            spatial map as a property.
            </summary>
            <returns>The current spatial map, as a "read-only" reference.</returns>
        </member>
        <member name="M:GoRogue.IReadOnlyLayeredSpatialMap`1.Contains(GoRogue.Coord,System.UInt32)">
            <summary>
            Returns whether or not there is an item in the spatial map at the given position that
            is on a layer included in the given layer mask. Defaults to searching on all layers.
            </summary>
            <param name="position">The position to check for.</param>
            <param name="layerMask">
            Layer mask that indicates which layers to check. Defaults to all layers.
            </param>
            <returns>
            True if there is some item at the given position on a layer included in the given layer
            mask, false if not.
            </returns>
        </member>
        <member name="M:GoRogue.IReadOnlyLayeredSpatialMap`1.Contains(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Returns whether or not there is an item in the data structure at the given position, that
            is on a layer included in the given layer mask.
            </summary>
            <param name="x">X-value of the position to check for.</param>
            <param name="y">Y-value of the position to check for.</param>
            <param name="layerMask">
            Layer mask that indicates which layers to check. Defaults to all layers.
            </param>
            <returns>
            True if there is some item at the given position on a layer included in the given layer
            mask, false if not.
            </returns>
        </member>
        <member name="M:GoRogue.IReadOnlyLayeredSpatialMap`1.GetItems(GoRogue.Coord,System.UInt32)">
            <summary>
            Gets the item(s) associated with the given position that reside on any layer included in
            the given layer mask. Returns nothing if there is nothing at that position on a layer
            included in the given layer mask.
            </summary>
            <param name="position">The position to return the item(s) for.</param>
            <param name="layerMask">
            Layer mask that indicates which layers to check. Defaults to all layers.
            </param>
            <returns>
            The item(s) at the given position that reside on a layer included in the layer mask if
            there are any items, or nothing if there is nothing at that position.
            </returns>
        </member>
        <member name="M:GoRogue.IReadOnlyLayeredSpatialMap`1.GetItems(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Gets the item(s) associated with the given position that reside on any layer included in
            the given layer mask. Returns nothing if there is nothing at that position on a layer
            included in the given layer mask.
            </summary>
            <param name="x">X-value of the position to return the item(s) for.</param>
            <param name="y">Y-value of the position to return the item(s) for.</param>
            <param name="layerMask">
            Layer mask that indicates which layers to check. Defaults to all layers.
            </param>
            <returns>
            The item(s) at the given position that reside on a layer included in the layer mask if
            there are any items, or nothing if there is nothing at that position.
            </returns>
        </member>
        <member name="M:GoRogue.IReadOnlyLayeredSpatialMap`1.GetLayer(System.Int32)">
            <summary>
            Gets a read-only spatial map representing the layer specified.
            </summary>
            <param name="layer">The layer to retrieve.</param>
            <returns>The IReadOnlySpatialMap that represents the given layer.</returns>
        </member>
        <member name="M:GoRogue.IReadOnlyLayeredSpatialMap`1.GetLayers(System.UInt32)">
            <summary>
            Returns read-only spatial maps that represent each layer included in the given layer
            mask. Defaults to all layers.
            </summary>
            <param name="layerMask">
            Layer mask indicating which layers to return. Defaults to all layers.
            </param>
            <returns>Read-only spatial maps representing each layer in the given layer mask.</returns>
        </member>
        <member name="T:GoRogue.LayerMasker">
            <summary>
            Allows convenient interpretation and creation of layer masks (bit-masks) that can be used
            to interact with <see cref="T:GoRogue.LayeredSpatialMap`1"/> and <see cref="T:GoRogue.GameFramework.Map"/>.
            </summary>
            <remarks>
            A layer mask is simply a list of layers.  It is frequently used in <see cref="T:GoRogue.LayeredSpatialMap`1"/>
            and <see cref="T:GoRogue.GameFramework.Map"/> as an optional parameter that indicates what layers should apply
            to an operation or given set of functionality.
            
            LayeredSpatialMap and Map both define their own LayerMask variable that should be used to retrieve
            layer masks whenever possible.  For layer masks needed outside of that, or when constructing
            those classes, use <see cref="F:GoRogue.LayerMasker.DEFAULT"/>.  There are also constants defined in 
            LayerMasker to represent "all layers" and "no layers".
            </remarks>
        </member>
        <member name="F:GoRogue.LayerMasker.DEFAULT">
            <summary>
            Default layer masker, that excludes no possible layers from its results.
            </summary>
        </member>
        <member name="F:GoRogue.LayerMasker.ALL_LAYERS">
            <summary>
            Layer-mask representing all layers.
            </summary>
        </member>
        <member name="F:GoRogue.LayerMasker.NO_LAYERS">
            <summary>
            Layer mask representing no layers.
            </summary>
        </member>
        <member name="M:GoRogue.LayerMasker.#ctor(System.Int32)">
            <summary>
            Constructor. Takes the number of layers allowed, which must be more than 0 and less than
            or equal to 32.
            </summary>
            <param name="numberOfLayers">The number of layers supported by this layer mask generator.</param>
        </member>
        <member name="P:GoRogue.LayerMasker.NumberOfLayers">
            <summary>
            Maximum number of layers supported by this layer masker. Functions using layer masks enforce this limit,
            and will not consider layers outside the range [0, NumberOfLayers - 1]
            </summary>
        </member>
        <member name="M:GoRogue.LayerMasker.AddLayers(System.UInt32,System.Int32[])">
            <summary>
            Adds the given layers to the given layer mask, provided those layers are within the
            supported number of layers. Any layer outside of this range will not be added.
            </summary>
            <param name="mask">The mask to add the layers to.</param>
            <param name="layers">Layers to include in the resulting layer mask.</param>
            <returns>
            A layer mask including any original layers that were in the given mask (regardless of
            whether they were within the supported number of layers), as well as the new layers
            provided (provided they are within the supported number of layers).
            </returns>
        </member>
        <member name="M:GoRogue.LayerMasker.AddLayers(System.UInt32,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Adds the given layers to the given layer mask, provided those layers are within the
            supported number of layers. Any layer outside of this range will not be added.
            </summary>
            <param name="mask">The mask to add the layers to.</param>
            <param name="layers">Layers to include in the resulting layer mask.</param>
            <returns>
            A layer mask including any original layers that were in the given mask (regardless of
            whether they were within the supported number of layers), as well as the new layers
            provided (provided they are within the supported number of layers).
            </returns>
        </member>
        <member name="M:GoRogue.LayerMasker.HasLayer(System.UInt32,System.Int32)">
            <summary>
            Returns whether or not a layer is contained within the given layer mask. Returns false if
            the layer given is outside the supported number of layers.
            </summary>
            <param name="mask">Layer mask to check.</param>
            <param name="layer">Layer to check for.</param>
            <returns>
            True if the given layer is present in the given layer mask, false if it is not or the
            layer is outside the supported number of layers for this LayerMasker.
            </returns>
        </member>
        <member name="M:GoRogue.LayerMasker.Layers(System.UInt32)">
            <summary>
            Returns an IEnumerable of all layers contained within the given layer mask (that fall
            within the supported number of layers).
            </summary>
            <param name="mask">Layer mask to return layers for.</param>
            <returns>
            All layers contained within the given layer mask that fall within the supported number of
            layers for this LayerMasker.
            </returns>
        </member>
        <member name="M:GoRogue.LayerMasker.Mask(System.Int32[])">
            <summary>
            Gets a layer mask including exactly the given layer indices. Any layer given outside the
            maximum number of layers is ignored, and will not be added to the resulting mask.
            </summary>
            <param name="layers">One or more layers to include in generated layer mask.</param>
            <returns>
            A layer mask including exactly those layers in the input that were within the supported
            number of layers.
            </returns>
        </member>
        <member name="M:GoRogue.LayerMasker.Mask(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Gets a layer mask including exactly the given layer indices. Any layer given outside the
            maximum number of layers is ignored, and will not be added to the resulting mask.
            </summary>
            <param name="layers">Layers to include in generated layer mask.</param>
            <returns>
            A layer mask including exactly those layers in the input that were within the supported
            number of layers.
            </returns>
        </member>
        <member name="M:GoRogue.LayerMasker.MaskAllAbove(System.Int32)">
            <summary>
            Generates and returns a layer mask including the given layer and any layer above (greater
            than) it. Layers not in the supported number of layers will be ignored, and will not be
            added to the resulting layer mask.
            </summary>
            <param name="layer">Layer to start the mask at.</param>
            <returns>
            A layer mask including the specified layer and all layers above it, provided those layers
            fall within the supported number of layers.
            </returns>
        </member>
        <member name="M:GoRogue.LayerMasker.MaskAllBelow(System.Int32)">
            <summary>
            Generates and returns a layer mask including the given layer and any layer below (less
            than) it. Layers not in the supported number of layers will be ignored, and will not be
            added to the resulting layer mask.
            </summary>
            <param name="layer">Layer to start the mask at.</param>
            <returns>
            A layer mask including the specified layer and all layers below it, provided those layers
            fall within the supported number of layers.
            </returns>
        </member>
        <member name="T:GoRogue.IReadOnlyRadiusAreaProvider">
            <summary>
            Read-only interface of <see cref="T:GoRogue.RadiusAreaProvider"/>.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyRadiusAreaProvider.Bounds">
            <summary>
            The bounds to constrain the returned locations to. Set to <see cref="F:GoRogue.Rectangle.EMPTY"/>
            to indicate that there are no bounds.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyRadiusAreaProvider.Center">
            <summary>
            The center point of the radius.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyRadiusAreaProvider.DistanceCalc">
            <summary>
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to a distance method, eg. <see cref="P:GoRogue.IReadOnlyRadiusAreaProvider.Radius"/>).
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyRadiusAreaProvider.Radius">
            <summary>
            The length of the radius, eg. the number of tiles from the center point (as defined by
            the distance calculation/radius shape given) to which the radius extends.
            </summary>
            <remarks>
            When this value is changed, reallocation of an underlying array is performed, however overhead should
            be relatively small in most cases.
            </remarks>
        </member>
        <member name="M:GoRogue.IReadOnlyRadiusAreaProvider.CalculatePositions">
            <summary>
            Calculates the new radius, and returns an IEnumerable of all unique locations within that
            radius and bounds specified (as applicable).
            </summary>
            <remarks>
            In the case that MANHATTAN/CHEBYSHEV distance, or DIAMOND/SQUARE/OCTAHEDRON/CUBE radius shapes
            are specified via <see cref="P:GoRogue.IReadOnlyRadiusAreaProvider.DistanceCalc"/>, positions returned are guaranteed to be returned
            in order of distance from the center, from least to greatest. This guarantee does NOT hold if
            EUCLIDEAN distance, or CIRCLE/SPHERE radius shapes are specified.
            </remarks>
            <returns>Enumerable of all unique positions within the radius and bounds specified.</returns>
        </member>
        <member name="T:GoRogue.IReadOnlySpatialMap`1">
            <summary>
            Implements the read-only interface of <see cref="T:GoRogue.ISpatialMap`1"/>.
            </summary>
            <remarks>
            Simply exposes only those functions of <see cref="T:GoRogue.ISpatialMap`1"/> that do not allow direct modification
            of the data (eg. adding/moving/removing items). This can allow for direct exposure of an ISpatialMap as a
            property of type IReadOnlySpatialMap, without allowing such an exposure to break data
            encapsulation principles of something like a game map.
            </remarks>
        </member>
        <member name="E:GoRogue.IReadOnlySpatialMap`1.ItemAdded">
            <summary>
            Event that is fired directly after an item has been added to the spatial map.
            </summary>
        </member>
        <member name="E:GoRogue.IReadOnlySpatialMap`1.ItemMoved">
            <summary>
            Event that is fired directly after an item in the sptial map has been moved.
            </summary>
        </member>
        <member name="E:GoRogue.IReadOnlySpatialMap`1.ItemRemoved">
            <summary>
            Event that is fired directly after an item has been removed from the spatial map.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlySpatialMap`1.Count">
            <summary>
            The number of items in the spatial map.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlySpatialMap`1.Items">
            <summary>
            Enumerable of the items stored in the spatial map: for use to iterate over all items with a foreach loop.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlySpatialMap`1.Positions">
            <summary>
            Enumerable of all positions that contain items.
            </summary>
        </member>
        <member name="M:GoRogue.IReadOnlySpatialMap`1.AsReadOnly">
            <summary>
            Returns a read-only reference to the spatial map. Convenient for "safely" exposing the
            spatial as a property, without allowing direct modification.
            </summary>
            <returns>The current spatial map, as a "read-only" reference.</returns>
        </member>
        <member name="M:GoRogue.IReadOnlySpatialMap`1.Contains(`0)">
            <summary>
            Returns whether or not the spatial map contains the given item.
            </summary>
            <param name="item">The item to check for.</param>
            <returns>True if the given item is contained in the spatial map, false if not.</returns>
        </member>
        <member name="M:GoRogue.IReadOnlySpatialMap`1.Contains(GoRogue.Coord)">
            <summary>
            Returns if there is an item in the spatial map at the given position or not.
            </summary>
            <param name="position">The position to check for.</param>
            <returns>True if there is some item at the given position, false if not.</returns>
        </member>
        <member name="M:GoRogue.IReadOnlySpatialMap`1.Contains(System.Int32,System.Int32)">
            <summary>
            Returns if there is an item in the spatial map at the given position or not.
            </summary>
            <param name="x">The x-value of the position to check for.</param>
            <param name="y">The y-value of the position to check for.</param>
            <returns>True if there is some item at the given position, false if not.</returns>
        </member>
        <member name="M:GoRogue.IReadOnlySpatialMap`1.GetItems(GoRogue.Coord)">
            <summary>
            Gets the item(s) at the given position if there are any items, or returns
            nothing if there is nothing at that position.
            </summary>
            <param name="position">The position to return the item(s) for.</param>
            <returns>
            The item(s) at the given position if there are any items, or nothing if there is nothing
            at that position.
            </returns>
        </member>
        <member name="M:GoRogue.IReadOnlySpatialMap`1.GetItems(System.Int32,System.Int32)">
            <summary>
            Gets the item(s) at the given position if there are any items, or returns
            nothing if there is nothing at that position.
            </summary>
            <param name="x">The x-value of the position to return the item(s) for.</param>
            <param name="y">The y-value of the position to return the item(s) for.</param>
            <returns>
            The item(s) at the given position if there are any items, or nothing if there is nothing
            at that position.
            </returns>
        </member>
        <member name="M:GoRogue.IReadOnlySpatialMap`1.GetPosition(`0)">
            <summary>
            Gets the position associated with the given item in the spatial map, or null if that item is
            not found.
            </summary>
            <param name="item">The item to get the position for.</param>
            <returns>
            The position associated with the given item, if it exists in the spatial map, or <see cref="F:GoRogue.Coord.NONE"/>
            if the item does not exist.
            </returns>
        </member>
        <member name="M:GoRogue.IReadOnlySpatialMap`1.ToString(System.Func{`0,System.String})">
            <summary>
            Returns a string representation of the IReadOnlySpatialMap, allowing display of the spatial map's
            items in a specified way.
            </summary>
            <param name="itemStringifier">Function that turns an item into a string.</param>
            <returns>A string representation of the spatial map.</returns>
        </member>
        <member name="T:GoRogue.ISpatialTuple`1">
            <summary>
            Interface specifying return type for item-location pairs in spatial maps.
            </summary>
            <typeparam name="T">Type of the item associated with locations.</typeparam>
        </member>
        <member name="P:GoRogue.ISpatialTuple`1.Item">
            <summary>
            The item associated with this pair.
            </summary>
        </member>
        <member name="P:GoRogue.ISpatialTuple`1.Position">
            <summary>
            The position associated with this pair.
            </summary>
        </member>
        <member name="T:GoRogue.ISortedComponent">
            <summary>
            Optional interface that may be implemented by components to ensure they are returned in a specific order
            when <see cref="M:GoRogue.ComponentContainer.GetComponent``1"/> is called.  Components are not required to implement
            this interface, however components that do not will be returned after any components that do.
            </summary>
            <remarks>
            When the GetComponents function of either ComponentContainer or any object that uses one to implement the component
            system (such as <see cref="T:GoRogue.GameFramework.IGameObject"/> is called, any components with a lower <see cref="P:GoRogue.ISortedComponent.SortOrder"/>
            are guaranteed to be returned BEFORE any components with a higher SortOrder.  This can be useful to enforce that certain
            types of or instances of components are processed before some other type of or instance of components.  Components that
            do not implement ISortedComponent will always be retorned AFTER any components that do implement that interface. 
            </remarks>
        </member>
        <member name="P:GoRogue.ISortedComponent.SortOrder">
            <summary>
            Value indicating the relative ordering of this component.  A lower value cause a component to be retrieved before
            any components with a higher value.
            </summary>
        </member>
        <member name="T:GoRogue.ISpatialMap`1">
            <summary>
            Interface common to spatial map implementations provided with GoRogue, which are designed
            to be a convenient way to store items that reside on a map.  TLDR; If you're about
            to use a List to store all the objects on a map, consider using a (GoRogue-provided) ISpatialMap
            implementation instead.
            </summary>
            <remarks>
            Typical roguelikes will use a 2D array (or 1D array accessed as a 2D array), for terrain, and
            lists of objects for things like entities, items, etc. This is simple but ultimately not
            efficient; for example, in that implementation, determining if there is an object at a
            location takes an amount of time proportional to the number of objects in this list. However,
            the other simple option is to use an array with size equal to the size of the map (as many do
            for terrain) for all object lists. This is even less ideal, as in that case, the time to
            iterate over all objects becomes proportional to the size of the map (since one has to do
            that for rendering, that's bad!), which is typically much larger than the number of objects in a
            list. This is the problem spatial map implementions are designed to solve. They provide fast,
            near-constant-time operations for getting the item(s) at a location, adding items, and removing
            items.  As well, they allow you to iterate through all objects in the spatial map in time
            proportional to the number of objects in it (the best possible). Effectively, it is a more efficient
            list for objects that have a position associated with them.  Spatial maps also provide events for when
            things are added, removed, etc., to allow you to conveniently respond to those types of actions.
            
            Spatial maps have to keep track of the position of each item in them in order to provide
            their fast-lookup functionality.  Spatial maps can be used as the primary authority for what an item's
            position is in some cases -- however, in many cases, this may be undesireable, particularly when interfacing
            with more traditional infrastructures from other libraries, which likely record each item's position as a field
            or property of the item itself.  In these cases, where the item itself records its position, you will need to
            call the <see cref="M:GoRogue.ISpatialMap`1.Move(`0,GoRogue.Coord)"/> function (or a similar overload) whenever an object moves, to keep the
            spatial map's position for that item in sync with its actual position.
            
            It is also worthy of note, that some implementations of ISpatialMap (such as <see cref="T:GoRogue.SpatialMap`1"/>) have implemented
            <see cref="M:GoRogue.ISpatialMap`1.Move(`0,GoRogue.Coord)"/> in such a way that it could fail in some cases.  Move will return false in cases where it
            fails, so if you are using an implementation where that may happen, you may need to check this to avoid desync issues.
            The Move function documentation for each implementation clearly states in what cases a call to Move can fail.
            </remarks>
            <typeparam name="T">The type of object that will be contained by the spatial map.</typeparam>
        </member>
        <member name="M:GoRogue.ISpatialMap`1.Add(`0,GoRogue.Coord)">
            <summary>
            Adds the given item at the given position, and returns true if the item was successfully
            added. If the item could not be added, returns false.
            </summary>
            <param name="newItem">Item to add.</param>
            <param name="position">Position to add item to.</param>
            <returns>True if item was successfully added, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.ISpatialMap`1.Add(`0,System.Int32,System.Int32)">
            <summary>
            Adds the given item at the given position, and returns true if the item was successfully
            added. If the item could not be added, returns false.
            </summary>
            <param name="newItem">Item to add.</param>
            <param name="x">X-value of the position to add item to.</param>
            <param name="y">Y-value of the position to add item to.</param>
            <returns>True if item was successfully added, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.ISpatialMap`1.Clear">
            <summary>
            Clears all items out of the spatial map.
            </summary>
        </member>
        <member name="M:GoRogue.ISpatialMap`1.Move(`0,GoRogue.Coord)">
            <summary>
            Moves the given item from its current location to the specified one. Returns true if the
            item was successfully moved, false otherwise.
            </summary>
            <param name="item">Item to move.</param>
            <param name="target">Location to move item to.</param>
            <returns>True if item was successfully moved, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.ISpatialMap`1.Move(`0,System.Int32,System.Int32)">
            <summary>
            Moves the given item from its current location to the specified one. Returns true if the
            item was successfully moved, false otherwise.
            </summary>
            <param name="item">Item to move</param>
            <param name="targetX">X-value of the location to move item to.</param>
            <param name="targetY">Y-value of the location to move item to.</param>
            <returns>True if item was successfully moved, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.ISpatialMap`1.Move(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Moves any items at the specified location to the target one. Returns any items that were moved.
            </summary>
            <param name="current">Location to move items from.</param>
            <param name="target">Location to move items to.</param>
            <returns>Any items that were moved, or nothing if no items were moved.</returns>
        </member>
        <member name="M:GoRogue.ISpatialMap`1.Move(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Moves any items at the specified location to the target one. Returns any items that were moved.
            </summary>
            <param name="currentX">X-value of the location to move items from.</param>
            <param name="currentY">Y-value of the location to move items from.</param>
            <param name="targetX">X-value of the location to move items to.</param>
            <param name="targetY">Y-value of the location to move items to.</param>
            <returns>Any items that were moved, or nothing if no items were moved.</returns>
        </member>
        <member name="M:GoRogue.ISpatialMap`1.Remove(`0)">
            <summary>
            Removes the given item from the spatial map, returning true if the item was removed, false
            otherwise.
            </summary>
            <param name="item">The item to remove.</param>
            <returns>True if item was removed, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.ISpatialMap`1.Remove(GoRogue.Coord)">
            <summary>
            Removes any items at the specified location from the spatial map. Returns any items
            that were removed.
            </summary>
            <param name="position">Position to remove items from.</param>
            <returns>Any items that were removed, or nothing if no items were removed.</returns>
        </member>
        <member name="M:GoRogue.ISpatialMap`1.Remove(System.Int32,System.Int32)">
            <summary>
            Removes any items at the specified location from the spatial map. Returns any items
            that were removed.
            </summary>
            <param name="x">X-value of the position to remove items from.</param>
            <param name="y">Y-value of the position to remove items from.</param>
            <returns>Any items that were removed, or nothing if no items were removed.</returns>
        </member>
        <member name="T:GoRogue.ItemEventArgs`1">
            <summary>
            Event arguments for spatial map events pertaining to an item (<see cref="E:GoRogue.IReadOnlySpatialMap`1.ItemAdded"/>,
            <see cref="E:GoRogue.IReadOnlySpatialMap`1.ItemRemoved"/>, etc.)
            </summary>
            <typeparam name="T">Type of item.</typeparam>
        </member>
        <member name="M:GoRogue.ItemEventArgs`1.#ctor(`0,GoRogue.Coord)">
            <summary>
            Constructor.
            </summary>
            <param name="item">Item being represented.</param>
            <param name="position">Current position of the item.</param>
        </member>
        <member name="M:GoRogue.ItemEventArgs`1.#ctor(`0,System.Int32,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="item">Item being represented.</param>
            <param name="x">X-value of the current position of the item.</param>
            <param name="y">Y-value of the current position of the item.</param>
        </member>
        <member name="P:GoRogue.ItemEventArgs`1.Item">
            <summary>
            Item being represented.
            </summary>
        </member>
        <member name="P:GoRogue.ItemEventArgs`1.Position">
            <summary>
            Current position of that item at time of event.
            </summary>
        </member>
        <member name="T:GoRogue.ItemMovedEventArgs`1">
            <summary>
            Event arguments for spatial maps <see cref="E:GoRogue.IReadOnlySpatialMap`1.ItemMoved"/> event.
            </summary>
            <typeparam name="T">Type of item being stored.</typeparam>
        </member>
        <member name="M:GoRogue.ItemMovedEventArgs`1.#ctor(`0,GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Constructor.
            </summary>
            <param name="item">Item being represented.</param>
            <param name="oldPosition">Position of item before it was moved.</param>
            <param name="newPosition">Position of item after it has been moved.</param>
        </member>
        <member name="M:GoRogue.ItemMovedEventArgs`1.#ctor(`0,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="item">Item being represented.</param>
            <param name="oldPositionX">X-value of the position of item before it was moved.</param>
            <param name="oldPositionY">Y-value of the position of item before it was moved.</param>
            <param name="newPositionX">X-value of the position of item after it has been moved.</param>
            <param name="newPositionY">Y-value of the position of item after it has been moved.</param>
        </member>
        <member name="P:GoRogue.ItemMovedEventArgs`1.Item">
            <summary>
            Item being represented.
            </summary>
        </member>
        <member name="P:GoRogue.ItemMovedEventArgs`1.NewPosition">
            <summary>
            Position of item after it has been moved.
            </summary>
        </member>
        <member name="P:GoRogue.ItemMovedEventArgs`1.OldPosition">
            <summary>
            Position of item before it was moved.
            </summary>
        </member>
        <member name="T:GoRogue.IDComparer`1">
            <summary>
            Class intended for comparing/hashing objects that implement <see cref="T:GoRogue.IHasID"/>. Type T must be a
            reference type.
            </summary>
            <typeparam name="T">
            Type of object being compared. Type T must be a reference type that implements <see cref="T:GoRogue.IHasID"/>.
            </typeparam>
        </member>
        <member name="M:GoRogue.IDComparer`1.Equals(`0,`0)">
            <summary>
            Equality comparison. Performs comparison via the object's <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>
            function.
            </summary>
            <param name="x">First object to compare.</param>
            <param name="y">Second object to compare.</param>
            <returns>True if the objects are considered equal, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.IDComparer`1.GetHashCode(`0)">
            <summary>
            Generates a hash based on the object's ID.GetHashCode() function.
            </summary>
            <param name="obj">Object to generate the hash for.</param>
            <returns>The hash of the object, based on its ID.</returns>
        </member>
        <member name="T:GoRogue.AdvancedLayeredSpatialMap`1">
            <summary>
            A more complex version of <see cref="T:GoRogue.LayeredSpatialMap`1"/> that does not require the items in it to implement
            <see cref="T:GoRogue.IHasID"/>, instead requiring the specification of a custom <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to use
            for hashing and comparison of items.
            </summary>
            <remarks>
            This class is useful for cases where you do not want to implement <see cref="T:GoRogue.IHasID"/>. For simple cases, it is
            recommended to use <see cref="T:GoRogue.LayeredSpatialMap`1"/> instead.
            
            Be mindful of the efficiency of your hashing function specified in the <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> --
            it will in large part determine the performance of AdvancedLayeredSpatialMap!
            </remarks>
            <typeparam name="T">
            Type of items in the layers. Type T must implement <see cref="T:GoRogue.IHasLayer"/>, and its <see cref="P:GoRogue.IHasLayer.Layer"/> value
            MUST NOT change while the item is in the AdvancedLayeredSpatialMap.
            </typeparam>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32,System.Int32,System.UInt32)">
            <summary>
            Constructor.
            </summary>
            <param name="comparer">
            Equality comparer to use for comparison and hashing of type T. Be especially mindful of the
            efficiency of its GetHashCode function, as it will determine the efficiency of
            many AdvancedLayeredSpatialMap functions.
            </param>
            <param name="numberOfLayers">Number of layers to include.</param>
            <param name="startingLayer">Index to use for the first layer.</param>
            <param name="layersSupportingMultipleItems">
            A layer mask indicating which layers should support multiple items residing at the same
            location on that layer. Defaults to no layers.
            </param>
        </member>
        <member name="E:GoRogue.AdvancedLayeredSpatialMap`1.ItemAdded">
            <summary>
            See <see cref="E:GoRogue.IReadOnlySpatialMap`1.ItemAdded"/>.
            </summary>
        </member>
        <member name="E:GoRogue.AdvancedLayeredSpatialMap`1.ItemMoved">
            <summary>
            See <see cref="E:GoRogue.IReadOnlySpatialMap`1.ItemMoved"/>.
            </summary>
        </member>
        <member name="E:GoRogue.AdvancedLayeredSpatialMap`1.ItemRemoved">
            <summary>
            See <see cref="E:GoRogue.IReadOnlySpatialMap`1.ItemRemoved"/>.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedLayeredSpatialMap`1.Count">
            <summary>
            See <see cref="P:GoRogue.IReadOnlySpatialMap`1.Count"/>
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedLayeredSpatialMap`1.Items">
            <summary>
            See <see cref="P:GoRogue.IReadOnlySpatialMap`1.Items"/>.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedLayeredSpatialMap`1.LayerMasker">
            <summary>
            Object used to get layer masks as they pertain to this spatial map.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedLayeredSpatialMap`1.Layers">
            <summary>
            Gets read-only spatial maps representing each layer. To access a specific layer, instead
            use <see cref="M:GoRogue.AdvancedLayeredSpatialMap`1.GetLayer(System.Int32)"/>.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedLayeredSpatialMap`1.NumberOfLayers">
            <summary>
            Gets the number of layers contained in the spatial map.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedLayeredSpatialMap`1.Positions">
            <summary>
            Gets all positions that have items for each layer. No positions are duplicated if
            multiple layers have an item at a position.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedLayeredSpatialMap`1.StartingLayer">
            <summary>
            Starting index for layers contained in this spatial map.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Add(`0,GoRogue.Coord)">
            <summary>
            Adds the given item at the given position. Item is automatically added to correct layer.
            </summary>
            <param name="newItem">Item to add.</param>
            <param name="position">Position to add item at.</param>
            <returns>True if the item was successfully added -- false otherwise.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Add(`0,System.Int32,System.Int32)">
            <summary>
            Adds the given item at the given position, or returns false if the item cannot be added.
            Item is automatically added to correct layer.
            </summary>
            <param name="newItem">Item to add.</param>
            <param name="x">X-value of position to add item at.</param>
            <param name="y">Y-value of position to add item at.</param>
            <returns>True if the item was successfully added, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GoRogue#IReadOnlySpatialMap{T}#AsReadOnly">
            <summary>
            See <see cref="M:GoRogue.IReadOnlySpatialMap`1.AsReadOnly"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.AsReadOnly">
            <summary>
            See <see cref="M:GoRogue.IReadOnlyLayeredSpatialMap`1.AsReadOnly"/>.
            </summary>
            <returns>The current data structure, as a "read-only" reference.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Clear">
            <summary>
            See <see cref="M:GoRogue.ISpatialMap`1.Clear"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Contains(`0)">
            <summary>
            See <see cref="M:GoRogue.IReadOnlySpatialMap`1.Contains(`0)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GoRogue#IReadOnlySpatialMap{T}#Contains(GoRogue.Coord)">
            <summary>
            See <see cref="M:GoRogue.IReadOnlySpatialMap`1.Contains(GoRogue.Coord)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Contains(GoRogue.Coord,System.UInt32)">
            <summary>
            See <see cref="M:GoRogue.IReadOnlyLayeredSpatialMap`1.Contains(GoRogue.Coord,System.UInt32)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GoRogue#IReadOnlySpatialMap{T}#Contains(System.Int32,System.Int32)">
            <summary>
            See <see cref="M:GoRogue.IReadOnlySpatialMap`1.Contains(System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Contains(System.Int32,System.Int32,System.UInt32)">
            <summary>
            See <see cref="M:GoRogue.IReadOnlyLayeredSpatialMap`1.Contains(System.Int32,System.Int32,System.UInt32)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GetEnumerator">
            <summary>
            Used by foreach loop, so that the class will give ISpatialTuple objects when used in a
            foreach loop. Generally should never be called explicitly.
            </summary>
            <returns>An enumerator for the spatial map</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Generic iterator used internally by foreach loops.
            </summary>
            <returns>Enumerator to ISpatialTuple instances.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GoRogue#IReadOnlySpatialMap{T}#GetItems(GoRogue.Coord)">
            <summary>
            <see cref="M:GoRogue.IReadOnlySpatialMap`1.GetItems(GoRogue.Coord)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GetItems(GoRogue.Coord,System.UInt32)">
            <summary>
            See <see cref="M:GoRogue.IReadOnlyLayeredSpatialMap`1.GetItems(GoRogue.Coord,System.UInt32)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GoRogue#IReadOnlySpatialMap{T}#GetItems(System.Int32,System.Int32)">
            <summary>
            See <see cref="M:GoRogue.IReadOnlySpatialMap`1.GetItems(System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GetItems(System.Int32,System.Int32,System.UInt32)">
            <summary>
            See <see cref="M:GoRogue.IReadOnlyLayeredSpatialMap`1.GetItems(System.Int32,System.Int32,System.UInt32)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GetLayer(System.Int32)">
            <summary>
            Gets a read-only spatial map representing the layer given.
            </summary>
            <param name="layer">The layer to retrieve.</param>
            <returns>The IReadOnlySpatialMap that represents the given layer.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GetLayers(System.UInt32)">
            <summary>
            Returns read-only spatial maps that represent each layer included in the given layer
            mask. Defaults to all layers.
            </summary>
            <param name="layerMask">
            Layer mask indicating which layers to return. Defaults to all layers.
            </param>
            <returns>Read-only spatial maps representing each layer in the given layer mask.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GetPosition(`0)">
            <summary>
            See <see cref="M:GoRogue.IReadOnlySpatialMap`1.GetPosition(`0)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Move(`0,GoRogue.Coord)">
            <summary>
            Moves the given item to the given position, or returns false if the item cannot be moved.
            The move could fail if either the item given isn't in the spatial map, or if the layer that
            the item resides on is configured to allow only one item per location at any given time and
            there is already an item at the <paramref name="target"/>.
            </summary>
            <param name="item">Item to move.</param>
            <param name="target">Position to move the given item to.</param>
            <returns>True if the item was successfully moved, false if the move failed.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Move(`0,System.Int32,System.Int32)">
            <summary>
            Moves the given item to the given position, or returns false if the item cannot be moved.
            The move could fail if either the item given isn't in the spatial map, or if the layer that
            the item resides on is configured to allow only one item per location at any given time and
            there is already an item at the target position.
            </summary>
            <param name="item">Item to move.</param>
            <param name="targetX">X-value of position to move the given item to.</param>
            <param name="targetY">Y-value of position to move the given item to.</param>
            <returns>True if the item was successfully moved, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GoRogue#ISpatialMap{T}#Move(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Moves all items on all layers at the given position to the new position.
            </summary>
            <param name="current">Position to move items from.</param>
            <param name="target">Position to move items to</param>
            <returns>All items moved.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Move(GoRogue.Coord,GoRogue.Coord,System.UInt32)">
            <summary>
            Moves all items at the given position, that are on any layer specified by the given layer
            mask, to the new position. If no layer mask is specified, defaults to all layers.
            </summary>
            <param name="current">Position to move all items from.</param>
            <param name="target">Position to move all items to.</param>
            <param name="layerMask">
            Layer mask specifying which layers to search for items on. Defaults to all layers.
            </param>
            <returns>All items moved.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GoRogue#ISpatialMap{T}#Move(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Moves all items on all layers at the given position to the new position.
            </summary>
            <param name="currentX">X-value of the position to move items from.</param>
            <param name="currentY">Y-value of the position to move items from.</param>
            <param name="targetX">X-value of the position to move items to.</param>
            <param name="targetY">Y-value of the position to move itesm from.</param>
            <returns>All items moved.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Move(System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)">
            <summary>
            Moves all items at the given position, that are on any layer specified by the given layer
            mask, to the new position. If no layer mask is specified, defaults to all layers.
            </summary>
            <param name="currentX">X-value of the position to move items from.</param>
            <param name="currentY">Y-value of the position to move items from.</param>
            <param name="targetX">X-value of the position to move items to.</param>
            <param name="targetY">Y-value of the position to move itesm from.</param>
            <param name="layerMask">
            Layer mask specifying which layers to search for items on. Defaults to all layers.
            </param>
            <returns>All items moved.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Remove(`0)">
            <summary>
            See <see cref="M:GoRogue.ISpatialMap`1.Remove(`0)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GoRogue#ISpatialMap{T}#Remove(GoRogue.Coord)">
            <summary>
            See <see cref="M:GoRogue.ISpatialMap`1.Remove(GoRogue.Coord)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Remove(GoRogue.Coord,System.UInt32)">
            <summary>
            Removes all items at the specified location that are on any layer included in the given
            layer mask from the spatial map. Returns any items that were removed. Defaults to searching
            for items on all layers.
            </summary>
            <param name="position">Position to remove items from.</param>
            <param name="layerMask">
            The layer mask indicating which layers to search for items. Defaults to all layers.
            </param>
            <returns>Any items that were removed, or nothing if no items were removed.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GoRogue#ISpatialMap{T}#Remove(System.Int32,System.Int32)">
            <summary>
            See <see cref="M:GoRogue.ISpatialMap`1.Remove(System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Remove(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Removes all items at the specified location that are on any layer included in the given
            layer mask from the spatial map. Returns any items that were removed. Defaults to searching
            for items on all layers.
            </summary>
            <param name="x">X-value of the position to remove items from.</param>
            <param name="y">Y-value of the position to remove items from.</param>
            <param name="layerMask">
            The layer mask indicating which layers to search for items. Defaults to all layers.
            </param>
            <returns>Any items that were removed, or nothing if no items were removed.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.ToString">
            <summary>
            Returns a string representation of each layer in the spatial map.
            </summary>
            <returns>A string representing each layer of the LayeredSpatialMap</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.ToString(System.Func{`0,System.String})">
            <summary>
            Returns a string representation of each item in the spatial map, with elements
            displayed in the specified way.
            </summary>
            <param name="elementStringifier">A function that takes an element of type T and produces the string that should represent it in the output.</param>
            <returns>A string representing each layer in the spatial map, with each element displayed in the specified way.</returns>
        </member>
        <member name="T:GoRogue.LayeredSpatialMap`1">
            <summary>
            <see cref="T:GoRogue.ISpatialMap`1"/> implementation that can be used to efficiently represent multiple
            "layers" of objects, with each layer represented as an <see cref="T:GoRogue.ISpatialMap`1"/> instance.
            It provides the regular spatial map functionality, as well as adds layer masking functionality
            that allow functions to operate on specific layers only. 
            </summary>
            <remarks>
            See the <see cref="T:GoRogue.ISpatialMap`1"/> for documentation on the practical purpose of spatial
            maps.
            
            The objects stored in a LayeredSpatialMap must be reference types and implement both <see cref="T:GoRogue.IHasID"/>
            and <see cref="T:GoRogue.IHasLayer"/>.  Each object in a spatial map is presumed to have a "layer", which is assumed
            to remain constant once the item is added to the layer mask.
            </remarks>
            <typeparam name="T">
            Type of items stored in the layers. Type T must implement <see cref="T:GoRogue.IHasID"/> and <see cref="T:GoRogue.IHasLayer"/>,
            must be a reference type, and its <see cref="P:GoRogue.IHasLayer.Layer"/> value MUST NOT change while the item is in the
            spatial map.
            </typeparam>
        </member>
        <member name="M:GoRogue.LayeredSpatialMap`1.#ctor(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Constructor.
            </summary>
            <remarks>
            This class allows you to specify the starting index for layers in order to make it easy to
            combine with other structures in a map which may represent other layers. For example, if a
            <paramref name="startingLayer"/> of 0 is specified, layers in the spatial map will have numbers
            in range[0, numberOfLayers - 1]. If 1 is specified, layers will have numbers in range [1-numberOfLayers],
            and anything to do with layer 0 will be ignored. For example, If a layer-mask that includes layers 0,
            2, and 3 is passed to a function, only layers 2 and 3 are considered (since they are the only ones that would
            be included in the spatial map.
            </remarks>
            <param name="numberOfLayers">Number of layers to include.</param>
            <param name="startingLayer">Index to use for the first layer.</param>
            <param name="layersSupportingMultipleItems">
            A layer mask indicating which layers should support multiple items residing at the same
            location on that layer. Defaults to no layers.  Generate this layer mask via <see cref="F:GoRogue.LayerMasker.DEFAULT"/>.
            </param>
        </member>
        <member name="T:GoRogue.Lines">
            <summary>
            Provides implementations of various (line-drawing) algorithms which are useful for
            for generating points closest to a line between two points on a grid.
            </summary>
        </member>
        <member name="T:GoRogue.Lines.Algorithm">
            <summary>
            Various supported line-drawing algorithms.
            </summary>
        </member>
        <member name="F:GoRogue.Lines.Algorithm.BRESENHAM">
            <summary>
            Bresenham's line algorithm.
            </summary>
        </member>
        <member name="F:GoRogue.Lines.Algorithm.BRESENHAM_ORDERED">
            <summary>
            Bresenham's line algorithm, with the points guaranteed to be in start to finish
            order. This may be significantly slower than <see cref="F:GoRogue.Lines.Algorithm.BRESENHAM"/>, so if you really
            need ordering, consider<see cref="F:GoRogue.Lines.Algorithm.DDA"/> instead, as it is both faster than Bresenham's
            and implicitly ordered.
            </summary>
        </member>
        <member name="F:GoRogue.Lines.Algorithm.DDA">
            <summary>
            DDA line algorithm -- effectively an optimized algorithm for producing Brensham-like
            lines. There may be slight differences in appearance when compared to lines created
            with Bresenham's, however this algorithm may also be measurably faster. Based on the
            algorithm <a href="https://hbfs.wordpress.com/2009/07/28/faster-than-bresenhams-algorithm/">here</a>,
            , as well as the Java library Squidlib's implementation.  Points are guaranteed to be in order from
            start to finish.
            </summary>
        </member>
        <member name="F:GoRogue.Lines.Algorithm.ORTHO">
            <summary>
            Line algorithm that takes only orthoganal steps (each grid location on the line
            returned is within one cardinal direction of the previous one). Potentially useful
            for LOS in games that use MANHATTAN distance. Based on the algorithm
            <a href="http://www.redblobgames.com/grids/line-drawing.html#stepping">here</a>.
            </summary>
        </member>
        <member name="M:GoRogue.Lines.Get(GoRogue.Coord,GoRogue.Coord,GoRogue.Lines.Algorithm)">
            <summary>
            Returns an IEnumerable of every point, in order, closest to a line between the two points
            specified, using the line drawing algorithm given. The start and end points will be included.
            </summary>
            <param name="start">The start point of the line.</param>
            <param name="end">The end point of the line.</param>
            <param name="type">The line-drawing algorithm to use to generate the line.</param>
            <returns>
            An IEnumerable of every point, in order, closest to a line between the two points
            specified (according to the algorithm given).
            </returns>
        </member>
        <member name="M:GoRogue.Lines.Get(System.Int32,System.Int32,System.Int32,System.Int32,GoRogue.Lines.Algorithm)">
            <summary>
            Returns an IEnumerable of every point, in order, closest to a line between the two points
            specified, using the line drawing algorithm given. The start and end points will be included.
            </summary>
            <param name="startX">X-coordinate of the starting point of the line.</param>
            <param name="startY">Y-coordinate of the starting point of the line.</param>
            <param name="endX">X-coordinate of the ending point of the line.</param>
            ///
            <param name="endY">Y-coordinate of the ending point of the line.</param>
            <param name="type">The line-drawing algorithm to use to generate the line.</param>
            <returns>
            An IEnumerable of every point, in order, closest to a line between the two points
            specified (according to the algorithm given).
            </returns>
        </member>
        <member name="T:GoRogue.MapGeneration.Connectors.CenterBoundsConnectionPointSelector">
            <summary>
            Selects the center points of the bounding boxes of each map area. On concave map areas,
            because the center point of the bounding box is not actually guaranteed to be among the
            MapArea's walkable tiles, connecting these two points is not guaranteed to actually connect
            the entirety of the two areas.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.CenterBoundsConnectionPointSelector.SelectConnectionPoints(GoRogue.MapGeneration.IReadOnlyMapArea,GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Selects and returns a the center point of the bounding rectangle for each map area's
            positions list.
            </summary>
            <param name="area1">First map area to connect.</param>
            <param name="area2">First map area to connect.</param>
            <returns>A tuple representing the center of the bounding box of each map area.</returns>
        </member>
        <member name="T:GoRogue.MapGeneration.Connectors.ClosestConnectionPointSelector">
            <summary>
            Point selector that selects the two points from the <see cref="T:GoRogue.MapGeneration.MapArea"/> instances that are closest to each other,
            according to the given distance calculation.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.Connectors.ClosestConnectionPointSelector.DistanceCalculation">
            <summary>
            <see cref="T:GoRogue.Distance"/> calculation to use to determine closeness.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.ClosestConnectionPointSelector.#ctor(GoRogue.Distance)">
            <summary>
            Constructor.
            </summary>
            <param name="distanceCalculation"><see cref="T:GoRogue.Distance"/> calculation to use to determine closeness.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.ClosestConnectionPointSelector.SelectConnectionPoints(GoRogue.MapGeneration.IReadOnlyMapArea,GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Determines the two points in the given map areas that are closest to each other, and returns
            them as a tuple of two positions.  The first position is the position in <paramref name="area1"/>to use,
            and the second is the position in <paramref name="area2"/> to use.
            </summary>
            <remarks>
            This algorithm can be relatively time-complex -- O(m*n) where m is the number of coordinates in area1, and n
            is the number of coordintes in area2.
            </remarks>
            <param name="area1">First <see cref="T:GoRogue.MapGeneration.MapArea"/> to connect.</param>
            <param name="area2">Second <see cref="T:GoRogue.MapGeneration.MapArea"/> to connect.</param>
            <returns>
            A tuple containing the coordinates from each <see cref="T:GoRogue.MapGeneration.MapArea"/> to connect -- the first item in the
            tuple is the position in <paramref name="area1"/>, the second is the position in <paramref name="area2"/>.
            </returns>
        </member>
        <member name="T:GoRogue.MapGeneration.Connectors.ClosestMapAreaConnector">
            <summary>
            Implements a connection algorithm that connects all unique map areas in the given map by
            connecting each area with the one closest to it, based on closeness of the area's center points.
            </summary>
            <remarks>
            The algorithm functions by first finding all unique areas in the map given by using
            <see cref="M:GoRogue.MapGeneration.MapAreaFinder.MapAreas"/>. Then, we iterate through each area, find the closest area that is not
            already conencted to the current area.  Distance between to areas is measured as the distance between the
            center point of the bounding boxes of those areas. Points to connect two areas, as well as method used to create
            a tunnel between those two points, are selected via specified parameters.
            </remarks>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.ClosestMapAreaConnector.Connect(GoRogue.MapViews.ISettableMapView{System.Boolean},GoRogue.Distance,GoRogue.MapGeneration.Connectors.IAreaConnectionPointSelector,GoRogue.MapGeneration.Connectors.ITunnelCreator)">
            <summary>
            Connects the given map using the algorithm described in the class description.  Map areas
            are automatically determined using a <see cref="T:GoRogue.MapGeneration.MapAreaFinder"/>.
            </summary>
            <param name="map">The map to connect.</param>
            <param name="distanceCalc">The distance calculation that defines distance/neighbors.</param>
            <param name="areaConnector">
            The area connection strategy to use. Not all methods function on maps with concave areas
            -- see respective class documentation for details.
            </param>
            <param name="tunnelCreator">
            The tunnel creation strategy to use. If null is specified, <see cref="T:GoRogue.MapGeneration.Connectors.DirectLineTunnelCreator"/> with
            the distance calculation specified is used.
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.ClosestMapAreaConnector.Connect(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Collections.Generic.IReadOnlyList{GoRogue.MapGeneration.MapArea},GoRogue.Distance,GoRogue.MapGeneration.Connectors.IAreaConnectionPointSelector,GoRogue.MapGeneration.Connectors.ITunnelCreator)">
            <summary>
            Connects the map areas given on the given map using the algorithm described in the class description.
            </summary>
            <param name="map">The map to connect.</param>
            <param name="mapAreas">The map areas to connect on the given map.</param>
            <param name="distanceCalc">The distance calculation that defines distance/neighbors.</param>
            <param name="areaConnector">
            The area connection strategy to use. Not all methods function on maps with concave areas
            -- see respective class documentation for details.
            </param>
            ///
            <param name="tunnelCreator">
            The tunnel creation strategy to use. If null is specified, <see cref="T:GoRogue.MapGeneration.Connectors.DirectLineTunnelCreator"/> with
            the distance calculation specified is used.
            </param>
        </member>
        <member name="T:GoRogue.MapGeneration.Connectors.DeadEndTrimmer">
            <summary>
            Implements an algorithm that will prune small dead-end locations (locations surrounded by 3 walls), from a map/list of map areas.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.DeadEndTrimmer.Trim(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Int32,System.Int32,Troschuetz.Random.IGenerator)">
            <summary>
            Trims current small dead-end paths from the given map.
            </summary>
            <param name="map">Map to remove-dead-end paths from.</param>
            <param name="saveDeadEndChance">The chance out of 100 that a given dead end is left alone. Defaults to 0.</param>
            <param name="maxTrimIterations">Maximum number of passes to make looking for dead ends.  Defaults to infinity.</param>
            <param name="rng">Rng to use.  Defaults to <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.DeadEndTrimmer.Trim(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Collections.Generic.IEnumerable{GoRogue.MapGeneration.MapArea},System.Int32,System.Int32,Troschuetz.Random.IGenerator)">
            <summary>
            Trims current small dead-end paths from the given list of map areas, and removes them from the given map.
            </summary>
            <param name="map">Map to remove-dead-end paths from.</param>
            <param name="areas">Map areas to check for dead ends.  Dead ends not contained as one of these map areas will be ignored.</param>
            <param name="saveDeadEndChance">The chance out of 100 that a given dead end is left alone. Defaults to 0.</param>
            <param name="maxTrimIterations">Maximum number of passes to make looking for dead ends.  Defaults to infinity.</param>
            <param name="rng">Rng to use.  Defaults to <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>.</param>
        </member>
        <member name="T:GoRogue.MapGeneration.Connectors.DirectLineTunnelCreator">
            <summary>
            Implements a tunnel creation algorithm that sets as walkable a direct line between the two
            points. In the case that <see cref="F:GoRogue.Distance.MANHATTAN"/> is being used, the line is calculated via the
            <see cref="F:GoRogue.Lines.Algorithm.ORTHO"/> algorithm.  Otherwise, the line is calculated using
            <see cref="F:GoRogue.Lines.Algorithm.BRESENHAM"/>.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.DirectLineTunnelCreator.#ctor(GoRogue.AdjacencyRule,System.Boolean)">
            <summary>
            Constructor. Takes the distance calculation to use, which determines whether <see cref="F:GoRogue.Lines.Algorithm.ORTHO"/>
            or <see cref="F:GoRogue.Lines.Algorithm.BRESENHAM"/> is used to create the tunnel.
            </summary>
            <param name="adjacencyRule">
            Method of adjacency to respect when creating tunnels. Cannot be diagonal.
            </param>
            <param name="doubleWideVertical">Whether or not to create vertical tunnels as 2-wide.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.DirectLineTunnelCreator.CreateTunnel(GoRogue.MapViews.ISettableMapView{System.Boolean},GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Implements the algorithm, creating the tunnel as specified in the class description.
            </summary>
            <param name="map">The map to create the tunnel on.</param>
            <param name="start">Start coordinate of the tunnel.</param>
            <param name="end">End coordinate of the tunnel.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.DirectLineTunnelCreator.CreateTunnel(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Implements the algorithm, creating the tunnel as specified in the class description.
            </summary>
            <param name="map">The map to create the tunnel on.</param>
            <param name="startX">X-value of the start position of the tunnel.</param>
            <param name="startY">Y-value of the start position of the tunnel.</param>
            <param name="endX">X-value of the end position of the tunnel.</param>
            <param name="endY">Y-value of the end position of the tunnel.</param>
        </member>
        <member name="T:GoRogue.MapGeneration.Connectors.HorizontalVerticalTunnelCreator">
            <summary>
            Implements a tunnel creation algorithm that creates a tunnel that performs all needed
            vertical movement before horizontal movement, or vice versa (depending on rng).
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.HorizontalVerticalTunnelCreator.#ctor(Troschuetz.Random.IGenerator)">
            <summary>
            Constructor. Takes rng to use -- if null is specified, the <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/> is used.
            </summary>
            <param name="rng">Rng to use -- if null is specified, <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/> is used.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.HorizontalVerticalTunnelCreator.CreateTunnel(GoRogue.MapViews.ISettableMapView{System.Boolean},GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Implemnets the algorithm, creating the tunnel as specified in the class description.
            </summary>
            <param name="map">The map to create the tunnel on.</param>
            <param name="start">Start coordinate of the tunnel.</param>
            <param name="end">End coordinate of the tunnel.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.HorizontalVerticalTunnelCreator.CreateTunnel(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Implements the algorithm, creating the tunnel as specified in the class description.
            </summary>
            <param name="map">The map to create the tunnel on.</param>
            <param name="startX">X-value of the start position of the tunnel.</param>
            <param name="startY">Y-value of the start position of the tunnel.</param>
            <param name="endX">X-value of the end position of the tunnel.</param>
            <param name="endY">Y-value of the end position of the tunnel.</param>
        </member>
        <member name="T:GoRogue.MapGeneration.Connectors.IAreaConnectionPointSelector">
            <summary>
            Interface for implementing an algorithm for selecting the positions to connect in order to
            connect two given map areas.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.IAreaConnectionPointSelector.SelectConnectionPoints(GoRogue.MapGeneration.IReadOnlyMapArea,GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Implements the algorithm. Returns a tuple of two positions -- the first position is the
            position in <paramref name="area1"/> to use, the second position is the position in
            <paramref name="area2"/> to use.
            </summary>
            <param name="area1">First <see cref="T:GoRogue.MapGeneration.MapArea"/> to connect.</param>
            <param name="area2">Second <see cref="T:GoRogue.MapGeneration.MapArea"/> to connect.</param>
            <returns>
            A tuple containing the coordinates from each <see cref="T:GoRogue.MapGeneration.MapArea"/> to connect -- the first
            item in the tuple is the position in area1, the second is the position in area2.
            </returns>
        </member>
        <member name="T:GoRogue.MapGeneration.Connectors.ITunnelCreator">
            <summary>
            Interface for implementing an algorithm for creating a tunnel between two positions on a
            walkability map.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.ITunnelCreator.CreateTunnel(GoRogue.MapViews.ISettableMapView{System.Boolean},GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Implements the algorithm, creating the tunnel between the two points (ensuring there is a
            path of positions set to true between those two points).
            </summary>
            <param name="map">Map to create the tunnel on.</param>
            <param name="start">Start position to connect.</param>
            <param name="end">End position to connect.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.ITunnelCreator.CreateTunnel(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Implements the algorithm, creating the tunnel between the two points (ensuring there is a
            path of positions set to true between those two points.
            </summary>
            <param name="map">Map to create the tunnel on.</param>
            <param name="startX">X-value of the start position to connect.</param>
            <param name="startY">Y-value of the start position to connect.</param>
            <param name="endX">X-value of the end position to connect.</param>
            <param name="endY">Y-value of the end position to connect.</param>
        </member>
        <member name="T:GoRogue.MapGeneration.Connectors.OrderedMapAreaConnector">
            <summary>
            Same as <see cref="T:GoRogue.MapGeneration.Connectors.ClosestMapAreaConnector"/>, but connects random rooms instead of determining the closest
            one, or connects rooms in the order specified if you give it a list of areas.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.OrderedMapAreaConnector.Connect(GoRogue.MapViews.ISettableMapView{System.Boolean},GoRogue.AdjacencyRule,GoRogue.MapGeneration.Connectors.IAreaConnectionPointSelector,GoRogue.MapGeneration.Connectors.ITunnelCreator,Troschuetz.Random.IGenerator,System.Boolean)">
            <summary>
            Connects the areas by determining all unique areas on the map given using a <see cref="T:GoRogue.MapGeneration.MapAreaFinder"/>,
            and then, if <paramref name="randomizeOrder"/> is true, performing a Fisher Yates shuffle of that
            list of areas found. It then simply connects areas adjacent to each other in that list,
            using the methods specified to determine points within two areas to connect, and how to
            create the tunnel between the two points.
            </summary>
            <param name="map">The map to connect.</param>
            <param name="adjacencyRule">
            Method of adjacency to respect when determining map areas. Cannot be diagonal.
            </param>
            <param name="areaConnector">
            The method to use to determine the points from two areas to make a tunnel between, in
            order to connect those two areas. If null is specified, a <see cref="T:GoRogue.MapGeneration.Connectors.RandomConnectionPointSelector"/>
            is used, that uses the RNG passed into this function.
            </param>
            <param name="tunnelCreator">
            The tunnel creation strategy to use. If null is specified,
            <see cref="T:GoRogue.MapGeneration.Connectors.HorizontalVerticalTunnelCreator"/> that utilizes the RNG passed into this function is used.
            </param>
            <param name="rng">The rng to use. If null is specified, the default rng is assumed.</param>
            <param name="randomizeOrder">
            Whether or not to randomize which room is connected to which -- if this is set to false,
            they will be conencted in the exact order they are returned from the <see cref="T:GoRogue.MapGeneration.MapAreaFinder"/>.
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.OrderedMapAreaConnector.Connect(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Collections.Generic.IReadOnlyList{GoRogue.MapGeneration.IReadOnlyMapArea},GoRogue.MapGeneration.Connectors.IAreaConnectionPointSelector,GoRogue.MapGeneration.Connectors.ITunnelCreator)">
            <summary>
            Connects the areas by simply connecting areas adjacent to each other in the passed in
            list of areas, using the methods specified to determine points within two areas to
            connect, and how to create the tunnel between the two points.
            </summary>
            <param name="map">The map to connect.</param>
            <param name="mapAreas">
            The list of map areas to connect, in the order they should be connected.
            </param>
            <param name="areaConnector">
            The method to use to determine the points from two areas to make a tunnel between, in
            order to connect those two areas. If null is specified, a <see cref="T:GoRogue.MapGeneration.Connectors.RandomConnectionPointSelector"/>
            is used, that uses the default RNG.
            </param>
            <param name="tunnelCreator">
            The tunnel creation strategy to use. If null is specified, a <see cref="T:GoRogue.MapGeneration.Connectors.HorizontalVerticalTunnelCreator"/>
            that utilizes the default RNG is used.
            </param>
        </member>
        <member name="T:GoRogue.MapGeneration.Connectors.RandomConnectionPointSelector">
            <summary>
            Implements a the selection algorithm that simply selects random points from the given
            areas' positions lists, using the RNG specified, or the default rng if null is given.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.RandomConnectionPointSelector.#ctor(Troschuetz.Random.IGenerator)">
            <summary>
            Constructor. Specifies the RNG to use, or null if the default RNG should be used.
            </summary>
            <param name="rng">The RNG to use, or null if the default RNG should be used.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.RandomConnectionPointSelector.SelectConnectionPoints(GoRogue.MapGeneration.IReadOnlyMapArea,GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Selects and returns a random point from each map area's positions list.
            </summary>
            <param name="area1">First map area to connect.</param>
            <param name="area2">Second area to connect</param>
            <returns>A tuple containing the selected positions.</returns>
        </member>
        <member name="T:GoRogue.MapGeneration.Connectors.RoomDoorConnector">
            <summary>
            Opens up room walls to connect tunnels that are placed near rooms.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.RoomDoorConnector.ConnectRooms(GoRogue.MapViews.ArrayMap{System.Boolean},System.Collections.Generic.IEnumerable{GoRogue.Rectangle},System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Detects tunnels near the specified rooms and tries to open a wall spot to represent a door.
            </summary>
            <param name="map">The map to modify.</param>
            <param name="rooms">A collection of rooms to process.</param>
            <param name="minSidesToConnect">Minimum sides of the room to process. Defaults to 1.</param>
            <param name="maxSidesToConnect">Maximum sides of the room to process. Defaults to 4.</param>
            <param name="cancelSideConnectionSelectChance">
            A chance out of 100 to cancel selecting sides to process (per room). Defaults to 50.
            </param>
            <param name="cancelConnectionPlacementChance">
            A chance out of 100 to cancel placing a door on a side after one has been placed (per
            room). Defaults to 70.
            </param>
            <param name="cancelConnectionPlacementChanceIncrease">
            Increase the <paramref name="cancelConnectionPlacementChance"/> value by this amount each
            time a door is placed (per room). Defaults to 10.
            </param>
            <returns>A list of rooms and the connections placed.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.RoomDoorConnector.ConnectRooms(GoRogue.MapViews.ArrayMap{System.Boolean},Troschuetz.Random.IGenerator,System.Collections.Generic.IEnumerable{GoRogue.Rectangle},System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Detects tunnels near the specified rooms and tries to open a wall spot to represent a door.
            </summary>
            <param name="map">The map to modify.</param>
            <param name="rng">The RNG to use.</param>
            <param name="rooms">A collection of rooms to process.</param>
            <param name="minSidesToConnect">Minimum sides of the room to process. Defaults to 1.</param>
            <param name="maxSidesToConnect">Maximum sides of the room to process. Defaults to 4.</param>
            <param name="cancelSideConnectionSelectChance">
            A chance out of 100 to cancel selecting sides to process (per room). Defaults to 50.
            </param>
            <param name="cancelConnectionPlacementChance">
            A chance out of 100 to cancel placing a door on a side after one has been placed (per
            room). Defaults to 70.
            </param>
            <param name="cancelConnectionPlacementChanceIncrease">
            Increase the <paramref name="cancelConnectionPlacementChance"/> value by this amount each
            time a door is placed (per room). Defaults to 10.
            </param>
            <returns>A list of rooms and the connections placed.</returns>
        </member>
        <member name="T:GoRogue.MapGeneration.Generators.BasicRoomsGenerator">
            <summary>
            Carves out non-overlapping rooms in a map using a basic process of generating a room, and
            trying to place that room without intersecting another. Generated rooms will not overlap with
            each other or existing open areas on the given map. Generated rooms will not be connected --
            for automatic connection of rooms generated by this algorithm, see
            <see cref="M:GoRogue.MapGeneration.QuickGenerators.GenerateRandomRoomsMap(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32)"/>
            and overloads.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Generators.BasicRoomsGenerator.Generate(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates rooms and adds them to the given map. After this function has been completed,
            room floor tiles will have a value of true in the <paramref name="map"/> given. The value at
            wall locations will not be modified from the state in which they were passed in.
            </summary>
            <remarks>
            It is guaranteed that the "set" function of the <paramref name="map"/> passed in will only be
            called once per tile at maximum.
            </remarks>
            <param name="map">The map to set values to.</param>
            <param name="maxRooms">The maximum number of rooms to attempt to place on the map.</param>
            <param name="roomMinSize">The minimum size in width and height of each room.</param>
            <param name="roomMaxSize">The maximum size in width and height of each room.</param>
            <param name="attemptsPerRoom">
            The maximum number of times the position of a room will be generated to try to position
            it properly (eg. without overlapping with other rooms), before simply discarding the room.
            </param>
            <returns>A collection of rectangles representing the interior of each generated room.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.Generators.BasicRoomsGenerator.Generate(GoRogue.MapViews.ISettableMapView{System.Boolean},Troschuetz.Random.IGenerator,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates rooms and adds them to the given map. After this function has been completed,
            room floor tiles will have a value of true in the <paramref name="map"/> given. The value at
            wall locations will not be modified from the state in which they were passed in.
            </summary>
            <remarks>
            It is guaranteed that the "set" function of the <paramref name="map"/> passed in will only be
            called once per tile at maximum.
            </remarks>
            <param name="map">The map to set values to.</param>
            <param name="rng">
            The RNG to use to place rooms and determine room size. If null is specified, the default
            RNG is used.
            </param>
            <param name="maxRooms">The maximum number of rooms to attempt to place on the map.</param>
            <param name="roomMinSize">The minimum size in width and height of each room.</param>
            <param name="roomMaxSize">The maximum size in width and height of each room.</param>
            <param name="attemptsPerRoom">
            The maximum number of times the position of a room will be generated to try to position
            it properly (eg. without overlapping with other rooms), before simply discarding the room.
            </param>
            <returns>A collection of rectangles representing the interior of each generated room.</returns>
        </member>
        <member name="T:GoRogue.MapGeneration.Generators.CellularAutomataAreaGenerator">
            <summary>
            Implements a cellular automata genereation algorithm to add cave-like (unconnected) areas to
            a map. A connection algorithm would be needed to connect these areas. For automatic
            connection, see <see cref="M:GoRogue.MapGeneration.QuickGenerators.GenerateCellularAutomataMap(GoRogue.MapViews.ISettableMapView{System.Boolean},Troschuetz.Random.IGenerator,System.Int32,System.Int32,System.Int32)"/>.
            </summary>
            <remarks>
            Generates a map by randomly filling the map surface with floor or wall values (true and false
            respectively) based on a probability given, then iteratively smoothing it via the process
            outlined in the cited roguebasin article. After generate is called, the passed in map will
            have had a value of true set to all floor tiles, and a value of false set to all wall tiles.
            Based on the C# roguelike library RogueSharp's implementation, and the roguebasin article
            below:
            http://www.roguebasin.com/index.php?title=Cellular_Automata_Method_for_Generating_Random_Cave-Like_Levels.
            It is guaranteed that the "set" function of the map passed in will only be
            called once per tile.
            </remarks>
        </member>
        <member name="M:GoRogue.MapGeneration.Generators.CellularAutomataAreaGenerator.Generate(GoRogue.MapViews.ISettableMapView{System.Boolean},Troschuetz.Random.IGenerator,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates the areas. Floor tiles will be set to true in the provided map, and wall tiles
            will be set to false.
            </summary>
            <param name="map">The map to fill with values when generate is called.</param>
            <param name="rng">
            The RNG to use to initially fill the map. If null is specified, <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/> is used.
            </param>
            <param name="fillProbability">
            Represents the percent chance that a given cell will be a floor cell when the map is
            initially randomly filled. Recommended to be in range [40, 60] (40 is used in the
            roguebasin article).
            </param>
            <param name="totalIterations">
            Total number of times the cellular automata-based smoothing algorithm is executed.
            Recommended to be in range [2, 10] (7 is used on roguebasin article).
            </param>
            <param name="cutoffBigAreaFill">
            Total number of times the cellular automata smoothing variation that is more likely to
            result in "breaking up" large areas will be run before switching to the more standard
            nearest neighbors version. Recommended to be in range [2, 7] (4 is used in roguebasin article).
            </param>
        </member>
        <member name="T:GoRogue.MapGeneration.Generators.MazeGenerator">
            <summary>
            Generates a maze, and adds it to the given map.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Generators.MazeGenerator.Generate(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Int32)">
            <summary>
            Generates a maze in map using crawlers that walk the map carving tunnels.
            </summary>
            <param name="map">The map to modify.</param>
            <param name="crawlerChangeDirectionImprovement">
            Out of 100, how much to increase the chance of the crawler changing direction each step.
            Once it changes direction, the chance resets to 0 and increases by this amount. Defaults
            to 10.
            </param>
            <returns>A list of mazes that were generated.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.Generators.MazeGenerator.Generate(GoRogue.MapViews.ISettableMapView{System.Boolean},Troschuetz.Random.IGenerator,System.Int32)">
            <summary>
            Generates a maze in map using crawlers that walk the map carving tunnels.
            </summary>
            <param name="map">The map to modify.</param>
            <param name="rng">The RNG to use.</param>
            <param name="crawlerChangeDirectionImprovement">
            Out of 100, how much to increase the chance of the crawler changing direction each step.
            Once it changes direction, the chance resets to 0 and increases by this amount. Defaults
            to 10.
            </param>
            <returns>A list of mazes that were generated.</returns>
        </member>
        <member name="T:GoRogue.MapGeneration.Generators.RoomsGenerator">
            <summary>
            Carves out non-overlapping rooms in a map. Rooms generated will not overlap with themselves,
            or any existing open areas on the given map. Rooms will not be connected -- for automatic
            connection of rooms generated by this generator, see
            <see cref="M:GoRogue.MapGeneration.QuickGenerators.GenerateDungeonMazeMap(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/>
            and overloads.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Generators.RoomsGenerator.Generate(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Carves random rectangles out of the map, setting the interior of the room to true. Does
            not set the wall of the rooms to false.
            </summary>
            <param name="map">The map to modify.</param>
            <param name="minRooms">Minimum amount of rooms to generate.</param>
            <param name="maxRooms">Maximum amount of rooms to generate.</param>
            <param name="roomMinSize">The minimum size of the room. Forces an odd number.</param>
            <param name="roomMaxSize">The maximum size of the room. Forces an odd number.</param>
            <param name="roomSizeRatioX">
            The ratio of the room width to the height. Defaults to 1.0.
            </param>
            <param name="roomSizeRatioY">
            The ratio of the room height to the width. Defaults to 1.0.
            </param>
            <param name="maxCreationAttempts">
            The max times to re-generate a room that cannot be placed before giving up on placing
            that room. Defaults to 10.
            </param>
            <param name="maxPlacementAttempts">
            The max times to attempt to place a room in a map without intersection, before giving up
            and re-generating that room. Defaults to 10.
            </param>
            <returns>A collection of rectangles representing the interior of the rooms that were added to the map.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.Generators.RoomsGenerator.Generate(GoRogue.MapViews.ISettableMapView{System.Boolean},Troschuetz.Random.IGenerator,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Carves random rectangles out of the map, placing rooms at odd x and y positions, with odd width/height.
            Sets the interior of the room to true. Does not set the wall of the rooms to false.
            </summary>
            <param name="map">The map to modify.</param>
            <param name="rng">RNG to use.</param>
            <param name="minRooms">Minimum amount of rooms to generate.</param>
            <param name="maxRooms">Maximum amount of rooms to generate.</param>
            <param name="roomMinSize">The minimum size of the room. Forces an odd number.</param>
            <param name="roomMaxSize">The maximum size of the room. Forces an odd number.</param>
            <param name="roomSizeRatioX">
            The ratio of the room width to the height. Defaults to 1.0.
            </param>
            <param name="roomSizeRatioY">
            The ratio of the room height to the width. Defaults to 1.0.
            </param>
            <param name="maxCreationAttempts">
            The max times to re-generate a room that cannot be placed before giving up on placing
            that room. Defaults to 10.
            </param>
            <param name="maxPlacementAttempts">
            The max times to attempt to place a room in a map without intersection, before giving up
            and re-generating that room. Defaults to 10.
            </param>
            <returns>A collection of rectangles representing the interior of the rooms that were added to the map.</returns>
        </member>
        <member name="T:GoRogue.MapGeneration.IReadOnlyMapArea">
            <summary>
            Read-only interface for an arbitrarily-shaped area of the map.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.IReadOnlyMapArea.Bounds">
            <summary>
            Smallest possible rectangle that encompasses every position in the area.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.IReadOnlyMapArea.Count">
            <summary>
            Number of (unique) positions in the currently stored list of positions.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.IReadOnlyMapArea.Positions">
            <summary>
            List of all (unique) positions in the list.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.IReadOnlyMapArea.Contains(GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Returns whether or not the given map area is completely contained within the current one.
            </summary>
            <param name="area">Area to check.</param>
            <returns>
            True if the given area is completely contained within the current one, false otherwise.
            </returns>
        </member>
        <member name="M:GoRogue.MapGeneration.IReadOnlyMapArea.Contains(System.Int32,System.Int32)">
            <summary>
            Determines whether or not the given position is considered within the area or not.
            </summary>
            <param name="x">X-coordinate of the position to check.</param>
            <param name="y">Y-coordinate of the position to check.</param>
            <returns>True if the specified position is within the area, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.IReadOnlyMapArea.Contains(GoRogue.Coord)">
            <summary>
            Determines whether or not the given position is considered within the area or not.
            </summary>
            <param name="position">The position to check.</param>
            <returns>True if the specified position is within the area, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.IReadOnlyMapArea.Intersects(GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Returns whether or not the given map area intersects the current one. If you intend to
            determine/use the exact intersection based on this return value, it is best to instead
            call <see cref="M:GoRogue.MapGeneration.MapArea.GetIntersection(GoRogue.MapGeneration.IReadOnlyMapArea,GoRogue.MapGeneration.IReadOnlyMapArea)"/>, and check the number of positions in the result (0 if
            no intersection).
            </summary>
            <param name="area">The area to check.</param>
            <returns>True if the given area intersects the current one, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.IReadOnlyMapArea.RandomPosition(Troschuetz.Random.IGenerator)">
            <summary>
            Gets a random position from the area.
            </summary>
            <param name="rng">The rng to use. Defaults to <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>.</param>
            <returns>A random position from within the map area.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.IReadOnlyMapArea.RandomPosition(System.Func{GoRogue.Coord,System.Boolean},Troschuetz.Random.IGenerator)">
            <summary>
            Gets a random position from the map area for which the given selector returns true. Positions
            are repeatedly selected until a valid one is found.
            </summary>
            <param name="selector">
            A function that should return true for any coordinate that is a valid selection, and
            false otherwise.
            </param>
            <param name="rng">The rng to use. Defaults to <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>.</param>
            <returns>
            A random position from within the map area for which the selector given returns true.
            </returns>
        </member>
        <member name="T:GoRogue.MapGeneration.MapArea">
            <summary>
            Represents an arbitrarily-shaped area of a map. Stores and provides access to a list of each
            unique position considered connected.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.MapArea.Bounds">
            <summary>
            Smallest possible rectangle that encompasses every position in the area.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.MapArea.Count">
            <summary>
            Number of (unique) positions in the currently stored list.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.MapArea.Positions">
            <summary>
            List of all (unique) positions in the list.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.GetDifference(GoRogue.MapGeneration.IReadOnlyMapArea,GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Gets a MapArea containing all positions in <paramref name="area1"/>, minus those that are in
            <paramref name="area2"/>.
            </summary>
            <param name="area1">The first MapArea.</param>
            <param name="area2">The second MapArea.</param>
            <returns>A MapArea with exactly those positions in <paramref name="area1"/> that are NOT in
            <paramref name="area2"/>.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.GetIntersection(GoRogue.MapGeneration.IReadOnlyMapArea,GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Gets a MapArea containing exactly those positions contained in both of the given MapAreas.
            </summary>
            <param name="area1">First MapArea.</param>
            <param name="area2">Second MapArea.</param>
            <returns>A MapArea containing exactly those positions contained in both of the given MapAreas.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.GetUnion(GoRogue.MapGeneration.IReadOnlyMapArea,GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Gets a new MapArea containing every position in one or both given map areas.
            </summary>
            <param name="area1">First MapArea.</param>
            <param name="area2">Second MapArea.</param>
            <returns>A MapArea containing only those positions in one or both of the given MapAreas.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.op_Inequality(GoRogue.MapGeneration.MapArea,GoRogue.MapGeneration.MapArea)">
            <summary>
            Inequality comparison -- true if the two areas do NOT contain exactly the same points.
            </summary>
            <param name="lhs">First MapArea to compare.</param>
            <param name="rhs">Second MapArea to compare.</param>
            <returns>True if the MapAreas do NOT contain exactly the same points, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.op_Addition(GoRogue.MapGeneration.MapArea,GoRogue.Coord)">
            <summary>
            Creates a new MapArea with the Coords all shifted by the given vector.
            </summary>
            <param name="lhs">MapArea.</param>
            <param name="rhs">Coord (vector) to add.</param>
            <returns>
            A new MapArea with the positions all translated by the given amount in x and y directions.
            </returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.op_Equality(GoRogue.MapGeneration.MapArea,GoRogue.MapGeneration.MapArea)">
            <summary>
            Compares for equality. Returns true if the two MapAreas are the same reference, or if
            they contain exactly the same points.
            </summary>
            <param name="lhs">First MapArea to compare.</param>
            <param name="rhs">Second MapArea to compare.</param>
            <returns>True if the MapAreas contain exactly the same points, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Add(GoRogue.Coord)">
            <summary>
            Adds the given position to the list of points within the area if it is not already in the
            list, or does nothing otherwise.
            </summary>
            <remarks>
            Because the class uses a hash set internally to
            determine what points have already been added, this is an average case O(1) operation.
            </remarks>
            <param name="position">The position to add.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Add(System.Collections.Generic.IEnumerable{GoRogue.Coord})">
            <summary>
            Adds the given positions to the list of points within the area if they are not already in
            the list.
            </summary>
            <param name="positions">Positions to add to the list.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Add(GoRogue.Rectangle)">
            <summary>
            Adds all positions in the given rectangle to the area, if they are not already present.
            </summary>
            <param name="rectangle">Rectangle whose points to add.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Add(System.Int32,System.Int32)">
            <summary>
            Adds the given position to the list of points within the area if it is not already in the
            list, or does nothing otherwise.
            </summary>
            <remarks>
            Because the class uses a hash set internally to
            determine what points have already been added, this is an average case O(1) operation.
            </remarks>
            <param name="x">X-coordinate of the position to add.</param>
            <param name="y">Y-coordinate of the position to add.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Add(GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Adds all coordinates in the given map area to this one.
            </summary>
            <param name="area">Area containing positions to add.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Contains(GoRogue.Coord)">
            <summary>
            Determines whether or not the given position is considered within the area or not.
            </summary>
            <param name="position">The position to check.</param>
            <returns>True if the specified position is within the area, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Contains(System.Int32,System.Int32)">
            <summary>
            Determines whether or not the given position is considered within the area or not.
            </summary>
            <param name="x">X-coordinate of the position to check.</param>
            <param name="y">Y-coordinate of the position to check.</param>
            <returns>True if the specified position is within the area, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Contains(GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Returns whether or not the given area is completely contained within the current one.
            </summary>
            <param name="area">Area to check.</param>
            <returns>
            True if the given area is completely contained within the current one, false otherwise.
            </returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Equals(System.Object)">
            <summary>
            Same as operator==. Returns false of obj is not a MapArea.
            </summary>
            <param name="obj">Object to compare</param>
            <returns>
            True if the object given is a MapArea and is equal (contains the same points), false otherwise.
            </returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.GetHashCode">
            <summary>
            Returns hash of the underlying set.
            </summary>
            <returns>Hash code for the underlying set.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Intersects(GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Returns whether or not the given map area intersects the current one. If you intend to
            determine/use the exact intersection based on this return value, it is best to instead
            call the <see cref="M:GoRogue.MapGeneration.MapArea.GetIntersection(GoRogue.MapGeneration.IReadOnlyMapArea,GoRogue.MapGeneration.IReadOnlyMapArea)"/>, and
            check the number of positions in the result (0 if no intersection).
            </summary>
            <param name="area">The area to check.</param>
            <returns>True if the given map area intersects the current one, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.RandomPosition(Troschuetz.Random.IGenerator)">
            <summary>
            Gets a random position from the MapArea.
            </summary>
            <param name="rng">The rng to use. Defaults to <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>.</param>
            <returns>A random position from within the MapArea.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.RandomPosition(System.Func{GoRogue.Coord,System.Boolean},Troschuetz.Random.IGenerator)">
            <summary>
            Gets a random position from the MapArea for which the given selector returns true. Positions
            are repeatedly selected until a valid one is found.
            </summary>
            <param name="selector">
            A function that should return true for any coordinate that is a valid selection, and
            false otherwise.
            </param>
            <param name="rng">The rng to use. Defaults to <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>.</param>
            <returns>
            A random position from within the MapArea for which the selector given returns true.
            </returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Remove(GoRogue.Coord)">
            <summary>
            Removes the given position specified from the MapArea. Particularly when the Remove
            operation changes the bounds, this operation can be expensive, so if you must do multiple
            Remove operations, it would be best to group them into 1 using <see cref="M:GoRogue.MapGeneration.MapArea.Remove(System.Collections.Generic.IEnumerable{GoRogue.Coord})"/>.
            </summary>
            <param name="position">The position to remove.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Remove(System.Func{GoRogue.Coord,System.Boolean})">
            <summary>
            Removes positions for which the given predicate returns true from the MapArea.
            </summary>
            <param name="predicate">Predicate returning true for positions that should be removed.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Remove(System.Collections.Generic.HashSet{GoRogue.Coord})">
            <summary>
            Removes the given positions from the specified MapArea.
            </summary>
            <param name="positions">Positions to remove.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Remove(System.Collections.Generic.IEnumerable{GoRogue.Coord})">
            <summary>
            Removes the given positions from the specified MapArea.
            </summary>
            <param name="positions">Positions to remove.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Remove(System.Int32,System.Int32)">
            <summary>
            Removes the given position specified from the MapArea. Particularly when the Remove
            operation changes the bounds, this operation can be expensive, so if you must do multiple
            Remove operations, it would be best to group them into 1 using <see cref="M:GoRogue.MapGeneration.MapArea.Remove(System.Collections.Generic.IEnumerable{GoRogue.Coord})"/>.
            </summary>
            <param name="x">X-coordinate of the position to remove.</param>
            <param name="y">Y-coordinate of the position to remove.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Remove(GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Removes all positions in the given map area from this one.
            </summary>
            <param name="area">Area containing positions to remove.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Remove(GoRogue.Rectangle)">
            <summary>
            Removes all positions in the given Rectangle from this MapArea.
            </summary>
            <param name="rectangle">Rectangle containing positions to remove.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.ToString">
            <summary>
            Returns the string of each position in the MapArea, in a square-bracket enclosed list,
            eg. [(1, 2), (3, 4), (5, 6)].
            </summary>
            <returns>A string representation of those coordinates in the MapArea.</returns>
        </member>
        <member name="T:GoRogue.MapGeneration.MapAreaFinder">
            <summary>
            Class designed to calculate and produce a list of MapAreas representing each unique connected
            area of the map.
            </summary>
            <remarks>
            The class takes in an <see cref="T:GoRogue.MapViews.IMapView`1"/>, where a value of true for a given position indicates it
            should be part of a map area, and false indicates it should not be part of any map area. In a
            classic roguelike dungeon example, this might be a walkability map where floors return a
            value of true and walls a value of false.
            </remarks>
        </member>
        <member name="F:GoRogue.MapGeneration.MapAreaFinder.AdjacencyMethod">
            <summary>
            The method used for determining connectivity of the grid.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.MapAreaFinder.Map">
            <summary>
            Map view indicating which cells should be considered part of a map area and which should not.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.MapAreaFinder.#ctor(GoRogue.MapViews.IMapView{System.Boolean},GoRogue.AdjacencyRule)">
            <summary>
            Constructor.
            </summary>
            <param name="map">
            Map view indicating which cells should be considered part of a map area and which should not.
            </param>
            <param name="adjacencyMethod">The method used for determining connectivity of the grid.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapAreaFinder.MapAreasFor(GoRogue.MapViews.IMapView{System.Boolean},GoRogue.AdjacencyRule)">
            <summary>
            Convenience function that creates a MapAreaFinder and returns the result of that
            instances <see cref="M:GoRogue.MapGeneration.MapAreaFinder.MapAreas"/> function. Intended to be used for cases in which the area finder
            will never be re-used.
            </summary>
            <param name="map">
            Map view indicating which cells should be considered part of a map area and which should not.
            </param>
            <param name="adjacencyMethod">The method used for determining connectivity of the grid.</param>
            <returns>An IEnumerable of each (unique) map area.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapAreaFinder.MapAreas">
            <summary>
            Calculates the list of map areas, returning each unique map area.
            </summary>
            <returns>An IEnumerable of each (unique) map area.</returns>
        </member>
        <member name="T:GoRogue.MapGeneration.QuickGenerators">
            <summary>
            Collection of algorithms that put map generation pieces together, in ways that allow you to
            quickly and easily generate a given type of map in a single function call. The implementation
            of these functions may also be used as the basis for implementing more customized generation processes.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.QuickGenerators.GenerateCellularAutomataMap(GoRogue.MapViews.ISettableMapView{System.Boolean},Troschuetz.Random.IGenerator,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a cave-like map using the cellular automata algorithm here:
            http://www.roguebasin.com/index.php?title=Cellular_Automata_Method_for_Generating_Random_Cave-Like_Levels.
            See <see cref="T:GoRogue.MapGeneration.Generators.CellularAutomataAreaGenerator"/> for details. This algorithm is identical, except that
            it connects the areas automatically afterward.
            </summary>
            <param name="map"></param>
            <param name="rng"></param>
            <param name="fillProbability"></param>
            <param name="totalIterations"></param>
            <param name="cutoffBigAreaFill"></param>
            <returns>Collection of areas representing the areas of the map before they were connected.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.QuickGenerators.GenerateDungeonMazeMap(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a dungeon map based on the process outlined here: http://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/.
            </summary>
            <remarks>
            First, non-overlapping rooms are randomly placed using <see cref="T:GoRogue.MapGeneration.Generators.RoomsGenerator"/>. Then, a maze is
            generated into the remaining space using a <see cref="T:GoRogue.MapGeneration.Generators.MazeGenerator"/>. Those mazes are then connected.
            The rooms are connected to the maze using a <see cref="T:GoRogue.MapGeneration.Connectors.RoomDoorConnector"/>, and finally, small dead ends
            are trimmed out.
            </remarks>
            <param name="map">The map to set values to.</param>
            <param name="minRooms">Minimum amount of rooms to generate.</param>
            <param name="maxRooms">Maximum amount of rooms to generate.</param>
            <param name="roomMinSize">The minimum size of the room. Forces an odd number.</param>
            <param name="roomMaxSize">The maximum size of the room. Forces an odd number.</param>
            <param name="roomSizeRatioX">
            The ratio of the room width to the height. Defaults to 1.0.
            </param>
            <param name="roomSizeRatioY">
            The ratio of the room height to the width. Defaults to 1.0.
            </param>
            <param name="maxCreationAttempts">
            The max times to re-generate a room that cannot be placed before giving up on placing
            that room. Defaults to 10.
            </param>
            <param name="maxPlacementAttempts">
            The max times to attempt to place a room in a map without intersection, before giving up
            and re-generating that room. Defaults to 10.
            </param>
            <param name="crawlerChangeDirectionImprovement">
            Out of 100, how much to increase the chance of the crawler changing direction each step
            during maze generation. Once it changes direction, the chance resets to 0 and increases
            by this amount. Defaults to 10.
            </param>
            <param name="minSidesToConnect">Minimum sides of the room to process. Defaults to 1.</param>
            <param name="maxSidesToConnect">Maximum sides of the room to process. Defaults to 4.</param>
            <param name="cancelSideConnectionSelectChance">
            A chance out of 100 to cancel selecting sides to process (per room) while we are
            connecting them. Defaults to 50.
            </param>
            <param name="cancelConnectionPlacementChance">
            A chance out of 100 to cancel placing a door on a side after one has already been placed
            (per room) during connection.Defaults to 70.
            </param>
            <param name="cancelConnectionPlacementChanceIncrease">
            Increase the <paramref name="cancelConnectionPlacementChance"/> value by this amount each
            time a door is placed (per room) during the connection process. Defaults to 10.
            </param>
            <param name="saveDeadEndChance">
            After the maze generation finishes, the small dead ends will be trimmed out. This value
            indicates the chance out of 100 that the dead end remains. Defaults to 0.
            </param>
            <param name="maxTrimIterations">
            Maximum number of passes to make looking for dead ends when trimming.  Defaults to infinity.
            </param>
            <returns>A list of the interior of rooms generated, and the connections placed.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.QuickGenerators.GenerateDungeonMazeMap(GoRogue.MapViews.ISettableMapView{System.Boolean},Troschuetz.Random.IGenerator,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a dungeon map based on the process outlined here: http://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/.
            </summary>
            <remarks>
            First, non-overlapping rooms are randomly placed using <see cref="T:GoRogue.MapGeneration.Generators.RoomsGenerator"/>. Then, a maze is
            generated into the remaining space using a <see cref="T:GoRogue.MapGeneration.Generators.MazeGenerator"/>. Those mazes are then connected.
            The rooms are connected to the maze using a <see cref="T:GoRogue.MapGeneration.Connectors.RoomDoorConnector"/>, and finally, small dead ends
            are trimmed out.
            </remarks>
            <param name="map">The map to set values to.</param>
            <param name="rng">The RNG to use. If null is specified, the default RNG is used.</param>
            <param name="minRooms">Minimum amount of rooms to generate.</param>
            <param name="maxRooms">Maximum amount of rooms to generate.</param>
            <param name="roomMinSize">The minimum size of the room. Forces an odd number.</param>
            <param name="roomMaxSize">The maximum size of the room. Forces an odd number.</param>
            <param name="roomSizeRatioX">
            The ratio of the room width to the height. Defaults to 1.0.
            </param>
            <param name="roomSizeRatioY">
            The ratio of the room height to the width. Defaults to 1.0.
            </param>
            <param name="maxCreationAttempts">
            The max times to re-generate a room that cannot be placed before giving up on placing
            that room. Defaults to 10.
            </param>
            <param name="maxPlacementAttempts">
            The max times to attempt to place a room in a map without intersection, before giving up
            and re-generating that room. Defaults to 10.
            </param>
            <param name="crawlerChangeDirectionImprovement">
            Out of 100, how much to increase the chance of the crawler changing direction each step
            during maze generation. Once it changes direction, the chance resets to 0 and increases
            by this amount. Defaults to 10.
            </param>
            <param name="minSidesToConnect">Minimum sides of the room to process. Defaults to 1.</param>
            <param name="maxSidesToConnect">Maximum sides of the room to process. Defaults to 4.</param>
            <param name="cancelSideConnectionSelectChance">
            A chance out of 100 to cancel selecting sides to process (per room) while we are
            connecting them. Defaults to 50.
            </param>
            <param name="cancelConnectionPlacementChance">
            A chance out of 100 to cancel placing a door on a side after one has already been placed
            (per room) during connection.Defaults to 70.
            </param>
            <param name="cancelConnectionPlacementChanceIncrease">
            Increase the <paramref name="cancelConnectionPlacementChance"/> value by this amount each
            time a door is placed (per room) during the connection process. Defaults to 10.
            </param>
            <param name="saveDeadEndChance">
            After the connection finishes, the small dead ends will be trimmed out. This value
            indicates the chance out of 100 that a given dead end remains. Defaults to 0.
            </param>
            <param name="maxTrimIterations">Maximum number of passes to make looking for dead ends when trimming.  Defaults to infinity.</param>
            <returns>A list of the interior of rooms generated and the connections placed.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.QuickGenerators.GenerateRandomRoomsMap(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a map by attempting to randomly place the specified number of rooms, ranging in
            size between the specified min size and max size, trying the specified number of times to
            position a room without overlap before discarding the room entirely. The given map will
            have a value of false set to all non-passable tiles, and true set to all passable ones.
            </summary>
            <param name="map">The map to set values to.</param>
            <param name="maxRooms">The maximum number of rooms to attempt to place on the map.</param>
            <param name="roomMinSize">The minimum size in width and height of each room.</param>
            <param name="roomMaxSize">The maximum size in width and height of each room.</param>
            <param name="attemptsPerRoom">
            The maximum number of times the position of a room will be generated to try to position
            it properly (eg. without overlapping with other rooms), before simply discarding the
            room. Defaults to 10.
            </param>
            <returns>Rectangles representing the interior of each room generated.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.QuickGenerators.GenerateRandomRoomsMap(GoRogue.MapViews.ISettableMapView{System.Boolean},Troschuetz.Random.IGenerator,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a map by attempting to randomly place the specified number of rooms, ranging in
            size between the specified min size and max size, trying the specified number of times to
            position a room without overlap before discarding the room entirely. The given map will
            have a value of false set to all non-passable tiles, and true set to all passable ones.
            </summary>
            <param name="map">The map to set values to.</param>
            <param name="rng">
            The RNG to use to place rooms and determine room size. If null is specified, the default
            RNG is used.
            </param>
            <param name="maxRooms">The maximum number of rooms to attempt to place on the map.</param>
            <param name="roomMinSize">The minimum size in width and height of each room.</param>
            <param name="roomMaxSize">The maximum size in width and height of each room.</param>
            <param name="attemptsPerRoom">
            The maximum number of times the position of a room will be generated to try to position
            it properly (eg. without overlapping with other rooms), before simply discarding the
            room. Defaults to 10.
            </param>
            <returns>Rectangles representing the interor of each room generated.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.QuickGenerators.GenerateRectangleMap(GoRogue.MapViews.ISettableMapView{System.Boolean})">
            <summary>
            Generates a map, as a simple rectangular box, setting the map given as a "walkability
            map". Wall tiles (the edges of the map) will have a value of false set in the given map,
            whereas true will be set to all non-wall tiles.
            </summary>
            <param name="map">The map to set values to.</param>
        </member>
        <member name="T:GoRogue.MapViews.ArrayMap`1">
            <summary>
            Implementation of the <see cref="T:GoRogue.MapViews.ISettableMapView`1"/> interface that uses a
            1D array to store data.
            </summary>
            <remarks>
            An <see cref="T:GoRogue.MapViews.ArrayMap`1"/> can be implicitly converted to its underlying 1D array,
            which allows exposing that array to code that works with 1D arrays.  Modifications in the array
            appear in the map view as well.
            
            If you need a 2D array instead of 1D, then you should use <see cref="T:GoRogue.MapViews.ArrayMap2D`1"/> instead.
            </remarks>
            <typeparam name="T">The type of value being stored.</typeparam>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor. Takes width and height of array.
            </summary>
            <param name="width">Width of array.</param>
            <param name="height">Height of array.</param>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap`1.#ctor(`0[],System.Int32)">
            <summary>
            Constructor.  Takes an existing 1D array to use as the underlying array, and
            the width of the 2D area represented by that array.
            </summary>
            <param name="existingArray">Existing 1D array to use as the underlying array.</param>
            <param name="width">The width of the 2D area represented by <paramref name="existingArray"/>.</param>
        </member>
        <member name="P:GoRogue.MapViews.ArrayMap`1.Height">
            <summary>
            The height of the map.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.ArrayMap`1.Width">
            <summary>
            The width of the map.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.ArrayMap`1.Item(System.Int32)">
            <summary>
            Returns/sets the value associated with the given index in the underlying array.
            </summary>
            <param name="index1D">1D index of location to retrieve the "value" for.</param>
            <returns>The "value" associated with the given location.</returns>
        </member>
        <member name="P:GoRogue.MapViews.ArrayMap`1.Item(System.Int32,System.Int32)">
            <summary>
            Given an X and Y value, returns/sets the "value" associated with that location.
            </summary>
            <param name="x">X-value of location.</param>
            <param name="y">Y-value of location.</param>
            <returns>The "value" associated with that location.</returns>
        </member>
        <member name="P:GoRogue.MapViews.ArrayMap`1.Item(GoRogue.Coord)">
            <summary>
            Given a position, returns/sets the "value" associated with that location.
            </summary>
            <param name="pos">Location to get/set the value for.</param>
            <returns>The "value" associated with the provided location.</returns>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap`1.Clone">
            <summary>
            Performs deep copy of array map.
            </summary>
            <returns>The cloned ArrayMap.</returns>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap`1.op_Implicit(GoRogue.MapViews.ArrayMap{`0})~`0[]">
            <summary>
            Allows implicit conversion to 1D array.
            </summary>
            <param name="arrayMap">ArrayMap to convert.</param>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap`1.SetToDefault">
            <summary>
            Sets each element in the ArrayMap to the default for type T.
            </summary>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap`1.Equals(System.Object)">
            <summary>
            Compares the current ArrayMap to the object given.
            </summary>
            <param name="obj"/>
            <returns>True if the given object is an ArrayMap&lt;T&gt; with a reference to the same underlying array, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap`1.Equals(GoRogue.MapViews.ArrayMap{`0})">
            <summary>
            Compares the current ArrayMap to the one given.
            </summary>
            <param name="other"/>
            <returns>True if the given ArrayMap&lt;T&gt; with a reference to the same underlying array, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap`1.GetHashCode">
            <summary>
            Returns a hash-value for this object.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap`1.op_Equality(GoRogue.MapViews.ArrayMap{`0},GoRogue.MapViews.ArrayMap{`0})">
            <summary>
            Compares the two ArrayMap instances.
            </summary>
            <param name="lhs"/>
            <param name="rhs"/>
            <returns>True if the two given ArrayMap&lt;T&gt; instances have a reference to the same underlying array, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap`1.op_Inequality(GoRogue.MapViews.ArrayMap{`0},GoRogue.MapViews.ArrayMap{`0})">
            <summary>
            Compares the two ArrayMap instances.
            </summary>
            <param name="lhs"/>
            <param name="rhs"/>
            <returns>True if the two given ArrayMap&lt;T&gt; instances do NOT have a reference to the same underlying array, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap`1.ToString">
            <summary>
            Returns a string representation of the 2D array.
            </summary>
            <returns>A string representation of the 2D array.</returns>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap`1.ToString(System.Func{`0,System.String})">
            <summary>
            Returns a string representation of the map data, using <paramref name="elementStringifier"/>
            to determine what string represents which value.
            </summary>
            <remarks>
            This could be used, for example, on an ArrayMap of boolean values, to output '#' for
            false values, and '.' for true values.
            </remarks>
            <param name="elementStringifier">
            Function determining the string representation of each element.
            </param>
            <returns>A string representation of the map data.</returns>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap`1.ToString(System.Int32,System.Func{`0,System.String})">
            <summary>
            Prints the values in the ArrayMap, using the function specified to turn elements into
            strings, and using the "field length" specified.
            </summary>
            <remarks>
            Each element of type T will have spaces added to cause it to take up exactly
            <paramref name="fieldSize"/> characters, provided <paramref name="fieldSize"/> 
            is less than the length of the element's string represention.
            </remarks>
            <param name="fieldSize">
            The size of the field to give each value.  A positive-number
            right-aligns the text within the field, while a negative number left-aligns the text.
            </param>
            <param name="elementStringifier">
            Function to use to convert each element to a string. null defaults to the ToString
            function of type T.
            </param>
            <returns>A string representation of the ArrayMap.</returns>
        </member>
        <member name="T:GoRogue.MapViews.ArrayMap2D`1">
            <summary>
            Implementation of the <see cref="T:GoRogue.MapViews.ISettableMapView`1"/> interface that uses a
            2D array to store data.
            </summary>
            <remarks>
            An <see cref="T:GoRogue.MapViews.ArrayMap2D`1"/> can be implicitly converted to its underlying 2D array,
            which allows exposing that array to code that works with 2D arrays.  Modifications in the array
            appear in the map view as well.
            
            If you need a 1D array instead of 2D, then you should use <see cref="T:GoRogue.MapViews.ArrayMap`1"/> instead.
            </remarks>
            <typeparam name="T">The type of value being stored.</typeparam>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap2D`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor. Takes width and height of array.
            </summary>
            <param name="width">Width of array.</param>
            <param name="height">Height of array.</param>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap2D`1.#ctor(`0[0:,0:])">
            <summary>
            Constructor.  Takes an existing 2D array to use as the underlying data structure.
            </summary>
            <param name="existingArray">An existing 2D array to use as the data structure.</param>
        </member>
        <member name="P:GoRogue.MapViews.ArrayMap2D`1.Height">
            <summary>
            The height of the map.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.ArrayMap2D`1.Width">
            <summary>
            The width of the map.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.ArrayMap2D`1.Item(System.Int32)">
            <summary>
            Given an 1-dimensional index, returns/sets the value associated with the corresponding position
            in the underlying 2D array.
            </summary>
            <param name="index1D">1D index of location to retrieve the "value" for.</param>
            <returns>The "value" associated with the given location.</returns>
        </member>
        <member name="P:GoRogue.MapViews.ArrayMap2D`1.Item(System.Int32,System.Int32)">
            <summary>
            Given an X and Y value, returns/sets the "value" associated with that location.
            </summary>
            <param name="x">X-value of location.</param>
            <param name="y">Y-value of location.</param>
            <returns>The "value" associated with that location.</returns>
        </member>
        <member name="P:GoRogue.MapViews.ArrayMap2D`1.Item(GoRogue.Coord)">
            <summary>
            Given a position, returns/sets the "value" associated with that location.
            </summary>
            <param name="pos">Location to get/set the value for.</param>
            <returns>The "value" associated with the provided location.</returns>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap2D`1.Clone">
            <summary>
            Performs deep copy of array map.
            </summary>
            <returns>The cloned ArrayMap2D.</returns>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap2D`1.op_Implicit(GoRogue.MapViews.ArrayMap2D{`0})~`0[0:,0:]">
            <summary>
            Allows implicit conversion to 2D array.
            </summary>
            <param name="arrayMap">The ArrayMap2D to convert.</param>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap2D`1.SetToDefault">
            <summary>
            Sets each element in the ArrayMap to the default for type T.
            </summary>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap2D`1.Equals(System.Object)">
            <summary>
            Compares the current ArrayMap2D to the object given.
            </summary>
            <param name="obj"/>
            <returns>True if the given object is an ArrayMap2D&lt;T&gt; with a reference to the same underlying array, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap2D`1.Equals(GoRogue.MapViews.ArrayMap2D{`0})">
            <summary>
            Compares the current ArrayMap2D to the one given.
            </summary>
            <param name="other"/>
            <returns>True if the given ArrayMap2D&lt;T&gt; with a reference to the same underlying array, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap2D`1.GetHashCode">
            <summary>
            Returns a hash-value for this object.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap2D`1.op_Equality(GoRogue.MapViews.ArrayMap2D{`0},GoRogue.MapViews.ArrayMap2D{`0})">
            <summary>
            Compares the two ArrayMap2D instances.
            </summary>
            <param name="lhs"/>
            <param name="rhs"/>
            <returns>True if the two given ArrayMap2D&lt;T&gt; instances have a reference to the same underlying array, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap2D`1.op_Inequality(GoRogue.MapViews.ArrayMap2D{`0},GoRogue.MapViews.ArrayMap2D{`0})">
            <summary>
            Compares the two ArrayMap2D instances.
            </summary>
            <param name="lhs"/>
            <param name="rhs"/>
            <returns>True if the two given ArrayMap2D&lt;T&gt; instances do NOT have a reference to the same underlying array, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap2D`1.ToString">
            <summary>
            Returns a string representation of the 2D array.
            </summary>
            <returns>A string representation of the 2D array.</returns>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap2D`1.ToString(System.Func{`0,System.String})">
            <summary>
            Returns a string representation of the 2D array, using the <paramref name="elementStringifier"/>
            function given to determine what string represents which value.
            </summary>
            <remarks>
            This could be used, for example, on an ArrayMap2D of boolean values, to output '#' for
            false values, and '.' for true values.
            </remarks>
            <param name="elementStringifier">
            Function determining the string representation of each element.
            </param>
            <returns>A string representation of the 2D array.</returns>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap2D`1.ToString(System.Int32,System.Func{`0,System.String})">
            <summary>
            Prints the values in the ArrayMap2D, using the function specified to turn elements into
            strings, and using the "field length" specified.
            </summary>
            <remarks>
            Each element of type T will have spaces added to cause it to take up exactly
            <paramref name="fieldSize"/> characters, provided <paramref name="fieldSize"/> 
            is less than the length of the element's string represention.
            </remarks>
            <param name="fieldSize">
            The size of the field to give each value.  A positive-number
            right-aligns the text within the field, while a negative number left-aligns the text.
            </param>
            <param name="elementStringifier">
            Function to use to convert each element to a string. null defaults to the ToString
            function of type T.
            </param>
            <returns>A string representation of the ArrayMap2D.</returns>
        </member>
        <member name="T:GoRogue.MapViews.IMapView`1">
            <summary>
            Interface designed to act as a standardized input/output interpretation for algorithms.
            </summary>
            <remarks>
            Many roguelike/2D grid algorithms, such as pathfinding, FOV, and map generation, view a map
            as simply a 2D array of some type. In many games, however, the "value" associated with each
            2D position may be dependent upon many different things. For example, pathfinding, as input,
            often needs a "walkability map" -- in common terms, a 2D array of boolean values, where the
            boolean value at each position represents whether or not that tile is passable with respect to
            pathing. This boolean value might be determined by a number of things - terrain type, monster
            positions, etc. Thus, in practice, maintaining an actual 2D array of boolean values that such
            an algorithm could take as input can be difficult. IMapView solves this problem by
            providing an interface that all such algorithms can take as input -- pathfinding, for
            instance, would take an <see cref="T:GoRogue.MapViews.IMapView`1"/>; instance, rather than a 2D array of booleans. A
            user of that algorithm might create a class that implements the indexers below to check the
            terrain type, if there is a monster at the position, etc., and returns the correct value.
            This prevents the need to maintain an actual 2D array in code that pathfinding can use, if
            such an array does not fit with your game architecture. If you do want to store the data in an actual 2D
            array, IMapView works similarly -- the indexers can simply retrieve values in the array.
            
            Although manually implementing a custom IMapView may be necessary in some cases, GoRogue provides many
            implementations that cater to common cases -- for example, <see cref="T:GoRogue.MapViews.ArrayMap`1"/> is an implementation
            that uses an actual array, while <see cref="T:GoRogue.MapViews.LambdaMapView`1"/> is a built-in implementation that uses a
            function to retrieve values.
            </remarks>
            <typeparam name="T">The type of value being returned by the indexer functions.</typeparam>
        </member>
        <member name="P:GoRogue.MapViews.IMapView`1.Height">
            <summary>
            The height of the map being represented.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.IMapView`1.Width">
            <summary>
            The width of the map being represented.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.IMapView`1.Item(System.Int32,System.Int32)">
            <summary>
            Given an X and Y value, returns the "value" associated with that location.
            </summary>
            <param name="x">X-value of location.</param>
            <param name="y">Y-value of location.</param>
            <returns>The "value" associated with that location.</returns>
        </member>
        <member name="P:GoRogue.MapViews.IMapView`1.Item(GoRogue.Coord)">
            <summary>
            Given a position, returns the "value" associated with that location.
            </summary>
            <param name="pos">Location to retrieve the value for.</param>
            <returns>The "value" associated with the provided location.</returns>
        </member>
        <member name="P:GoRogue.MapViews.IMapView`1.Item(System.Int32)">
            <summary>
            Given an 1-dimensional index, returns the value associated with the corresponding position
            in the map view.
            </summary>
            <remarks>
            Typically, this may be implemented in terms of <see cref="P:GoRogue.MapViews.IMapView`1.Item(GoRogue.Coord)"/> by using
            <see cref="M:GoRogue.Coord.ToCoord(System.Int32,System.Int32)"/> to calculate the 2D position represented by that
            1D index, and passing that position to the <see cref="P:GoRogue.MapViews.IMapView`1.Item(GoRogue.Coord)"/> indexer to determine
            the value associated with the position.
            </remarks>
            <param name="index1D">1D index of location to retrieve the "value" for.</param>
            <returns>The "value" associated with the given location.</returns>
        </member>
        <member name="T:GoRogue.MapViews.IMapViewExtensions">
            <summary>
            Extensions for <see cref="T:GoRogue.MapViews.IMapView`1"/> implementaions that provide basic utility functions
            for them.
            </summary>
            <remarks>
            By providing these as extension methods, they effectively act as interface methods that have implementations
            already defined.  If these were regular interface implemenations, all interface implementers would be forced
            to implement them manually, which is undesireable as the implementation should clearly be the same and is based
            only on functions/properties defined in IMapView.
            </remarks>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.ApplyOverlay``1(GoRogue.MapViews.ISettableMapView{``0},GoRogue.MapViews.IMapView{``0})">
            <summary>
            Sets all the values of the current map to be equal to the corresponding values from
            the map you pass in.
            </summary>
            <typeparam name="T"/>
            <param name="self"/>
            <param name="overlay">
            The data apply to the map. Must have identical dimensions to the current map.
            </param>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.Bounds``1(GoRogue.MapViews.IMapView{``0})">
            <summary>
            Gets a rectangle representing the bounds of the current map view.
            </summary>
            <typeparam name="T"/>
            <param name="mapView"/>
            <returns>A rectangle representing the map view's bounds.</returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.Contains``1(GoRogue.MapViews.IMapView{``0},System.Int32,System.Int32)">
            <summary>
            Returns whether or not the given position is contained withing the current map view or not.
            </summary>
            <typeparam name="T"/>
            <param name="mapView"/>
            <param name="x">X-value of the position to check.</param>
            <param name="y">Y-value of the position to check.</param>
            <returns>True if the given position is contained within this map view, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.Contains``1(GoRogue.MapViews.IMapView{``0},GoRogue.Coord)">
            <summary>
            Returns whether or not the given position is contained withing the current map view or not.
            </summary>
            <typeparam name="T"/>
            <param name="mapView"/>
            <param name="position">The position to check.</param>
            <returns>True if the given position is contained within this map view, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.ExtendToString``1(GoRogue.MapViews.IMapView{``0},System.String,System.String,System.Func{``0,System.String},System.String,System.String,System.String,System.String)">
            <summary>
            Allows stringifying the contents of a map view. Takes characters to
            surround the map printout, and each row, the method used to get the string representation
            of each element (defaulting to the ToString function of type T), and separation
            characters for each element and row.
            </summary>
            <typeparam name="T"/>
            <param name="map"/>
            <param name="begin">Character(s) that should precede the IMapView printout.</param>
            <param name="beginRow">Character(s) that should precede each row.</param>
            <param name="elementStringifier">
            Function to use to get the string representation of each value. null uses the ToString
            function of type T.
            </param>
            <param name="rowSeparator">Character(s) to separate each row from the next.</param>
            <param name="elementSeparator">Character(s) to separate each element from the next.</param>
            <param name="endRow">Character(s) that should follow each row.</param>
            <param name="end">Character(s) that should follow the IMapView printout.</param>
            <returns>A string representation of the map, as viewd by the given map view.</returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.ExtendToString``1(GoRogue.MapViews.IMapView{``0},System.Int32,System.String,System.String,System.Func{``0,System.String},System.String,System.String,System.String,System.String)">
            <summary>
            Allows stringifying the contents of a map view. Takes characters to
            surround the map, and each row, the method used to get the string representation of each
            element (defaulting to the ToString function of type T), and separation characters for
            each element and row. Takes the size of the field to give each element, characters to
            surround the MapView printout, and each row, the method used to get the string
            representation of each element (defaulting to the ToString function of type T), and
            separation characters for each element and row.
            </summary>
            <typeparam name="T"/>
            <param name="map"/>
            <param name="fieldSize">
            The amount of space each element should take up in characters. A positive number aligns
            the text to the right of the space, while a negative number aligns the text to the left.
            </param>
            <param name="begin">Character(s) that should precede the IMapView printout.</param>
            <param name="beginRow">Character(s) that should precede each row.</param>
            <param name="elementStringifier">
            Function to use to get the string representation of each value. Null uses the ToString
            function of type T.
            </param>
            <param name="rowSeparator">Character(s) to separate each row from the next.</param>
            <param name="elementSeparator">Character(s) to separate each element from the next.</param>
            <param name="endRow">Character(s) that should follow each row.</param>
            <param name="end">Character(s) that should follow the IMapView printout.</param>
            <returns>A string representation of the map, as viewd by the given map view.</returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.Positions``1(GoRogue.MapViews.IMapView{``0})">
            <summary>
            Iterates through each position in the map view. Equivalent to nested for loop for (y =
            0...) for (x = 0...)
            </summary>
            <typeparam name="T"/>
            <param name="mapView"/>
            <returns>All positions in the IMapView.</returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.RandomItem``1(GoRogue.MapViews.IMapView{``0},Troschuetz.Random.IGenerator)">
            <summary>
            Gets the value at a random position in the IMapView.
            </summary>
            <typeparam name="T"/>
            <param name="mapView"/>
            <param name="rng">The rng to use. Defaults to <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>.</param>
            <returns>The item at a random position in the IMapView.</returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.RandomItem``1(GoRogue.MapViews.IMapView{``0},System.Func{GoRogue.Coord,``0,System.Boolean},Troschuetz.Random.IGenerator)">
            <summary>
            Gets the item at a random position in the map view for which the selector returns true.
            Random positions will continuously be generated until one that qualifies is found.
            </summary>
            <typeparam name="T"/>
            <param name="mapView"/>
            <param name="selector">
            Function that takes a position, and the value at that position, and returns true if it is an
            acceptable selection, and false if not.
            </param>
            <param name="rng">The rng to use. Defaults to <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>.</param>
            <returns>
            The item at a random position in the IMapView for which the selector returns true.
            </returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.RandomPosition``1(GoRogue.MapViews.IMapView{``0},``0,Troschuetz.Random.IGenerator)">
            <summary>
            Gets a random position in the map view, whose value in that map view is the specified
            one. Random positions will continually be generated until one with the specified value is found.
            </summary>
            <typeparam name="T"/>
            <param name="mapView"/>
            <param name="validValue">
            A value to look for in the IMapView to determine whether or not a generated position is valid.
            </param>
            <param name="rng">The rng to use. Defaults to <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>.</param>
            <returns>A random position whose value in the current IMapView is equal to the one specified.</returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.RandomPosition``1(GoRogue.MapViews.IMapView{``0},System.Collections.Generic.IEnumerable{``0},Troschuetz.Random.IGenerator)">
            <summary>
            Gets a random position in the map view, whose value in map view is one of the ones
            specified. Random positions will continually be generated until one that has one of the
            specified values is found.
            </summary>
            <typeparam name="T"/>
            <param name="mapView"/>
            <param name="validValues">
            A set of values to look for in the IMapView to determine whether or not a generated position
            is valid.
            </param>
            <param name="rng">The rng to use. Defaults to <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>.</param>
            <returns>
            A random position whose value in this IMapView is equal to one of the values specified.
            </returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.RandomPosition``1(GoRogue.MapViews.IMapView{``0},System.Collections.Generic.HashSet{``0},Troschuetz.Random.IGenerator)">
            <summary>
            Gets a random position in the map view, whose value in map view is one of the ones
            specified in the hash set. Random positions will continually be generated until one that
            has one of the specified values is found.
            </summary>
            <typeparam name="T"/>
            <param name="mapView"/>
            <param name="validValues">
            A set of values to look for in the IMapView to determine whether or not a generated position
            is valid.
            </param>
            <param name="rng">The rng to use. Defaults to <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>.</param>
            <returns>
            A random position whose value in this IMapView is equal to one of the values specified.
            </returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.RandomPosition``1(GoRogue.MapViews.IMapView{``0},Troschuetz.Random.IGenerator,``0[])">
            <summary>
            Gets a random position in the map view, whose value in map view is one of the ones
            specified in <paramref name="validValues"/>. Random positions will continually be generated until one that
            has one of the specified values is found.
            </summary>
            <typeparam name="T"/>
            <param name="mapView"/>
            <param name="rng">The rng to use. Defaults to <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>.</param>
            <param name="validValues">
            A set of values to look for in the IMapView to determine whether or not a generated position
            is valid.
            </param>
            <returns>
            A random position whose value in this IMapView is equal to one of the values specified.
            </returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.RandomPosition``1(GoRogue.MapViews.IMapView{``0},System.Func{GoRogue.Coord,``0,System.Boolean},Troschuetz.Random.IGenerator)">
            <summary>
            Gets a random position in the map view, for which the selector returns true. Random
            positions will continuously be generated until one that qualifies is found.
            </summary>
            <typeparam name="T"/>
            <param name="mapView"/>
            <param name="selector">
            Function that takes a position and the value at that position, and returns true if it is an
            acceptable selection, and false if not.
            </param>
            <param name="rng">The rng to use. Defaults to<see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>.</param>
            <returns>A random position in the IMapView for which the selector returns true.</returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.RandomPosition``1(GoRogue.MapViews.IMapView{``0},Troschuetz.Random.IGenerator)">
            <summary>
            Gets a random position within the IMapView.
            </summary>
            <typeparam name="T"/>
            <param name="mapView"/>
            <param name="rng">The rng to use. Defaults to <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>.</param>
            <returns>A random position within the IMapView.</returns>
        </member>
        <member name="T:GoRogue.MapViews.ISettableMapView`1">
            <summary>
            Interface designed to act as a standardized input/output interpretation for algorithms that need to make
            modifications to data on a map.
            </summary>
            <remarks>
            See <see cref="T:GoRogue.MapViews.IMapView`1"/>. Algorithms such as map generation may need to modify their
            inputs. Again, creating an actual 2D array can be tedious, depending on the application. As
            such, this interface extends IMapView to provide the capability to "set" values
            
            Like IMapView, a number of implementations of this interface to cover common cases are provided.  For example,
            in case an actual array is desired, <see cref="T:GoRogue.MapViews.ArrayMap`1"/> implements this interface for you via an actual
            array. Similarly, <see cref="T:GoRogue.MapViews.LambdaSettableMapView`1"/> implements the interface for you via a function you
            pass to it.
            </remarks>
            <typeparam name="T">The type of value being returned/set by the indexer functions.</typeparam>
        </member>
        <member name="P:GoRogue.MapViews.ISettableMapView`1.Item(System.Int32,System.Int32)">
            <summary>
            Given an X and Y value, returns/sets the "value" associated with that location.
            </summary>
            <param name="x">X-value of location.</param>
            <param name="y">Y-value of location.</param>
            <returns>The "value" associated with that location.</returns>
        </member>
        <member name="P:GoRogue.MapViews.ISettableMapView`1.Item(GoRogue.Coord)">
            <summary>
            Given a position, returns/sets the "value" associated with that location.
            </summary>
            <param name="pos">Location to get/set the value for.</param>
            <returns>The "value" associated with the provided location.</returns>
        </member>
        <member name="P:GoRogue.MapViews.ISettableMapView`1.Item(System.Int32)">
            <summary>
            Given an 1-dimensional index, returns/sets the value associated with the corresponding position
            in the map view.
            </summary>
            <remarks>
            Typically, this may be implemented in terms of <see cref="P:GoRogue.MapViews.ISettableMapView`1.Item(GoRogue.Coord)"/> by using
            <see cref="M:GoRogue.Coord.ToCoord(System.Int32,System.Int32)"/> to calculate the 2D position represented by that
            1D index, and passing that position to the <see cref="P:GoRogue.MapViews.ISettableMapView`1.Item(GoRogue.Coord)"/> indexer to get/set
            the value associated with the position.
            </remarks>
            <param name="index1D">1D index of location to get/set the "value" for.</param>
            <returns>The "value" associated with the given location.</returns>
        </member>
        <member name="T:GoRogue.MapViews.LambdaMapView`1">
            <summary>
            Class designed to make implementing simple IMapViews more convenient, by providing the "get"
            functionality via a function that is passed in at construction. For a version that
            implements <see cref="T:GoRogue.MapViews.ISettableMapView`1"/> as opposed to <see cref="T:GoRogue.MapViews.IMapView`1"/>, see
            <see cref="T:GoRogue.MapViews.LambdaSettableMapView`1"/>.
            </summary>
            <remarks>
            Despite actual game map representations often consisting of complex types, exposing certain
            properties as primitive types (via IMapView implementations) for GoRogue algorithms to use is
            often fairly simple (simply exposing a property in the actual map class, or similar). If your
            map consists of cells of some sort, where there exists an instance of some class/struct per
            location that contains information about that location, TranslationMap/LambdaTranslationMap
            provide convenient ways to implement simple IMapViews. In the case that no such single type
            exists, however, a more generic IMapView implementation is needed. This class takes the "get"
            function as a function to shorten the process of creating such an implementation.
            </remarks>
            <typeparam name="T">The type of value being returned by the indexer functions.</typeparam>
        </member>
        <member name="M:GoRogue.MapViews.LambdaMapView`1.#ctor(System.Int32,System.Int32,System.Func{GoRogue.Coord,`0})">
            <summary>
            Constructor. Takes the width and height of the map, and the function to use to retrieve
            the value for a location.
            </summary>
            <remarks>
            This constructor is useful if the width and height of the underlying representation do
            not change, so they can safely be passed in as constants.
            </remarks>
            <param name="width">The (constant) width of the map.</param>
            <param name="height">The (constant) height of the map.</param>
            <param name="valueGetter">
            A lambda/function that returns the value of type T associated with the location it is given.
            This function is called each time the map view's indexers are called upon to retrieve a value
            from a location.
            </param>
        </member>
        <member name="M:GoRogue.MapViews.LambdaMapView`1.#ctor(System.Func{System.Int32},System.Func{System.Int32},System.Func{GoRogue.Coord,`0})">
            <summary>
            Constructor. Takes functions that retrieve the width and height of the map, and the
            function used to retrieve the value for a location.
            </summary>
            <remarks>
            This constructor is useful if the width and height of the map being represented may
            change -- one can provide lambdas/functions that retrieve the width and height of the map being
            represented, and these functions will be called any time the <see cref="P:GoRogue.MapViews.LambdaMapView`1.Width"/> and <see cref="P:GoRogue.MapViews.LambdaMapView`1.Height"/>
            properties are retrieved.
            </remarks>
            <param name="widthGetter">
            A function/lambda that retrieves the width of the map being represented.
            </param>
            <param name="heightGetter">
            A function/lambda that retrieves the height of the map being represented.
            </param>
            <param name="valueGetter">
            A function/lambda that returns the value of type T associated with the location it is given.
            </param>
        </member>
        <member name="P:GoRogue.MapViews.LambdaMapView`1.Height">
            <summary>
            The height of the map being represented.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.LambdaMapView`1.Width">
            <summary>
            The width of the map being represented.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.LambdaMapView`1.Item(System.Int32)">
            <summary>
            Given an 1D-array-style index, determines the position associated with that index, and
            returns the "value" associated with that location, by calling the valueGetter function
            passed in at construction.
            </summary>
            <param name="index1D">1D-array-style index for location to retrieve value for.</param>
            <returns>
            The "value" associated with the given location, according to the valueGetter function provided
            at construction.
            </returns>
        </member>
        <member name="P:GoRogue.MapViews.LambdaMapView`1.Item(System.Int32,System.Int32)">
            <summary>
            Given an X and Y value, returns the "value" associated with that location, by calling the
            valueGetter function provided at construction.
            </summary>
            <param name="x">X-value of location.</param>
            <param name="y">Y-value of location.</param>
            <returns>
            The "value" associated with that location, according to the valueGetter function provided
            at construction.
            </returns>
        </member>
        <member name="P:GoRogue.MapViews.LambdaMapView`1.Item(GoRogue.Coord)">
            <summary>
            Given a position, returns the "value" associated with that position, by calling the
            valueGetter function provided at construction.
            </summary>
            <param name="pos">Location to retrieve the value for.</param>
            <returns>
            The "value" associated with the provided location, according to the valueGetter function
            provided at construction.
            </returns>
        </member>
        <member name="M:GoRogue.MapViews.LambdaMapView`1.ToString">
            <summary>
            Returns a string representation of the map view.
            </summary>
            <returns>A string representation of the map view.</returns>
        </member>
        <member name="M:GoRogue.MapViews.LambdaMapView`1.ToString(System.Func{`0,System.String})">
            <summary>
            Returns a string representation of the map view, using <paramref name="elementStringifier"/>
            to determine what string represents each value.
            </summary>
            <remarks>
            This could be used, for example, on an LambdaMapView of boolean values, to output '#' for
            false values, and '.' for true values.
            </remarks>
            <param name="elementStringifier">
            Function determining the string representation of each element.
            </param>
            <returns>A string representation of the LambdaMapView.</returns>
        </member>
        <member name="M:GoRogue.MapViews.LambdaMapView`1.ToString(System.Int32,System.Func{`0,System.String})">
            <summary>
            Prints the values in the LambdaMapView, using the function specified to turn elements into
            strings, and using the "field length" specified.
            </summary>
            <remarks>
            Each element of type T will have spaces added to cause it to take up exactly
            <paramref name="fieldSize"/> characters, provided <paramref name="fieldSize"/> 
            is less than the length of the element's string represention.
            </remarks>
            <param name="fieldSize">
            The size of the field to give each value.  A positive-number
            right-aligns the text within the field, while a negative number left-aligns the text.
            </param>
            <param name="elementStringifier">
            Function to use to convert each element to a string. null defaults to the ToString
            function of type T.
            </param>
            <returns>A string representation of the LambdaMapView.</returns>
        </member>
        <member name="T:GoRogue.MapViews.LambdaSettableMapView`1">
            <summary>
            Class designed to make implementing simple ISettableMapViews more convenient, by providing the
            get/set functionality via a function that is passed in at construction. For a version that
            implements <see cref="T:GoRogue.MapViews.IMapView`1"/> as opposed to <see cref="T:GoRogue.MapViews.ISettableMapView`1"/>, see
            <see cref="T:GoRogue.MapViews.LambdaMapView`1"/>.
            </summary>
            <remarks>
            See <see cref="T:GoRogue.MapViews.LambdaMapView`1"/>.  Identical in nature, but takes both get and set functionality
            via functions.
            </remarks>
            <typeparam name="T">The type of value being returned by the indexer functions.</typeparam>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableMapView`1.#ctor(System.Int32,System.Int32,System.Func{GoRogue.Coord,`0},System.Action{GoRogue.Coord,`0})">
            <summary>
            Constructor. Takes the width and height of the map, and the functions to use to
            retrieve/set the value for a location.
            </summary>
            <remarks>
            This constructor is useful if the width and height of the underlying representation do
            not change, so they can safely be passed in as constants.
            </remarks>
            <param name="width">The (constant) width of the map.</param>
            <param name="height">The (constant) height of the map.</param>
            <param name="valueGetter">
            A function/lambda that returns the value of type T associated with the location it is given.
            </param>
            <param name="valueSetter">
            A function/lambda that updates the map being represented accordingly, given a type T and
            position to which it was set.
            </param>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableMapView`1.#ctor(System.Func{System.Int32},System.Func{System.Int32},System.Func{GoRogue.Coord,`0},System.Action{GoRogue.Coord,`0})">
            <summary>
            Constructor. Takes functions that retrieve the width and height of the map, and the
            functions used to retrieve/set the value for a location.
            </summary>
            <remarks>
            This constructor is useful if the width and height of the map being represented may
            change -- one can provide functions that retrieve the width and height of the map being
            represented, and these functions will be called any time the <see cref="P:GoRogue.MapViews.LambdaSettableMapView`1.Width"/> and <see cref="P:GoRogue.MapViews.LambdaSettableMapView`1.Height"/>
            properties are retrieved.
            </remarks>
            <param name="widthGetter">
            A function/lambda that retrieves the width of the map being represented.
            </param>
            <param name="heightGetter">
            A function/lambda that retrieves the height of the map being represented.
            </param>
            <param name="valueGetter">
            A function/lambda that returns the value of type T associated with the location it is given.
            </param>
            <param name="valueSetter">
            A function/lambda that updates the map being represented accordingly, given a type T and
            position to which it was set.
            </param>
        </member>
        <member name="P:GoRogue.MapViews.LambdaSettableMapView`1.Height">
            <summary>
            The height of the map being represented.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.LambdaSettableMapView`1.Width">
            <summary>
            The width of the map being represented.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.LambdaSettableMapView`1.Item(System.Int32)">
            <summary>
            Given an 1D-array-style index, determines the position associated with that index, and
            returns/sets the "value" associated with that location, by calling the valueGetter/valueSetter
            function passed in at construction.
            </summary>
            <param name="index1D">1D-array-style index for location to get/set the value for.</param>
            <returns>
            The "value" associated with the given location, according to the valueGetter function provided
            at construction.
            </returns>
        </member>
        <member name="P:GoRogue.MapViews.LambdaSettableMapView`1.Item(System.Int32,System.Int32)">
            <summary>
            Given an X and Y value, returns/sets the "value" associated with that location, by
            calling the valueGetter/valueSetter functions provided at construction.
            </summary>
            <param name="x">X-value of location.</param>
            <param name="y">Y-value of location.</param>
            <returns>
            The "value" associated with that location, according to the valueGetter function provided
            at construction.
            </returns>
        </member>
        <member name="P:GoRogue.MapViews.LambdaSettableMapView`1.Item(GoRogue.Coord)">
            <summary>
            Given a position, returns/sets the "value" associated with that location, by calling the
            valueGetter/valueSetter functions provided at construction.
            </summary>
            <param name="pos">Location to retrieve/set the value for.</param>
            <returns>
            The "value" associated with the provided location, according to the valueGetter function
            provided at construction.
            </returns>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableMapView`1.ToString">
            <summary>
            Returns a string representation of the LambdaSettableMapView.
            </summary>
            <returns>A string representation of the LambdaSettableMapView.</returns>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableMapView`1.ToString(System.Func{`0,System.String})">
            <summary>
            Returns a string representation of the map view, using <paramref name="elementStringifier"/>
            to determine what string represents each value.
            </summary>
            <remarks>
            This could be used, for example, on an LambdaSettableMapView of boolean values, to output '#' for
            false values, and '.' for true values.
            </remarks>
            <param name="elementStringifier">
            Function determining the string representation of each element.
            </param>
            <returns>A string representation of the LambdaSettableMapView.</returns>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableMapView`1.ToString(System.Int32,System.Func{`0,System.String})">
            <summary>
            Prints the values in the LambdaSettableMapView, using the function specified to turn elements into
            strings, and using the "field length" specified.
            </summary>
            <remarks>
            Each element of type T will have spaces added to cause it to take up exactly
            <paramref name="fieldSize"/> characters, provided <paramref name="fieldSize"/> 
            is less than the length of the element's string represention.
            </remarks>
            <param name="fieldSize">
            The size of the field to give each value.  A positive-number
            right-aligns the text within the field, while a negative number left-aligns the text.
            </param>
            <param name="elementStringifier">
            Function to use to convert each element to a string. null defaults to the ToString
            function of type T.
            </param>
            <returns>A string representation of the LambdaSettableMapView.</returns>
        </member>
        <member name="T:GoRogue.MapViews.LambdaSettableTranslationMap`2">
            <summary>
            A simple <see cref="T:GoRogue.MapViews.SettableTranslationMap`2"/> implementation that allows you to provide
            functions/lambdas for the translation functions. For a version offering only "get" functionality,
            see <see cref="T:GoRogue.MapViews.LambdaTranslationMap`2"/>.
            </summary>
            <remarks>
            If you have a view that simply exposes a property of your underlying data, it
            can be tedious to write a <see cref="T:GoRogue.MapViews.SettableTranslationMap`2"/> implementation for all of them.
            This class simplifies that task by letting you just provide the translation methods as funtions/lambdas
            without needing to build the rest of the class infrastructure.
            </remarks>
            <typeparam name="T1">The type of your underlying data.</typeparam>
            <typeparam name="T2">The type of the data being exposed to the algorithm.</typeparam>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableTranslationMap`2.#ctor(GoRogue.MapViews.ISettableMapView{`0},System.Func{`0,`1},System.Func{`1,`0})">
            <summary>
            Constructor. Takes an existing map view to create a view from, and getter/setter
            functions taking only a map value.
            </summary>
            <remarks>
            If a position is also needed to perform the translation, an overload is provided taking
            corresponding functions.
            </remarks>
            <param name="baseMap">Your underlying map data.</param>
            <param name="getter">The TranslateGet implementation.</param>
            <param name="setter">The TranslateSet implementation.</param>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableTranslationMap`2.#ctor(GoRogue.MapViews.ISettableMapView{`0},System.Func{GoRogue.Coord,`0,`1},System.Func{GoRogue.Coord,`1,`0})">
            <summary>
            Constructor. Takes an existing map view to create a view from, and getter/setter
            functions taking a map value and its corresponding position.
            </summary>
            <param name="baseMap">Your underlying map data.</param>
            <param name="getter">The TranslateGet implementation.</param>
            <param name="setter">The TranslateSet implementation.</param>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableTranslationMap`2.#ctor(GoRogue.MapViews.ISettableMapView{`0},GoRogue.MapViews.ISettableMapView{`1},System.Func{`0,`1},System.Func{`1,`0})">
            <summary>
            Constructor. Takes an existing map view to create a view from and applies view data to it.
            </summary>
            <param name="baseMap">Your underlying map data.</param>
            <param name="overlay">
            The view data to apply to the map. Must have identical dimensions to <paramref name="baseMap"/>.
            </param>
            <param name="getter">The TranslateGet implementation.</param>
            <param name="setter">The TranslateSet implementation.</param>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableTranslationMap`2.#ctor(GoRogue.MapViews.ISettableMapView{`0},GoRogue.MapViews.ISettableMapView{`1},System.Func{GoRogue.Coord,`0,`1},System.Func{GoRogue.Coord,`1,`0})">
            <summary>
            Constructor. Takes an existing map view to create a view from and applies view data to it.
            </summary>
            <param name="baseMap">Your underlying map data.</param>
            <param name="overlay">
            The view data to apply to the map. Must have identical dimensions to <paramref name="baseMap"/>.
            </param>
            <param name="getter">The TranslateGet implementation.</param>
            <param name="setter">The TranslateSet implementation.</param>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableTranslationMap`2.TranslateGet(GoRogue.Coord,`0)">
            <summary>
            Translates your map data into the view type by calling the getter function specified in the
            class constructor.
            </summary>
            <param name="position">Position corresponding to given data value of your map.</param>
            <param name="value">The data value from your map.</param>
            <returns>A value of the mapped data type (via the getter specified in the class constructor).</returns>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableTranslationMap`2.TranslateSet(GoRogue.Coord,`1)">
            <summary>
            Translates the view type into the appropriate form for your map data, by calling the
            setter function specified in the class constructor.
            </summary>
            <param name="position">Position corresponding to the given mapped data type.</param>
            <param name="value">A value of the mapped data type.</param>
            <returns>The data value for your map, (via the setter specified in the class constructor).</returns>
        </member>
        <member name="T:GoRogue.MapViews.LambdaTranslationMap`2">
            <summary>
            A simple <see cref="T:GoRogue.MapViews.TranslationMap`2"/> implementation that allows you to provide a function/lambda
            at construction to use as the TranslateGet implementation. For a version offering "set" functionality,
            see <see cref="T:GoRogue.MapViews.LambdaSettableTranslationMap`2"/>.
            </summary>
            <remarks>
            If you have a view that simply exposes a simple property of your underlying data, it
            can be tedious to write a <see cref="T:GoRogue.MapViews.TranslationMap`2"/> implementation for
            all of them. This class simplifies that task by letting you just provide the
            translation method as a function/lambda, without needing to build the rest of the
            class infrastructure.
            </remarks>
            <typeparam name="T1">The type of your underlying data.</typeparam>
            <typeparam name="T2">The type of the data being exposed to the algorithm.</typeparam>
        </member>
        <member name="M:GoRogue.MapViews.LambdaTranslationMap`2.#ctor(GoRogue.MapViews.IMapView{`0},System.Func{`0,`1})">
            <summary>
            Constructor. Takes an existing map view to create a view from and a getter function
            taking only a value of type T1.
            </summary>
            <remarks>
            If a position is also needed to perform the translation, an overload is provided taking a
            corresponding function.
            </remarks>
            <param name="baseMap">Your underlying map data.</param>
            <param name="getter">The TranslateGet implementation.</param>
        </member>
        <member name="M:GoRogue.MapViews.LambdaTranslationMap`2.#ctor(GoRogue.MapViews.IMapView{`0},System.Func{GoRogue.Coord,`0,`1})">
            <summary>
            Constructor. Takes an existing map view to create a view from and a getter function
            taking a value of type T1 and its corresponding position.
            </summary>
            <param name="baseMap">Your underlying map data.</param>
            <param name="getter">The TranslateGet implementation.</param>
        </member>
        <member name="M:GoRogue.MapViews.LambdaTranslationMap`2.TranslateGet(GoRogue.Coord,`0)">
            <summary>
            Translates your map data into the view type by calling the getter function specified in the
            class constructor.
            </summary>
            <param name="position">Position corresponding to given data value of your map.</param>
            <param name="value">The data value from your map.</param>
            <returns>A value of the mapped data type (via the getter specified in the class constructor).</returns>
        </member>
        <member name="T:GoRogue.MapViews.SettableTranslationMap`2">
            <summary>
            Settable map view class capable of taking complex data and providing a simpler view of it.
            For a version that provides only "get" functionality, see <see cref="T:GoRogue.MapViews.TranslationMap`2"/>.
            </summary>
            <remarks>
            See <see cref="T:GoRogue.MapViews.TranslationMap`2"/>.  The use case is the same, except that this class
            implements <see cref="T:GoRogue.MapViews.ISettableMapView`1"/> instead, and thus also allows you to specify
            set-translations via TranslateSet.
            </remarks>
            <typeparam name="T1">The type of your underlying data.</typeparam>
            <typeparam name="T2">The type of the data being exposed to the algorithm.</typeparam>
        </member>
        <member name="M:GoRogue.MapViews.SettableTranslationMap`2.#ctor(GoRogue.MapViews.ISettableMapView{`0})">
            <summary>
            Constructor. Takes an existing map view to create a view from.
            </summary>
            <param name="baseMap">Your underlying map data.</param>
        </member>
        <member name="M:GoRogue.MapViews.SettableTranslationMap`2.#ctor(GoRogue.MapViews.ISettableMapView{`0},GoRogue.MapViews.ISettableMapView{`1})">
            <summary>
            Constructor. Takes an existing map view to create a view from and applies view data to it.
            </summary>
            <remarks>
            Since this constructor must call TranslateSet to perform its function, do NOT
            call this constructor if the TranslateSet implementation depends on the derived
            class's constructor being completed to function properly.
            </remarks>
            <param name="baseMap">Your underlying map data.</param>
            <param name="overlay">
            The view data to apply to the map. Must have identical dimensions to <paramref name="baseMap"/>.
            </param>
        </member>
        <member name="P:GoRogue.MapViews.SettableTranslationMap`2.BaseMap">
            <summary>
            The underlying map.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.SettableTranslationMap`2.Height">
            <summary>
            The height of the underlying map.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.SettableTranslationMap`2.Width">
            <summary>
            The width of the underlying map.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.SettableTranslationMap`2.Item(System.Int32)">
            <summary>
            Given an 1D-array-style index, determines the position associated with that index, and
            returns/sets the "value" associated with that location.  This function calls
            <see cref="P:GoRogue.MapViews.SettableTranslationMap`2.Item(GoRogue.Coord)"/>, so override that indexer to change functionality.
            </summary>
            <param name="index1D">1D-array-style index for location to retrieve/set value for.</param>
            <returns>
            The "value" associated with the given location, according to the translation function.
            </returns>
        </member>
        <member name="P:GoRogue.MapViews.SettableTranslationMap`2.Item(GoRogue.Coord)">
            <summary>
            Given a position, translates and returns/sets the "value" associated with that position.
            The  other indexers call this indexer for its functionality, so overriding this
            functionality also changes those overloads.
            </summary>
            <param name="pos">Location to get/set the value for.</param>
            <returns>The translated "value" associated with the provided location.</returns>
        </member>
        <member name="P:GoRogue.MapViews.SettableTranslationMap`2.Item(System.Int32,System.Int32)">
            <summary>
            Given an X and Y value, translates and returns/sets the "value" associated with that
            location. This function calls <see cref="P:GoRogue.MapViews.SettableTranslationMap`2.Item(GoRogue.Coord)"/>, so override that indexer to
            change functionality.
            </summary>
            <param name="x">X-value of location.</param>
            <param name="y">Y-value of location.</param>
            <returns>The translated "value" associated with that location.</returns>
        </member>
        <member name="M:GoRogue.MapViews.SettableTranslationMap`2.ToString">
            <summary>
            Returns a string representation of the SettableTranslationMap.
            </summary>
            <returns>A string representation of the SettableTranslationMap.</returns>
        </member>
        <member name="M:GoRogue.MapViews.SettableTranslationMap`2.ToString(System.Func{`1,System.String})">
            <summary>
            Returns a string representation of the map view, using <paramref name="elementStringifier"/>
            to determine what string represents each value.
            </summary>
            <remarks>
            This could be used, for example, on an SettableTranslationMap of boolean values, to output '#' for
            false values, and '.' for true values.
            </remarks>
            <param name="elementStringifier">
            Function determining the string representation of each element.
            </param>
            <returns>A string representation of the SettableTranslationMap.</returns>
        </member>
        <member name="M:GoRogue.MapViews.SettableTranslationMap`2.ToString(System.Int32,System.Func{`1,System.String})">
            <summary>
            Prints the values in the map view, using the function specified to turn elements into
            strings, and using the "field length" specified.
            </summary>
            <remarks>
            Each element of type T will have spaces added to cause it to take up exactly
            <paramref name="fieldSize"/> characters, provided <paramref name="fieldSize"/> 
            is less than the length of the element's string represention.
            </remarks>
            <param name="fieldSize">
            The size of the field to give each value.  A positive-number
            right-aligns the text within the field, while a negative number left-aligns the text.
            </param>
            <param name="elementStringifier">
            Function to use to convert each element to a string. null defaults to the ToString
            function of type T.
            </param>
            <returns>A string representation of the SettableTranslationMap.</returns>
        </member>
        <member name="M:GoRogue.MapViews.SettableTranslationMap`2.TranslateGet(`0)">
            <summary>
            Translates your map data into the view type. Takes only a value from the underlying map.
            If a position is also needed to perform the translation, use <see cref="M:GoRogue.MapViews.SettableTranslationMap`2.TranslateGet(GoRogue.Coord,`0)"/>
            instead.
            </summary>
            <param name="value">The data value from your map.</param>
            <returns>A value of the mapped data type</returns>
        </member>
        <member name="M:GoRogue.MapViews.SettableTranslationMap`2.TranslateGet(GoRogue.Coord,`0)">
            <summary>
            Translates your map data into the view type. Takes a value from the underlying map and
            the corresponding position for that value. If a position is not needed to perform the
            translation, use <see cref="M:GoRogue.MapViews.SettableTranslationMap`2.TranslateGet(`0)"/> instead.
            </summary>
            <param name="position">The position of the given data value from your map.</param>
            <param name="value">The data value from your map.</param>
            <returns>A value of the mapped data type</returns>
        </member>
        <member name="M:GoRogue.MapViews.SettableTranslationMap`2.TranslateSet(`1)">
            <summary>
            Translates the view type into the appropriate form for your map data. Takes only a value
            from the underlying map. If a position is also needed to perform the translation, use
            <see cref="M:GoRogue.MapViews.SettableTranslationMap`2.TranslateSet(GoRogue.Coord,`1)"/> instead.
            </summary>
            <param name="value">A value of the mapped data type</param>
            <returns>The data value for your map.</returns>
        </member>
        <member name="M:GoRogue.MapViews.SettableTranslationMap`2.TranslateSet(GoRogue.Coord,`1)">
            <summary>
            Translates the view type into the appropriate form for your map data. Takes a value from
            the underlying map, and it corresponding position. If a position is not needed to perform
            the translation, use <see cref="M:GoRogue.MapViews.SettableTranslationMap`2.TranslateSet(`1)"/> instead.
            </summary>
            <param name="position">The position of the given mapped data type.</param>
            <param name="value">A value of the mapped data type</param>
            <returns>The data value for your map.</returns>
        </member>
        <member name="T:GoRogue.MapViews.SettableViewport`1">
            <summary>
            Similar to <see cref="T:GoRogue.MapViews.Viewport`1"/>, but implements <see cref="T:GoRogue.MapViews.ISettableMapView`1"/>and thus implements
            "set" functionality via relative coordinates.
            </summary>
            <typeparam name="T">Type being exposed by map view.</typeparam>
        </member>
        <member name="M:GoRogue.MapViews.SettableViewport`1.#ctor(GoRogue.MapViews.ISettableMapView{`0},GoRogue.Rectangle)">
            <summary>
            Constructor. Takes the parent map view, and the initial subsection of that map view to represent.
            </summary>
            <param name="mapView">The map view being represented.</param>
            <param name="viewArea">The initial subsection of that map to represent.</param>
        </member>
        <member name="M:GoRogue.MapViews.SettableViewport`1.#ctor(GoRogue.MapViews.ISettableMapView{`0})">
            <summary>
            Constructor. Takes the map view to represent. The viewport will represent the entire given map view.
            </summary>
            <param name="mapView">The map view to represent.</param>
        </member>
        <member name="P:GoRogue.MapViews.SettableViewport`1.MapView">
            <summary>
            The map view that this viewport is exposing values from.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.SettableViewport`1.Item(System.Int32)">
            <summary>
            Given a position in relative 1d-array-index style, returns/sets the "value" associated with that
            location in absolute coordinates.
            </summary>
            <param name="relativeIndex1D">
            Viewport-relative position of the location to retrieve/set the value for, as a 1D array index.
            </param>
            <returns>
            The "value" associated with the absolute location represented on the underlying map view.
            </returns>
        </member>
        <member name="P:GoRogue.MapViews.SettableViewport`1.Item(GoRogue.Coord)">
            <summary>
            Given a position in relative coordinates, sets/returns the "value" associated with that
            location in absolute coordinates.
            </summary>
            <param name="relativePosition">
            Viewport-relative position of the location to retrieve/set the value for.
            </param>
            <returns>
            The "value" associated with the absolute location represented on the underlying map view.
            </returns>
        </member>
        <member name="P:GoRogue.MapViews.SettableViewport`1.Item(System.Int32,System.Int32)">
            <summary>
            Given an X and Y value in relative coordinates, sets/returns the "value" associated with
            that location in absolute coordinates.
            </summary>
            <param name="relativeX">Viewport-relative X-value of location.</param>
            <param name="relativeY">Viewport-relative Y-value of location.</param>
            <returns>
            The "value" associated with the absolute location represented on the underlying map view.
            </returns>
        </member>
        <member name="T:GoRogue.MapViews.TranslationMap`2">
            <summary>
            Map view class capable of taking complex data and providing a simpler view of it. For a
            version that provides "set" functionality, see <see cref="T:GoRogue.MapViews.SettableTranslationMap`2"/>.
            </summary>
            <remarks>
            Many GoRogue algorithms work on a IMapView of a simple data type, which is likely to be a
            poor match for your game's actual map data. For example, map generation works with bools, and
            SenseMap calculation with doubles, while your map data may model each map cell as a class or
            struct containing many different member values. This class allows you to build descendant
            classes that override the TranslateGet method(s) for simple mapping, or the "this" indexers
            if you need full access to the underlying data for context, in order to present a simplified
            view of your data to an algorithm without having to create the large amount of duplicate code
            associated with multiple ISettableMapView instances that all extract data from a Cell or Tile class.
            
            If your TranslateGet implementation is simple, or you do not want to create a full subclass, you should
            look at <see cref="T:GoRogue.MapViews.LambdaTranslationMap`2"/> instead.
            </remarks>
            <typeparam name="T1">The type of your underlying data.</typeparam>
            <typeparam name="T2">The type of the data being exposed to the algorithm.</typeparam>
        </member>
        <member name="M:GoRogue.MapViews.TranslationMap`2.#ctor(GoRogue.MapViews.IMapView{`0})">
            <summary>
            Constructor. Takes an existing map view to create a view from.
            </summary>
            <param name="baseMap">Your underlying map data.</param>
        </member>
        <member name="P:GoRogue.MapViews.TranslationMap`2.BaseMap">
            <summary>
            The underlying map.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.TranslationMap`2.Height">
            <summary>
            The height of the underlying map.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.TranslationMap`2.Width">
            <summary>
            The width of the underlying map.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.TranslationMap`2.Item(System.Int32)">
            <summary>
            Given an 1D-array-style index, determines the position associated with that index, and
            returns the "value" associated with that location.  This function calls <see cref="P:GoRogue.MapViews.TranslationMap`2.Item(GoRogue.Coord)"/>,
            so override that indexer to change functionality.
            </summary>
            <param name="index1D">1D-array-style index for location to retrieve value for.</param>
            <returns>
            The "value" associated with the given location, according to the translation function.
            </returns>
        </member>
        <member name="P:GoRogue.MapViews.TranslationMap`2.Item(System.Int32,System.Int32)">
            <summary>
            Given an X and Y value, translates and returns the "value" associated with that location.
            This function calls this[Coord pos], so override that indexer to change functionality.
            </summary>
            <param name="x">X-value of location.</param>
            <param name="y">Y-value of location.</param>
            <returns>The translated "value" associated with that location.</returns>
        </member>
        <member name="P:GoRogue.MapViews.TranslationMap`2.Item(GoRogue.Coord)">
            <summary>
            Given a position, translates and returns the "value" associated with that position. the other indexers
            call this indexer for its functionality, so overriding this functionality also
            changes those overloads.
            </summary>
            <param name="pos">Location to get the value for.</param>
            <returns>The translated "value" associated with the provided location.</returns>
        </member>
        <member name="M:GoRogue.MapViews.TranslationMap`2.ToString">
            <summary>
            Returns a string representation of the TranslationMap.
            </summary>
            <returns>A string representation of the TranslationMap.</returns>
        </member>
        <member name="M:GoRogue.MapViews.TranslationMap`2.ToString(System.Func{`1,System.String})">
            <summary>
            Returns a string representation of the map view, using <paramref name="elementStringifier"/>
            to determine what string represents each value.
            </summary>
            <remarks>
            This could be used, for example, on an TranslationMap of boolean values, to output '#' for
            false values, and '.' for true values.
            </remarks>
            <param name="elementStringifier">
            Function determining the string representation of each element.
            </param>
            <returns>A string representation of the TranslationMap.</returns>
        </member>
        <member name="M:GoRogue.MapViews.TranslationMap`2.ToString(System.Int32,System.Func{`1,System.String})">
            <summary>
            Prints the values in the map view, using the function specified to turn elements into
            strings, and using the "field length" specified.
            </summary>
            <remarks>
            Each element of type T will have spaces added to cause it to take up exactly
            <paramref name="fieldSize"/> characters, provided <paramref name="fieldSize"/> 
            is less than the length of the element's string represention.
            </remarks>
            <param name="fieldSize">
            The size of the field to give each value.  A positive-number
            right-aligns the text within the field, while a negative number left-aligns the text.
            </param>
            <param name="elementStringifier">
            Function to use to convert each element to a string. null defaults to the ToString
            function of type T.
            </param>
            <returns>A string representation of the TranslationMap.</returns>
        </member>
        <member name="M:GoRogue.MapViews.TranslationMap`2.TranslateGet(`0)">
            <summary>
            Translates your map data into the view type using just the map data value itself. If you need
            the location as well to perform the translation, implement <see cref="M:GoRogue.MapViews.TranslationMap`2.TranslateGet(GoRogue.Coord,`0)"/>
            instead.
            </summary>
            <param name="value">The data value from your map.</param>
            <returns>A value of the mapped data type</returns>
        </member>
        <member name="M:GoRogue.MapViews.TranslationMap`2.TranslateGet(GoRogue.Coord,`0)">
            <summary>
            Translates your map data into the view type using the position and the map data value. If
            you need only the data value to perform the translation, implement <see cref="M:GoRogue.MapViews.TranslationMap`2.TranslateGet(`0)"/>
            instead.
            </summary>
            <param name="position">The position of the given data value in your map.</param>
            <param name="value">The data value from your map.</param>
            <returns>A value of the mapped data type</returns>
        </member>
        <member name="T:GoRogue.MapViews.UnboundedViewport`1">
            <summary>
            Class like <see cref="T:GoRogue.MapViews.Viewport`1"/>, however the view area is in no way bounded to the edges of the underlying map.
            Instead, if you access a position that cannot map to any valid position in the underlying map view, a (specified)
            default value is returned.
            </summary>
            <typeparam name="T">The type being exposed by the UnboundedViewport.</typeparam>
        </member>
        <member name="M:GoRogue.MapViews.UnboundedViewport`1.#ctor(GoRogue.MapViews.IMapView{`0},GoRogue.Rectangle,`0)">
            <summary>
            Constructor. Takes the parent map view, and the initial subsection of that map view to represent.
            </summary>
            <param name="mapView">The map view being represented.</param>
            <param name="viewArea">The initial subsection of that map to represent.</param>
            <param name="defaultValue">The value to return if a position is accessed that is outside the actual underlying map view.</param>
        </member>
        <member name="M:GoRogue.MapViews.UnboundedViewport`1.#ctor(GoRogue.MapViews.IMapView{`0},`0)">
            <summary>
            Constructor. Takes the map view to represent. The viewport will represent the entire given map view.
            </summary>
            <param name="mapView">The map view to represent.</param>
            <param name="defaultValue">The value to return if a position is accessed that is outside the actual underlying map view.</param>
        </member>
        <member name="P:GoRogue.MapViews.UnboundedViewport`1.Height">
            <summary>
            The height of the area being represented.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.UnboundedViewport`1.MapView">
            <summary>
            The map view that this UnboundedViewport is exposing values from.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.UnboundedViewport`1.ViewArea">
            <summary>
            The area of the base MapView that this Viewport is exposing. Although this property does
            not explicitly expose a set accessor, it is returning a reference and as such may be
            assigned to. This viewport is NOT bounded to base map edges -- for this functionality, see the <see cref="T:GoRogue.MapViews.Viewport`1"/> class.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.UnboundedViewport`1.Width">
            <summary>
            The height of the area being represented.
            </summary>
        </member>
        <member name="F:GoRogue.MapViews.UnboundedViewport`1.DefaultValue">
            <summary>
            The value to return if a position is accessed that is outside the actual underlying map view.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.UnboundedViewport`1.Item(System.Int32)">
            <summary>
            Given a position in relative 1d-array-index style, returns the "value" associated with that
            location in absolute coordinates.
            </summary>
            <param name="relativeIndex1D">
            Viewport-relative position of the location to retrieve the value for, as a 1D array index.
            </param>
            <returns>
            The "value" associated with the absolute location represented on the underlying map view,
            or <see cref="F:GoRogue.MapViews.UnboundedViewport`1.DefaultValue"/> if the absolute position does not exist in the underlying map view.
            </returns>
        </member>
        <member name="P:GoRogue.MapViews.UnboundedViewport`1.Item(GoRogue.Coord)">
            <summary>
            Given a position in relative coordinates, returns the "value" associated with that
            location in absolute coordinates.
            </summary>
            <param name="relativePosition">
            Viewport-relative position of the location to retrieve the value for.
            </param>
            <returns>
            The "value" associated with the absolute location represented on the underlying map view,
            or <see cref="F:GoRogue.MapViews.UnboundedViewport`1.DefaultValue"/> if the absolute position does not exist in the underlying map view.
            </returns>
        </member>
        <member name="P:GoRogue.MapViews.UnboundedViewport`1.Item(System.Int32,System.Int32)">
            <summary>
            Given an X and Y value in relative coordinates, returns the "value" associated with that
            location in absolute coordinates.
            </summary>
            <param name="relativeX">Viewport-relative X-value of location.</param>
            <param name="relativeY">Viewport-relative Y-value of location.</param>
            <returns>
            The "value" associated with the absolute location represented on the underlying map view, 
            or <see cref="F:GoRogue.MapViews.UnboundedViewport`1.DefaultValue"/> if the absolute position does not exist in the underlying map view.
            </returns>
        </member>
        <member name="M:GoRogue.MapViews.UnboundedViewport`1.ToString">
            <summary>
            Returns a string representation of the UnboundedViewport.
            </summary>
            <returns>A string representation of the UnboundedViewport.</returns>
        </member>
        <member name="M:GoRogue.MapViews.UnboundedViewport`1.ToString(System.Func{`0,System.String})">
            <summary>
            Returns a string representation of the map view, using <paramref name="elementStringifier"/>
            to determine what string represents each value.
            </summary>
            <remarks>
            This could be used, for example, on an UnboundedViewport of boolean values, to output '#' for
            false values, and '.' for true values.
            </remarks>
            <param name="elementStringifier">
            Function determining the string representation of each element.
            </param>
            <returns>A string representation of the UnboundedViewport.</returns>
        </member>
        <member name="M:GoRogue.MapViews.UnboundedViewport`1.ToString(System.Int32,System.Func{`0,System.String})">
            <summary>
            Prints the values in the UnboundedViewport, using the function specified to turn elements into
            strings, and using the "field length" specified.
            </summary>
            <remarks>
            Each element of type T will have spaces added to cause it to take up exactly
            <paramref name="fieldSize"/> characters, provided <paramref name="fieldSize"/> 
            is less than the length of the element's string represention.
            </remarks>
            <param name="fieldSize">
            The size of the field to give each value.  A positive-number
            right-aligns the text within the field, while a negative number left-aligns the text.
            </param>
            <param name="elementStringifier">
            Function to use to convert each element to a string. null defaults to the ToString
            function of type T.
            </param>
            <returns>A string representation of the UnboundedViewport.</returns>
        </member>
        <member name="T:GoRogue.MapViews.Viewport`1">
            <summary>
            Viewport is a class that effectively creates and maintains a "viewport", or subsection, of the map.
            Its indexers perform relative to absolute coordinate translations, and return the proper value of
            type T from the underlying map.
            </summary>
            <remarks>
            Since some algorithms that use <see cref="T:GoRogue.MapViews.IMapView`1"/> implementations can be expensive to
            run on large maps (GoalMaps, etc), you can use viewports to present only a relevant subsection of the
            map to that algorithm.  It is generally useful for any case where you want an <see cref="T:GoRogue.MapViews.IMapView`1"/>
            that represents a subsection of some other <see cref="T:GoRogue.MapViews.IMapView`1"/>.
            
            This implementation restricts the subsection of the map that is presented in such a way that no part
            of the viewport can be outside the boundary of its parent map view.  The viewport cannot be bigger than
            the map, and the viewport's position is "locked" to the edge so that it cannot be set in such a way that a portion
            of the viewport lies outside the bounds of the parent map.  If you would rather allow this and return
            a default value for locations outside the parent map, see <see cref="T:GoRogue.MapViews.UnboundedViewport`1"/>.
            </remarks>
            <typeparam name="T">The type being exposed by the Viewport.</typeparam>
        </member>
        <member name="M:GoRogue.MapViews.Viewport`1.#ctor(GoRogue.MapViews.IMapView{`0},GoRogue.Rectangle)">
            <summary>
            Constructor. Takes the parent map view, and the initial subsection of that map view to represent.
            </summary>
            <param name="mapView">The map view being represented.</param>
            <param name="viewArea">The initial subsection of that map to represent.</param>
        </member>
        <member name="M:GoRogue.MapViews.Viewport`1.#ctor(GoRogue.MapViews.IMapView{`0})">
            <summary>
            Constructor. Takes the map view to represent. The viewport will represent the entire given map view.
            </summary>
            <param name="mapView">The map view to represent.</param>
        </member>
        <member name="P:GoRogue.MapViews.Viewport`1.Height">
            <summary>
            The height of the area being represented.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.Viewport`1.MapView">
            <summary>
            The map view that this Viewport is exposing values from.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.Viewport`1.ViewArea">
            <summary>
            The area of <see cref="P:GoRogue.MapViews.Viewport`1.MapView"/> that this Viewport is exposing. Although this property does
            not explicitly expose a set accessor, it is returning a reference and as such may be
            assigned to. When accessed, the rectangle is automatically restricted by the edges of the
            map as necessary.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.Viewport`1.Width">
            <summary>
            The width of the area being represented.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.Viewport`1.Item(System.Int32)">
            <summary>
            Given a position in relative 1d-array-index style, returns the "value" associated with that
            location in absolute coordinates.
            </summary>
            <param name="relativeIndex1D">
            Viewport-relative position of the location to retrieve the value for, as a 1D array index.
            </param>
            <returns>
            The "value" associated with the absolute location represented on the underlying map view.
            </returns>
        </member>
        <member name="P:GoRogue.MapViews.Viewport`1.Item(GoRogue.Coord)">
            <summary>
            Given a position in relative coordinates, returns the "value" associated with that
            location in absolute coordinates.
            </summary>
            <param name="relativePosition">
            Viewport-relative position of the location to retrieve the value for.
            </param>
            <returns>
            The "value" associated with the absolute location represented on the underlying map view.
            </returns>
        </member>
        <member name="P:GoRogue.MapViews.Viewport`1.Item(System.Int32,System.Int32)">
            <summary>
            Given an X and Y value in relative coordinates, returns the "value" associated with that
            location in absolute coordinates.
            </summary>
            <param name="relativeX">Viewport-relative X-value of location.</param>
            <param name="relativeY">Viewport-relative Y-value of location.</param>
            <returns>
            The "value" associated with the absolute location represented on the underlying map view.
            </returns>
        </member>
        <member name="M:GoRogue.MapViews.Viewport`1.ToString">
            <summary>
            Returns a string representation of the Viewport.
            </summary>
            <returns>A string representation of the Viewport.</returns>
        </member>
        <member name="M:GoRogue.MapViews.Viewport`1.ToString(System.Func{`0,System.String})">
            <summary>
            Returns a string representation of the map view, using <paramref name="elementStringifier"/>
            to determine what string represents each value.
            </summary>
            <remarks>
            This could be used, for example, on a Viewport of boolean values, to output '#' for
            false values, and '.' for true values.
            </remarks>
            <param name="elementStringifier">
            Function determining the string representation of each element.
            </param>
            <returns>A string representation of the Viewport.</returns>
        </member>
        <member name="M:GoRogue.MapViews.Viewport`1.ToString(System.Int32,System.Func{`0,System.String})">
            <summary>
            Prints the values in the Viewport, using the function specified to turn elements into
            strings, and using the "field length" specified.
            </summary>
            <remarks>
            Each element of type T will have spaces added to cause it to take up exactly
            <paramref name="fieldSize"/> characters, provided <paramref name="fieldSize"/> 
            is less than the length of the element's string represention.
            </remarks>
            <param name="fieldSize">
            The size of the field to give each value.  A positive-number
            right-aligns the text within the field, while a negative number left-aligns the text.
            </param>
            <param name="elementStringifier">
            Function to use to convert each element to a string. null defaults to the ToString
            function of type T.
            </param>
            <returns>A string representation of the Viewport.</returns>
        </member>
        <member name="T:GoRogue.MathHelpers">
            <summary>
            Static class consisting of mathematical "helper" functions and constants -- things like angle
            unit conversions, and other helpful functions.
            </summary>
        </member>
        <member name="F:GoRogue.MathHelpers.DEGREE_PCT_OF_CIRCLE">
            <summary>
            Result of 1/360; represents in decimal form a percent of a circle that a degree constitutes.
            </summary>
        </member>
        <member name="M:GoRogue.MathHelpers.RoundToMultiple(System.Int32,System.Int32)">
            <summary>
            Rounds the given number up (toward highest number), to the nearest multiple of the
            specified value.
            </summary>
            <param name="number">Number to round.</param>
            <param name="toMultipleOf">Number given is rounded up to nearest multiple of this number.</param>
            <returns>The number parameter, rouded up to the nearest multiple of <paramref name="toMultipleOf"/>.</returns>
        </member>
        <member name="M:GoRogue.MathHelpers.ToDegree(System.Double)">
            <summary>
            Converts given angle from radians to degrees.
            </summary>
            <param name="radAngle">Angle in radians.</param>
            <returns>The given angle in degrees.</returns>
        </member>
        <member name="M:GoRogue.MathHelpers.ToRadian(System.Double)">
            <summary>
            Converts given angle from degrees to radians.
            </summary>
            <param name="degAngle">Angle in degrees.</param>
            <returns>The given angle in radians.</returns>
        </member>
        <member name="M:GoRogue.MathHelpers.WrapAround(System.Int32,System.Int32)">
            <summary>
            A modified modulo operator, which practically differs from <paramref name="num"/> / <paramref name="wrapTo"/>
            in that it wraps from 0 to <paramref name="wrapTo"/> - 1, as well as from <paramref name="wrapTo"/> - 1 to 0.
            </summary>
            <remarks>
            A modified modulo operator. Returns the result of  the formula
            (<paramref name="num"/> % <paramref name="wrapTo"/> + <paramref name="wrapTo"/>) % <paramref name="wrapTo"/>.
            
            Practically it differs from regular modulo in that the values it returns when negative values for <paramref name="num"/>
            are wrapped around like one would want an array index to (if wrapTo is list.length, -1 wraps to list.length - 1). For example,
            0 % 3 = 0, -1 % 3 = -1, -2 % 3 = -2, -3 % 3 = 0, and so forth, but WrapTo(0, 3) = 0,
            WrapTo(-1, 3) = 2, WrapTo(-2, 3) = 1, WrapTo(-3, 3) = 0, and so forth. This can be useful if you're
            trying to "wrap" a number around at both ends, for example wrap to 3, such that 3 wraps
            to 0, and -1 wraps to 2. This is common if you are wrapping around an array index to the
            length of the array and need to ensure that positive numbers greater than or equal to the
            length of the array wrap to the beginning of the array (index 0), AND that negative
            numbers (under 0) wrap around to the end of the array (Length - 1).
            </remarks>
            <param name="num">The number to wrap.</param>
            <param name="wrapTo">
            The number to wrap to -- the result of the function is as outlined in function
            description, and guaranteed to be between [0, wrapTo - 1], inclusive.
            </param>
            <returns>
            The wrapped result, as outlined in function description. Guaranteed to lie in range [0,
            wrapTo - 1], inclusive.
            </returns>
        </member>
        <member name="M:GoRogue.MathHelpers.ScaledAtan2Approx(System.Double,System.Double)">
            <summary>
            Approximation of the Atan2 function that scales the returned value to the range [0.0, 1.0], in order to remain
            agnostic of units (radius vs degrees).  It will never return a negative number, so is also useful to avoid floating-point
            modulus.  Credit to the SquidLib java RL library and <a href="https://math.stackexchange.com/a/1105038">this suggestion
            from user njuffa</a> for this math.
            </summary>
            <param name="y">Y-component of point to find angle towards.</param>
            <param name="x">X-component of point to find angle towards.</param>
            <returns>A value representing the angle to the given point, scaled to range [0.0, 1.0].</returns>
        </member>
        <member name="T:GoRogue.Messaging.ISubscriber`1">
            <summary>
            Interface representing subscribers to messages sent over a <see cref="T:GoRogue.Messaging.MessageBus"/>.  Classes wishing to respond to one or more message types as they are sent across
            the bus should implement this interface.
            </summary>
            <remarks>
            It is possible to have one class handle two different event types, by having it implement multiple ISubscriber types, passing different types as TMessage.
            When this is performed, however, the compiler will be unable to automatically resolve the template parameter of <see cref="M:GoRogue.Messaging.MessageBus.RegisterSubscriber``1(GoRogue.Messaging.ISubscriber{``0})"/>,
            so it will need to be specified manually.  Further, the RegisterSubscriber function will need to be called once for each ISubscriber type the class implements.
            <example>
            In this example, MultipleSubscriber wants to respond to messages of both type string and string[], without using any component classes or any such method of splitting
            up the implementations.  Thus, we implement the appropriate ISubscriber interfaces, and call the message bus's
            <see cref="M:GoRogue.Messaging.MessageBus.RegisterSubscriber``1(GoRogue.Messaging.ISubscriber{``0})"/> function once for each interface, explicitly specifying the type.
            <code>
            class MultipleSubscriber : ISubscriber&lt;string&gt;, ISubscriber&lt;string[]&gt;
            {
            	/* Explicit interface definitions are not required but are recommened for code clarity
            	void ISubscriber&lt;string&gt;.Handle(string message) => Console.WriteLine(message);
            	void ISubscriber&lt;string[]&gt;.Handle(string[] message) => Console.WriteLine(message.ExtendToString());
            }
            
            /* Later, when we add the subscriber to our message bus, we add each subscriber interface seperately */
            var messageBus = new MessageBus();
            var multiSubber = new MultipleSubscriber();
            messageBus.RegisterSubscriber&lt;string&gt;(multiSubber);
            messageBus.RegisterSubscriber&lt;string[]&gt;(multiSubber);
            </code>
            </example>
            </remarks>
            <typeparam name="TMessage">The type of message that the subscriber wants to handle.  Any and all messages sent over the event bus you subscribe to
            that can cast to this type will be passed the <see cref="M:GoRogue.Messaging.ISubscriber`1.Handle(`0)"/> function when they are sent.</typeparam>
        </member>
        <member name="M:GoRogue.Messaging.ISubscriber`1.Handle(`0)">
            <summary>
            Function that should handle the specified type of message in whatever manner it needs to.  Called automatically any time a message is sent
            over an event bus this subscriber has been registered on.
            </summary>
            <param name="message">Message that was sent.</param>
        </member>
        <member name="T:GoRogue.Messaging.MessageBus">
            <summary>
            A messaging system that can have subscribers added to it, and send messages.  When messages are sent, it will call any handlers that requested to handle messages
            of the proper types, based on the type-tree/interface-tree of the messages.
            </summary>
        </member>
        <member name="P:GoRogue.Messaging.MessageBus.SubscriberCount">
            <summary>
            Number of subscribers currently listening on this message bus.
            </summary>
        </member>
        <member name="M:GoRogue.Messaging.MessageBus.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GoRogue.Messaging.MessageBus.RegisterSubscriber``1(GoRogue.Messaging.ISubscriber{``0})">
            <summary>
            Adds the given subscriber to the message bus's handlers list, so its Handle function will be called when any messages
            that can cast to <typeparamref name="TMessage"/> are sent via the <see cref="M:GoRogue.Messaging.MessageBus.Send``1(``0)"/> function.
            Particularly when a handler is intended to have a shorter lifespan than the message bus, they MUST be unregistered via
            <see cref="M:GoRogue.Messaging.MessageBus.UnregisterSubscriber``1(GoRogue.Messaging.ISubscriber{``0})"/> when they are disposed of, to avoid the bus preventing
            the handler from being garbage collected.
            </summary>
            <typeparam name="TMessage">Type of message the subscriber is handling.  This can typically be inferred by the compiler,
            barring the case detailed in the <see cref="T:GoRogue.Messaging.ISubscriber`1"/> remarks where one class subscribes to multiple message types.</typeparam>
            <param name="subscriber">Subscriber to add.</param>
            <returns>The subscriber that was added, in case a reference is needed to later call <see cref="M:GoRogue.Messaging.MessageBus.UnregisterSubscriber``1(GoRogue.Messaging.ISubscriber{``0})"/>.</returns>
        </member>
        <member name="M:GoRogue.Messaging.MessageBus.UnregisterSubscriber``1(GoRogue.Messaging.ISubscriber{``0})">
            <summary>
            Removes the given subscriber from the message bus's handlers list.  Particularly when a subscriber is intended to have a shorter lifetime than the
            MessageBus object it subscribed with, handlers MUST be removed when disposed of so they can be garbage collected -- an object cannot be garbage-collected
            so long as it is registered as a subscriber to a message bus (unless the bus is also being garbage-collected).
            </summary>
            <typeparam name="TMessage">Type of message the subscriber is handling.  This can typically be inferred by the compiler,
            barring the case detailed in the <see cref="T:GoRogue.Messaging.ISubscriber`1"/> remarks where one class subscribes to multiple message types.</typeparam>
            <param name="subscriber">Subscriber to remove.</param>
        </member>
        <member name="M:GoRogue.Messaging.MessageBus.Send``1(``0)">
            <summary>
            Sends the specified message on the message bus, automatically calling any appropriate registered handlers.
            </summary>
            <typeparam name="TMessage"></typeparam>
            <param name="message"></param>
        </member>
        <member name="T:GoRogue.AdvancedMultiSpatialMap`1">
            <summary>
            A more complex version of <see cref="T:GoRogue.MultiSpatialMap`1"/> that does not require the items in it to implement
            <see cref="T:GoRogue.IHasID"/>, instead requiring the specification of a custom <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to use
            for hashing and comparison of items.
            </summary>
            <remarks>
            This class is useful for cases where you do not want to implement <see cref="T:GoRogue.IHasID"/>, or if you need
            to use a value type in a spatial map. For simple cases, it is recommended to use <see cref="T:GoRogue.MultiSpatialMap`1"/>
            instead.
            
            Be mindful of the efficiency of your hashing function specified in the <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> --
            it will in large part determine the performance of AdvancedMultiSpatialMap!
            </remarks>
            <typeparam name="T">The type of object that will be contained by this AdvancedMultiSpatialMap.</typeparam>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="comparer">
            Equality comparer to use for comparison and hashing of type T. Be especially mindful of the
            efficiency of its GetHashCode function, as it will determine the efficiency of many
            AdvancedMultiSpatialMap functions.
            </param>
            <param name="initialCapacity">
            The initial maximum number of elements the AdvancedMultiSpatialMap can hold before it has to
            internally resize data structures. Defaults to 32.
            </param>
        </member>
        <member name="E:GoRogue.AdvancedMultiSpatialMap`1.ItemAdded">
            <summary>
            See <see cref="E:GoRogue.IReadOnlySpatialMap`1.ItemAdded"/>.
            </summary>
        </member>
        <member name="E:GoRogue.AdvancedMultiSpatialMap`1.ItemMoved">
            <summary>
            See <see cref="E:GoRogue.IReadOnlySpatialMap`1.ItemMoved"/>.
            </summary>
        </member>
        <member name="E:GoRogue.AdvancedMultiSpatialMap`1.ItemRemoved">
            <summary>
            See <see cref="E:GoRogue.IReadOnlySpatialMap`1.ItemRemoved"/>.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedMultiSpatialMap`1.Count">
            <summary>
            See <see cref="P:GoRogue.IReadOnlySpatialMap`1.Count"/>.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedMultiSpatialMap`1.Items">
            <summary>
            See <see cref="P:GoRogue.IReadOnlySpatialMap`1.Items"/>.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedMultiSpatialMap`1.Positions">
            <summary>
            See <see cref="P:GoRogue.IReadOnlySpatialMap`1.Positions"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Add(`0,GoRogue.Coord)">
            <summary>
            Adds the given item at the given position, provided the item is not already in the
            spatial map. If the item is already contained in it, does nothing and returns false.
            Otherwise (if item was successfully added), returns true.
            </summary>
            <param name="newItem">The item to add.</param>
            <param name="position">The position at which to add the new item.</param>
            <returns>True if the item was added, false if the add operation failed.</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Add(`0,System.Int32,System.Int32)">
            <summary>
            Adds the given item at the given position, provided the item is not already in the
            spatial map. If the item is already contained in it, does nothing and returns false.
            Otherwise (if item was successfully added), returns true.
            </summary>
            <param name="newItem">The item to add.</param>
            <param name="x">x-value of the position to add item to.</param>
            <param name="y">y-value of the position to add item to.</param>
            <returns>True if the item was added, false if the add operation failed.</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.AsReadOnly">
            <summary>
            See <see cref="M:GoRogue.IReadOnlySpatialMap`1.AsReadOnly"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Clear">
            <summary>
            See <see cref="M:GoRogue.ISpatialMap`1.Clear"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Contains(`0)">
            <summary>
            See <see cref="M:GoRogue.IReadOnlySpatialMap`1.Contains(`0)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Contains(GoRogue.Coord)">
            <summary>
            See <see cref="M:GoRogue.IReadOnlySpatialMap`1.Contains(GoRogue.Coord)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Contains(System.Int32,System.Int32)">
            <summary>
            See <see cref="M:GoRogue.IReadOnlySpatialMap`1.Contains(System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.GetEnumerator">
            <summary>
            Used by foreach loop, so that the class will give ISpatialTuple objects when used in a
            foreach loop. Generally should never be called explicitly.
            </summary>
            <returns>An enumerator for the spatial map.</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Non-generic verion of enumerable used by foreach loop internally.
            </summary>
            <returns>Enumerator of ISpatialTuples.</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.GetItems(GoRogue.Coord)">
            <summary>
            See <see cref="M:GoRogue.IReadOnlySpatialMap`1.GetItems(GoRogue.Coord)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.GetItems(System.Int32,System.Int32)">
            <summary>
            See <see cref="M:GoRogue.IReadOnlySpatialMap`1.GetItems(System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.GetPosition(`0)">
            <summary>
            <see cref="M:GoRogue.IReadOnlySpatialMap`1.GetPosition(`0)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Move(`0,GoRogue.Coord)">
            <summary>
            Moves the item specified to the position specified. If the item does not exist in the
            spatial map, the function does nothing and returns false. Otherwise, returns true.
            </summary>
            <param name="item">The item to move.</param>
            <param name="target">The position to move it to.</param>
            <returns>True if the item was moved, false if the move failed.</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Move(`0,System.Int32,System.Int32)">
            <summary>
            Move the item specified to the position specified.  If the
            item does not exist in the spatial map, the function does nothing and
            returns false. Otherwise, returns true.
            </summary>
            <param name="item">The item to move.</param>
            <param name="targetX">X-value of the location to move it to.</param>
            <param name="targetY">Y-value of the location to move it to.</param>
            <returns>True if the item was moved, false if the move failed.</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Move(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Moves everything at <paramref name="current"/>, if anything, to <paramref name="target"/>.
            If something was moved, returns everything that was moved. If nothing was moved, eg. there
            was nothing at <paramref name="current"/>, returns nothing.
            </summary>
            <param name="current">The position of the items to move.</param>
            <param name="target">The position to move the item to.</param>
            <returns>The items moved if something was moved, or nothing if no item was moved.</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Move(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Moves whatever is at the "current" position specified, if anything, to the "target" position.
            If something was moved, returns what was moved. If nothing was moved, eg. there was nothing
            at the "current" position given, returns nothing.
            </summary>
            <param name="currentX">X-value of the location to move items from.</param>
            <param name="currentY">Y-value of the location to move items from.</param>
            <param name="targetX">X-value of the location to move items to.</param>
            <param name="targetY">Y-value of the location to move items to.</param>
            <returns>The items moved if something was moved, or nothing if no item was moved.</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Remove(`0)">
            <summary>
            Removes the item specified, if it exists, and returns true. Returns false if the item was
            not in the spatial map.
            </summary>
            <param name="item">The item to remove.</param>
            <returns>True if the item was removed, false if the item was not found.</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Remove(GoRogue.Coord)">
            <summary>
            Removes everything at the given position, and returns the items removed.
            Returns nothing if no items were at the position specified.
            </summary>
            <param name="position">The position of the item to remove.</param>
            <returns>
            The items removed, if any were removed; nothing if no items were found at that position.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Remove(System.Int32,System.Int32)">
            <summary>
            Removes everything at the given position, and returns the items removed.
            Returns nothing if no item was at the position specified.
            </summary>
            <param name="x">X-value of the position to remove items from.</param>
            <param name="y">Y-value of the position to remove items from.</param>
            <returns>
            The items removed, if any were removed; nothing if no items were found at that position.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.ToString(System.Func{`0,System.String})">
            <summary>
            Returns a string representation of the spatial map, allowing display of the
            spatial map's items in a specified way.
            </summary>
            <param name="itemStringifier">Function that turns an item into a string.</param>
            <returns>A string representation of the spatial map.</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.ToString">
            <summary>
            Returns a string representation of the spatial map.
            </summary>
            <returns>A string representation of the spatial map.</returns>
        </member>
        <member name="T:GoRogue.MultiSpatialMap`1">
            <summary>
            An implementation of <see cref="T:GoRogue.ISpatialMap`1"/> that allows multiple items to reside
            at any given position at the same time.  If you wish to allow only one item to reside
            at each location at a time, use <see cref="T:GoRogue.SpatialMap`1"/> instead.  For a situation
            involving different categories or layers of items, you may want to look at
            <see cref="T:GoRogue.LayeredSpatialMap`1"/>.
            </summary>
            <remarks>
            See the <see cref="T:GoRogue.ISpatialMap`1"/> for documentation on the practical purpose of spatial
            maps.
            
            The objects stored in a MultiSpatialMap must implement <see cref="T:GoRogue.IHasID"/>. This is used
            internally to keep track of the objects, since uints are easily (and efficiently) hashable.
            
            Although MultiSpatialMap is generally quite performant, if you know the spatial map will
            only have one item at any given position at a time, <see cref="T:GoRogue.SpatialMap`1"/> may yield
            better performance.
            </remarks>
            <typeparam name="T">
            The type of items being stored in the spatial map. Must implement <see cref="T:GoRogue.IHasID"/> and be
            a reference-type.
            </typeparam>
        </member>
        <member name="M:GoRogue.MultiSpatialMap`1.#ctor(System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="initialCapacity">
            The initial maximum number of elements the spatial map can hold before it has to
            internally resize data structures. Defaults to 32.
            </param>
        </member>
        <member name="T:GoRogue.Pathing.AStar">
            <summary>
            Implements an optimized AStar pathfinding algorithm. Optionally supports custom heuristics, and custom weights for each tile.
            </summary>
            <remarks>
            Like most GoRogue algorithms, AStar takes as a construction parameter an IMapView representing the map. 
            Specifically, it takes an <see cref="T:GoRogue.MapViews.IMapView`1"/>, where true indicates that a tile should be
            considered walkable, and false indicates that a tile should be considered impassable.
            
            For details on the map view system in general, see <see cref="T:GoRogue.MapViews.IMapView`1"/>.  As well, there is an article
            explaining the map view system at the GoRogue documentation page
            <a href="https://chris3606.github.io/GoRogue/articles">here</a>
            
            If truly shortest paths are not strictly necessary, you may want to consider <see cref="T:GoRogue.Pathing.FastAStar"/> instead.
            </remarks>
        </member>
        <member name="P:GoRogue.Pathing.AStar.DistanceMeasurement">
            <summary>
            The distance calculation being used to determine distance between points. <see cref="F:GoRogue.Distance.MANHATTAN"/>
            implies 4-way connectivity, while <see cref="F:GoRogue.Distance.CHEBYSHEV"/> or <see cref="F:GoRogue.Distance.EUCLIDEAN"/> imply
            8-way connectivity for the purpose of determining adjacent coordinates.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.AStar.WalkabilityMap">
            <summary>
            The map view being used to determine whether or not each tile is walkable.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.AStar.Heuristic">
            <summary>
            The heuristic used to estimate distance from nodes to the end point.  If unspecified or specified as null,
            it defaults to using the distance calculation specified by <see cref="P:GoRogue.Pathing.AStar.DistanceMeasurement"/>, with a safe/efficient
            tie-breaking multiplier added on.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.AStar.Weights">
            <summary>
            Weights given to each tile.  The weight is multiplied by the cost of a tile, so a tile with weight 2 is twice as hard to
            enter as a tile with weight 1.  If unspecified or specified as null, all tiles have weight 1.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.AStar.MaxEuclideanMultiplier">
            <summary>
            Multiplier that is used in the tiebreaking/smoothing element of the default heuristic. This value is based on the
            maximum possible <see cref="M:GoRogue.Coord.EuclideanDistanceMagnitude(GoRogue.Coord,GoRogue.Coord)"/> between two points on the map.
            
            Typically you dont' need this value unless you're creating a custom heuristic an introducing the same
            tiebreaking/smoothing element as the default heuristic.
            </summary>
        </member>
        <member name="F:GoRogue.Pathing.AStar.MinimumWeight">
            <summary>
            The minimum value that is allowed to occur in the <see cref="P:GoRogue.Pathing.AStar.Weights"/> map view.  This value is only used with the default heuristic
            for AStar and <see cref="T:GoRogue.Pathing.FastAStar"/>, so if a custom heuristic is used, the value is also ignored.  Must be greater than 0.0 and less
            than or equal to the minimum value in the <see cref="P:GoRogue.Pathing.AStar.Weights"/> map view.  Defaults to 1.0 in cases where the default heuristic is used.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.AStar.#ctor(GoRogue.MapViews.IMapView{System.Boolean},GoRogue.Distance)">
            <summary>
            Constructor.  Uses a default heuristic corresponding to the distance calculation given, along with a safe/efficient
            tiebreaking/smoothing element which will produce guaranteed shortest paths.
            </summary>
            <param name="walkabilityMap">Map view used to deterine whether or not each location can be traversed -- true indicates a tile can be traversed,
            and false indicates it cannot.</param>
            <param name="distanceMeasurement">Distance calculation used to determine whether 4-way or 8-way connectivity is used, and to determine
            how to calculate the distance between points.</param>
        </member>
        <member name="M:GoRogue.Pathing.AStar.#ctor(GoRogue.MapViews.IMapView{System.Boolean},GoRogue.Distance,System.Func{GoRogue.Coord,GoRogue.Coord,System.Double})">
            <summary>
            Constructor.
            </summary>
            <param name="walkabilityMap">Map view used to deterine whether or not each location can be traversed -- true indicates a tile can be traversed,
            and false indicates it cannot.</param>
            <param name="distanceMeasurement">Distance calculation used to determine whether 4-way or 8-way connectivity is used, and to determine
            how to calculate the distance between points.</param>
            <param name="heuristic">Function used to estimate the distance between two given points.</param>
        </member>
        <member name="M:GoRogue.Pathing.AStar.#ctor(GoRogue.MapViews.IMapView{System.Boolean},GoRogue.Distance,GoRogue.MapViews.IMapView{System.Double},System.Double)">
            <summary>
            Constructor.  Uses a default heuristic corresponding to the distance calculation given, along with a safe/efficient
            tiebreaking/smoothing element which will produce guaranteed shortest paths, provided <paramref name="minimumWeight"/> is correct.
            </summary>
            <param name="walkabilityMap">Map view used to deterine whether or not each location can be traversed -- true indicates a tile can be traversed,
            and false indicates it cannot.</param>
            <param name="distanceMeasurement">Distance calculation used to determine whether 4-way or 8-way connectivity is used, and to determine
            how to calculate the distance between points.</param>
            <param name="weights">A map view indicating the weights of each location (see <see cref="P:GoRogue.Pathing.AStar.Weights"/>.</param>
            <param name="minimumWeight">The minimum value that will be present in <paramref name="weights"/>.  It must be greater than 0.0 and
            must be less than or equal to the minimum value present in the weights view -- the algorithm may not produce truly shortest paths if
            this condition is not met.  If this minimum changes after construction, it may be updated via the <see cref="F:GoRogue.Pathing.AStar.MinimumWeight"/> property.</param>
        </member>
        <member name="M:GoRogue.Pathing.AStar.#ctor(GoRogue.MapViews.IMapView{System.Boolean},GoRogue.Distance,System.Func{GoRogue.Coord,GoRogue.Coord,System.Double},GoRogue.MapViews.IMapView{System.Double})">
            <summary>
            Constructor.
            </summary>
            <param name="walkabilityMap">Map view used to deterine whether or not each location can be traversed -- true indicates a tile can be traversed,
            and false indicates it cannot.</param>
            <param name="distanceMeasurement">Distance calculation used to determine whether 4-way or 8-way connectivity is used, and to determine
            how to calculate the distance between points.</param>
            <param name="heuristic">Function used to estimate the distance between two given points.</param>
            <param name="weights">A map view indicating the weights of each location (see <see cref="P:GoRogue.Pathing.AStar.Weights"/>.</param>
        </member>
        <member name="M:GoRogue.Pathing.AStar.ShortestPath(GoRogue.Coord,GoRogue.Coord,System.Boolean)">
            <summary>
            Finds the shortest path between the two specified points.
            </summary>
            <remarks>
            Returns <see langword="null"/> if there is no path between the specified points. Will still return an
            appropriate path object if the start point is equal to the end point.
            </remarks>
            <param name="start">The starting point of the path.</param>
            <param name="end">The ending point of the path.</param>
            <param name="assumeEndpointsWalkable">
            Whether or not to assume the start and end points are walkable, regardless of what the
            <see cref="P:GoRogue.Pathing.AStar.WalkabilityMap"/> reports. Defaults to <see langword="true"/>.
            </param>
            <returns>The shortest path between the two points, or <see langword="null"/> if no valid path exists.</returns>
        </member>
        <member name="M:GoRogue.Pathing.AStar.ShortestPath(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Finds the shortest path between the two specified points.
            </summary>
            <remarks>
            Returns <see langword="null"/> if there is no path between the specified points. Will still return an
            appropriate path object if the start point is equal to the end point.
            </remarks>
            <param name="startX">The x-coordinate of the starting point of the path.</param>
            <param name="startY">The y-coordinate of the starting point of the path.</param>
            <param name="endX">The x-coordinate of the ending point of the path.</param>
            <param name="endY">The y-coordinate of the ending point of the path.</param>
            <param name="assumeEndpointsWalkable">
            Whether or not to assume the start and end points are walkable, regardless of what the
            <see cref="P:GoRogue.Pathing.AStar.WalkabilityMap"/> reports. Defaults to <see langword="true"/>.
            </param>
            <returns>The shortest path between the two points, or <see langword="null"/> if no valid path exists.</returns>
        </member>
        <member name="T:GoRogue.Pathing.Path">
            <summary>
            Encapsulates a path as returned by pathfinding algorithms like AStar.
            </summary>
            <remarks>
            Provides various functions to iterate through/access steps of the path, as well as
            constant-time reversing functionality.
            </remarks>
        </member>
        <member name="M:GoRogue.Pathing.Path.#ctor(GoRogue.Pathing.Path,System.Boolean)">
            <summary>
            Creates a copy of the path, optionally reversing the path as it does so.
            </summary>
            <remarks>Reversing is an O(1) operation, since it does not modify the list.</remarks>
            <param name="pathToCopy">The path to copy.</param>
            <param name="reverse">Whether or not to reverse the path. Defaults to <see langword="false"/>.</param>
        </member>
        <member name="P:GoRogue.Pathing.Path.End">
            <summary>
            Ending point of the path.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.Path.Length">
            <summary>
            The length of the path, NOT including the starting point.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.Path.LengthWithStart">
            <summary>
            The length of the path, INCLUDING the starting point.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.Path.Start">
            <summary>
            Starting point of the path.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.Path.Steps">
            <summary>
            The coordinates that constitute the path (in order), NOT including the starting point.
            These are the coordinates something might walk along to follow a path.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.Path.StepsWithStart">
            <summary>
            The coordinates that constitute the path (in order), INCLUDING the starting point.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.Path.GetStep(System.Int32)">
            <summary>
            Gets the nth step along the path, where 0 is the step AFTER the starting point.
            </summary>
            <param name="stepNum">The (array-like index) of the step to get.</param>
            <returns>The coordinate consituting the step specified.</returns>
        </member>
        <member name="M:GoRogue.Pathing.Path.GetStepWithStart(System.Int32)">
            <summary>
            Gets the nth step along the path, where 0 IS the starting point.
            </summary>
            <param name="stepNum">The (array-like index) of the step to get.</param>
            <returns>The coordinate consituting the step specified.</returns>
        </member>
        <member name="M:GoRogue.Pathing.Path.Reverse">
            <summary>
            Reverses the path, in constant time.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.Path.ToString">
            <summary>
            Returns a string representation of all the steps in the path, including the start point,
            eg. [(1, 2), (3, 4), (5, 6)].
            </summary>
            <returns>A string representation of all steps in the path, including the start.</returns>
        </member>
        <member name="T:GoRogue.Pathing.FastAStar">
            <summary>
            A version of <see cref="T:GoRogue.Pathing.AStar"/> that may perform significantly faster, in exchange for not being guaranteed to always produce a shortest path.  A 
            valid path will still be produced, but it is not guaranteed to be the shortest possible.
            </summary>
            <remarks>
            This class is exactly like a regular <see cref="T:GoRogue.Pathing.AStar"/> instance, but sets the heuristic by default to the <see cref="F:GoRogue.Distance.MANHATTAN"/>
            calculate function (with the same tiebreaking/smoothing element as regular AStar. In the case that euclidean or chebyshev distance is used, this
            heuristic is over-estimating -- that is, it may in some cases produce a value that is greater than the actual shortest path between two points.
            As such, this means that, while the algorithm will still produce valid paths, the algorithm is no longer guaranteed to produce fully shortest paths.
            In exchange, however, the algorithm may perform significantly faster than an AStar instance with its default heuristic.
            
            In practice, however, it is worth noting that the paths are often (though not always) the shortest path regardless, and when they are not, the deviation
            in length between the path that the algorithm returns and the actual shortest path is often very small (less than 5%).  As such, it may be viable for use
            in most cases.
            </remarks>
        </member>
        <member name="M:GoRogue.Pathing.FastAStar.#ctor(GoRogue.MapViews.IMapView{System.Boolean},GoRogue.Distance)">
            <summary>
            Constructor.
            </summary>
            <param name="walkabilityMap">Map view used to deterine whether or not each location can be traversed -- true indicates a tile can be traversed,
            and false indicates it cannot.</param>
            <param name="distanceMeasurement">Distance calculation used to determine whether 4-way or 8-way connectivity is used, and to determine
            how to calculate the distance between points.</param>
        </member>
        <member name="M:GoRogue.Pathing.FastAStar.#ctor(GoRogue.MapViews.IMapView{System.Boolean},GoRogue.Distance,GoRogue.MapViews.IMapView{System.Double},System.Double)">
            <summary>
            
            </summary>
            <param name="walkabilityMap"></param>
            <param name="distanceMeasurement"></param>
            <param name="weights">A map view indicating the weights of each location (see <see cref="P:GoRogue.Pathing.AStar.Weights"/>.</param>
            <param name="minimumWeight">The minimum value that will be present in <paramref name="weights"/>.  It must be greater than 0.0 and
            must be less than or equal to the minimum value present in the weights view -- the algorithm may not produce truly shortest paths if
            this condition is not met.  If this minimum changes after construction, it may be updated via the <see cref="F:GoRogue.Pathing.AStar.MinimumWeight"/> property.</param>
        </member>
        <member name="T:GoRogue.Pathing.FleeMap">
            <summary>
            Implements the concept of a "safety map", also known as "flee map", as described in the
            <a href="http://www.roguebasin.com/index.php?title=The_Incredible_Power_of_Dijkstra_Maps">this article</a>.
            </summary>
            <remarks>
            Takes a goal map, wherein any goals are treated as "threats" to be avoided. Automatically
            recalculated when the underlying goal map is recalculated. Implements IDisposable, so ensure
            that it is disposed of properly after use.
            </remarks>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.#ctor(GoRogue.Pathing.GoalMap,System.Double)">
            <summary>
            Constructor. Takes a goal map where in all goals are treated as threats to be avoided,
            and a magnitude to use (defaulting to 1.2).
            </summary>
            <param name="baseMap">The underlying goal map to use.</param>
            <param name="magnitude">Magnitude to multiply by during calculation.</param>
        </member>
        <member name="P:GoRogue.Pathing.FleeMap.Height">
            <summary>
            Height of the flee map.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.FleeMap.Magnitude">
            <summary>
            The degree to which entities following this flee-map will prefer global safety to local
            safety. Higher values will make entities try to move past an approaching "threat" from
            farther away.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.FleeMap.Width">
            <summary>
            Width of the flee map.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.FleeMap.Item(System.Int32)">
            <summary>
            Returns the flee-map value for the given position.
            </summary>
            <param name="index1D">The position to return the value for, as a 1D-array-style index.</param>
            <returns>The flee-map value for the given location.</returns>
        </member>
        <member name="P:GoRogue.Pathing.FleeMap.Item(GoRogue.Coord)">
            <summary>
            Returns the flee-map value for the given position.
            </summary>
            <param name="pos">The position to return the value for.</param>
            <returns>The flee-map value for the given location.</returns>
        </member>
        <member name="P:GoRogue.Pathing.FleeMap.Item(System.Int32,System.Int32)">
            <summary>
            Returns the goal-map value for the given position.
            </summary>
            <param name="x">The x-value of the position to return the value for.</param>
            <param name="y">The y-value of the position to return the value for.</param>
            <returns>The flee-map value for the given location.</returns>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.GetDirectionOfMinValue(GoRogue.Coord)">
            <summary>
            Gets the direction of the neighbor with the minimum flee-map value from the given position.
            </summary>
            <param name="position">The position to get the minimum value for.</param>
            <returns>
            The direction that has the minimum value in the goal-map, or <see cref="P:GoRogue.Direction.NONE"/> if the
            neighbors are all obstacles.
            </returns>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.GetDirectionOfMinValue(System.Int32,System.Int32)">
            <summary>
            Gets the direction of the neighbor with the minimum flee-map value from the given position.
            </summary>
            <param name="positionX">The x-value of the position to get the minimum value for.</param>
            <param name="positionY">The y-value of the position to get the minimum value for.</param>
            <returns>
            The direction that has the minimum value in the goal-map, or <see cref="P:GoRogue.Direction.NONE"/> if the
            neighbors are all obstacles.
            </returns>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.ToString">
            <summary>
            Returns the flee-map values represented as a 2D grid-style string.
            </summary>
            <returns>A string representing the flee map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.ToString(System.String)">
            <summary>
            Returns the flee-map values represented as a 2D-grid-style string, where any value that
            isn't null is formatted as per the specified format string.
            </summary>
            <param name="formatString">Format string to use for non-null values.</param>
            <returns>A string representing the flee-map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.ToString(System.Int32)">
            <summary>
            Returns the flee-map values represented as a 2D-grid-style string, with the given field size.
            </summary>
            <param name="fieldSize">Number of characters allocated to each value in the string.</param>
            <returns>A string representing the flee-map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.ToString(System.Int32,System.String)">
            <summary>
            Returns the flee-map values represented as a 2D-grid-style string, with the given field
            size, and any non-null values formatted using the given format string.
            </summary>
            <param name="fieldSize">Number of characters allocated to each value in the string.</param>
            <param name="formatString">Format string to use for non-null values.</param>
            <returns>A string representing the flee-map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.Finalize">
            <summary>
            Destructor for IDisposable implementation.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.Dispose">
            <summary>
            Function called to dispose of the class, automatically unlinking it from its goal map.
            </summary>
        </member>
        <member name="T:GoRogue.Pathing.GoalMap">
            <summary>
            Implementation of a goal map system, also known as Dijkstra maps,
            based on <a href="http://www.roguebasin.com/index.php?title=The_Incredible_Power_of_Dijkstra_Maps">this article</a>
            </summary>
            <remarks>
            This class encapsulates the work of building a goal map from your map level. You provide the
            constructor with a map view representing the map as <see cref="T:GoRogue.Pathing.GoalState"/> values, and
            GoalMap will compute the goal map for the level. When the underlying circumstances of the
            level change, the GoalMap instance will need to be updated. Call <see cref="M:GoRogue.Pathing.GoalMap.Update"/> if obstacles
            have changed, or <see cref="M:GoRogue.Pathing.GoalMap.UpdatePathsOnly"/> if the goals have changed but not the obstacles.
            
            This class exposes the resulting goal map to you via indexers -- GoalMap implements
            <see cref="T:GoRogue.MapViews.IMapView`1"/>, where <see langword="null"/> indicates a square is an obstacle,
            and any other value indicates distance from the nearest goal.  Thus, a value of 0 indicates a tile
            contains a goal.
            
            For items following the GoalMap, they can simply call <see cref="M:GoRogue.Pathing.GoalMap.GetDirectionOfMinValue(GoRogue.Coord)"/>
            </remarks>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.#ctor(GoRogue.MapViews.IMapView{GoRogue.Pathing.GoalState},GoRogue.Distance)">
            <summary>
            Constructor. Takes a base map and a distance measurement to use for calculation.
            </summary>
            <param name="baseMap">A map view that represents the map as
            <see cref="T:GoRogue.MapViews.IMapView`1"/>GoalStates.</param>
            <param name="distanceMeasurement">
            The distance measurement (and implicitly the <see cref="T:GoRogue.AdjacencyRule"/>) to use for calculation.
            </param>
        </member>
        <member name="E:GoRogue.Pathing.GoalMap.Updated">
            <summary>
            Triggers when the GoalMap is updated.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.GoalMap.BaseMap">
            <summary>
            The map view of the underlying map used to determine where obstacles/goals are.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.GoalMap.DistanceMeasurement">
            <summary>
            The distance measurement the GoalMap is using to calculate distance.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.GoalMap.Height">
            <summary>
            Height of the goal map.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.GoalMap.Width">
            <summary>
            Width of the goal map.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.GoalMap.Item(System.Int32)">
            <summary>
            Returns the goal-map value for the given position.
            </summary>
            <param name="index1D">Position to return the goal-map value for, as a 1d-index-style value.</param>
            <returns>The goal-map value for the given position.</returns>
        </member>
        <member name="P:GoRogue.Pathing.GoalMap.Item(System.Int32,System.Int32)">
            <summary>
            Returns the goal-map value for the given position.
            </summary>
            <param name="x">X-coordinate of the position to return the goal-map value for.</param>
            <param name="y">Y-coordinate of the position to return the goal-map value for.</param>
            <returns>The goal-map value for the given position.</returns>
        </member>
        <member name="P:GoRogue.Pathing.GoalMap.Item(GoRogue.Coord)">
            <summary>
            Returns the goal-map value for the given position.
            </summary>
            <param name="pos">The position to return the goal-map value for.</param>
            <returns>The goal-map value for the given position.</returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.GetDirectionOfMinValue(GoRogue.Coord)">
            <summary>
            Gets the direction of the neighbor with the minimum goal-map value from the given position.
            </summary>
            <param name="position">The position to get the minimum value for.</param>
            <returns>
            The direction that has the minimum value in the goal-map, or <see cref="P:GoRogue.Direction.NONE"/> if the
            neighbors are all obstacles.
            </returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.GetDirectionOfMinValue(System.Int32,System.Int32)">
            <summary>
            Gets the direction of the neighbor with the minimum goal-map value from the given position.
            </summary>
            <param name="positionX">The x-value of the position to get the minimum value for.</param>
            <param name="positionY">The y-value of the position to get the minimum value for.</param>
            <returns>
            The direction that has the minimum value in the goal-map, or <see cref="P:GoRogue.Direction.NONE"/> if the
            neighbors are all obstacles.
            </returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.ToString">
            <summary>
            Returns the goal-map values represented as a 2D grid-style string.
            </summary>
            <returns>A string representing the goal map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.ToString(System.String)">
            <summary>
            Returns the goal-map values represented as a 2D-grid-style string, where any value that
            isn't null is formatted as per the specified format string.
            </summary>
            <param name="formatString">Format string to use for non-null values.</param>
            <returns>A string representing the goal-map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.ToString(System.Int32)">
            <summary>
            Returns the goal-map values represented as a 2D-grid-style string, with the given field size.
            </summary>
            <param name="fieldSize">Number of characters allocated to each value in the string.</param>
            <returns>A string representing the goal-map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.ToString(System.Int32,System.String)">
            <summary>
            Returns the goal-map values represented as a 2D-grid-style string, with the given field
            size, and any non-null values formatted using the given format string.
            </summary>
            <param name="fieldSize">Number of characters allocated to each value in the string.</param>
            <param name="formatString">Format string to use for non-null values.</param>
            <returns>A string representing the goal-map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.Update">
            <summary>
            Re-evaluates the entire goal map. Should be called when obstacles change. If the
            obstacles have not changed but the goals have, call <see cref="M:GoRogue.Pathing.GoalMap.UpdatePathsOnly"/> for better efficiency.
            </summary>
            <returns>False if no goals were produced by the evaluator, true otherwise</returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.UpdatePathsOnly">
            <summary>
            Re-evaluates the walkable portion of the goal map. Should be called anytime the goals change
            but the obstacles haven't.  If the obstacles have also changed, call <see cref="M:GoRogue.Pathing.GoalMap.Update"/> instead.
            </summary>
            <returns>False if no goals were produced by the evaluator, true otherwise</returns>
        </member>
        <member name="T:GoRogue.Pathing.GoalMapExtensions">
            <summary>
            Contains extensions for <see cref="T:GoRogue.MapViews.IMapView`1"/>, that pertain generally to goal maps.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.GoalMapExtensions.GetDirectionOfMinValue(GoRogue.MapViews.IMapView{System.Nullable{System.Double}},GoRogue.Coord,GoRogue.AdjacencyRule)">
            <summary>
            Gets the direction of the neighbor with the minimum goal-map value from the given position.
            </summary>
            <param name="goalMap"/>
            <param name="position">The position to get the minimum value for.</param>
            <param name="adjacencyRule">The adjacency rule to use to determine neighbors.</param>
            <returns>
            The direction that has the minimum value in the goal-map, or <see cref="P:GoRogue.Direction.NONE"/> if the
            neighbors are all obstacles.
            </returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMapExtensions.GetDirectionOfMinValue(GoRogue.MapViews.IMapView{System.Nullable{System.Double}},System.Int32,System.Int32,GoRogue.AdjacencyRule)">
            <summary>
            Gets the direction of the neighbor with the minimum goal-map value from the given position.
            </summary>
            <param name="goalMap"/>
            <param name="positionX">The x-value of the position to get the minimum value for.</param>
            <param name="positionY">The y-value of the position to get the minimum value for.</param>
            <param name="adjacencyRule">The adjacency rule to use to determine neighbors.</param>
            <returns>
            The direction that has the minimum value in the goal-map, or <see cref="P:GoRogue.Direction.NONE"/> if the
            neighbors are all obstacles.
            </returns>
        </member>
        <member name="T:GoRogue.Pathing.GoalState">
            <summary>
            Used to determine the status of a tile for goal-mapping purposes.
            </summary>
        </member>
        <member name="F:GoRogue.Pathing.GoalState.Obstacle">
            <summary>
            A tile that can't be entered and has to be routed around
            </summary>
        </member>
        <member name="F:GoRogue.Pathing.GoalState.Clear">
            <summary>
            A tile that can be entered
            </summary>
        </member>
        <member name="F:GoRogue.Pathing.GoalState.Goal">
            <summary>
            A destination on the goal map.
            </summary>
        </member>
        <member name="T:GoRogue.Pathing.WeightedGoalMap">
            <summary>
            Implementation of the second half of the goal map system described in
            <a href="http://www.roguebasin.com/index.php?title=The_Incredible_Power_of_Dijkstra_Maps">this article</a> --
            the ability to combine multiple goal maps with different weights.
            </summary>
            <remarks>
            This class encapsulates the work of building one overall goal map out of multiple existing
            maps. It holds references to one or more maps, each with its own "weight". The higher the
            weight value, the more strongly an AI will attempt to pursue this goal. A negative weight
            inverts the map, turning its goal into something to avoid.  Inverting the weight does not
            create a "safety map" as described in the article, as the resulting goal map will show no
            concept of global vs. local avoidance.  For that functionality, see <see cref="T:GoRogue.Pathing.FleeMap"/>.
            </remarks>
        </member>
        <member name="F:GoRogue.Pathing.WeightedGoalMap.Weights">
            <summary>
            The list of weighted goal maps. Can be used to add or remove goal maps, or change their weights.
            </summary>
            <remarks>
            When adding a new goal map, its <see cref="P:GoRogue.MapViews.IMapView`1.Width"/> and <see cref="P:GoRogue.MapViews.IMapView`1.Height"/>
            should be identical to the WeightedGoalMap's <see cref="P:GoRogue.Pathing.WeightedGoalMap.Width"/> and
            <see cref="P:GoRogue.Pathing.WeightedGoalMap.Height"/>.
            </remarks>
        </member>
        <member name="M:GoRogue.Pathing.WeightedGoalMap.#ctor(GoRogue.MapViews.IMapView{System.Nullable{System.Double}})">
            <summary>
            Constructor. Takes a single goal map and assigns it a weight of 1.0.
            </summary>
            <param name="map">The goal map.</param>
        </member>
        <member name="M:GoRogue.Pathing.WeightedGoalMap.#ctor(System.Collections.Generic.IEnumerable{GoRogue.MapViews.IMapView{System.Nullable{System.Double}}})">
            <summary>
            Constructor. Takes a sequence of goal maps and assigns each one a weight of 1.0.
            </summary>
            <param name="maps">The goal maps. Each one should be of the same size.</param>
        </member>
        <member name="M:GoRogue.Pathing.WeightedGoalMap.#ctor(System.Collections.Generic.IDictionary{GoRogue.MapViews.IMapView{System.Nullable{System.Double}},System.Double})">
            <summary>
            Constructor. Takes an existing goal map dictionary and copies it.
            </summary>
            <param name="maps">
            The goal maps. Each one should be of the same size, and all weights should have a nonzero value.
            </param>
        </member>
        <member name="P:GoRogue.Pathing.WeightedGoalMap.Height">
            <summary>
            The height of the goal map, and the goal maps that compose it.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.WeightedGoalMap.Width">
            <summary>
            The width of the goal map, and the goal maps that compose it.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.WeightedGoalMap.Item(System.Int32)">
            <summary>
            Returns the value of the combined goal maps at the given point.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.WeightedGoalMap.Item(System.Int32,System.Int32)">
            <summary>
            Returns the value of the combined goal maps at any given point.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.WeightedGoalMap.Item(GoRogue.Coord)">
            <summary>
            Returns the value of the combined goal maps at any given point.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.WeightedGoalMap.Combine">
            <summary>
            Computes the entire aggregate goal map and returns it, effectively caching the result.
            This may be useful in situations where the goals are shared between many characters and do not change frequently.
            </summary>
        </member>
        <member name="T:GoRogue.Radius">
            <summary>
            Class representing different shapes that define the concept of a radius on a grid. You cannot
            create instances of this class using a constructor -- instead, this class contains static instances
            representing the various radius shapes.
            </summary>
            <remarks>
            Contains utility functions to work with radius shapes.  Instances of Radius are also implicitly
            convertible to both <see cref="T:GoRogue.Distance"/> and <see cref="T:GoRogue.AdjacencyRule"/> (since both a method
            of determining adjacent locations and a method of calculating distance are implied by a radius
            shape).
            </remarks>
        </member>
        <member name="F:GoRogue.Radius.CIRCLE">
            <summary>
            Radius is a circle around the center point. CIRCLE would represent movement radius in
            an 8-way movement scheme with a ~1.41 cost multiplier for diagonal movement.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.CUBE">
            <summary>
            Radius is a cube around the center point. Similar to SQUARE in 2d shape.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.DIAMOND">
            <summary>
            Radius is a diamond around the center point. DIAMOND would represent movement radius
            in a 4-way movement scheme.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.OCTAHEDRON">
            <summary>
            Radius is an octahedron around the center point. Similar to DIAMOND in 2d shape.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.SPHERE">
            <summary>
            Radius is a sphere around the center point. Similar to CIRCLE in 2d shape.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.SQUARE">
            <summary>
            Radius is a square around the center point. SQUARE would represent movement radius in
            an 8-way movement scheme, where all 8 squares around an item are considered equal distance
            away.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.Type">
            <summary>
            Enum value representing the radius shape -- useful for using Radius types in switch
            statements.
            </summary>
        </member>
        <member name="T:GoRogue.Radius.Types">
            <summary>
            Enum representing Radius types. Each Radius instance has a <see cref="F:GoRogue.Radius.Type"/> field
            which contains the corresponding value from this enum.  Useful for easy mapping of Radius
            types to a primitive type (for cases like a switch statement).
            </summary>
        </member>
        <member name="F:GoRogue.Radius.Types.SQUARE">
            <summary>
            Type for Radius.SQUARE.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.Types.DIAMOND">
            <summary>
            Type for Radius.DIAMOND.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.Types.CIRCLE">
            <summary>
            Type for Radius.CIRCLE.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.Types.CUBE">
            <summary>
            Type for Radius.CUBE.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.Types.OCTAHEDRON">
            <summary>
            Type for Radius.OCTAHEDRON.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.Types.SPHERE">
            <summary>
            Type for Radius.SPHERE.
            </summary>
        </member>
        <member name="M:GoRogue.Radius.Equals(System.Object)">
            <summary>
            Compares the current Radius to the object given.
            </summary>
            <param name="obj"/>
            <returns>True if the given object is a Radius with the same Type, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.Radius.Equals(GoRogue.Radius)">
            <summary>
            Compares the current Radius to the one given.
            </summary>
            <param name="other"/>
            <returns>True if the given Radius has the same Type, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.Radius.GetHashCode">
            <summary>
            Returns a hash-value for this object.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.Radius.op_Equality(GoRogue.Radius,GoRogue.Radius)">
            <summary>
            Compares the two Radius instances.
            </summary>
            <param name="lhs"/>
            <param name="rhs"/>
            <returns>True if the two given Radius instances have the same Type, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.Radius.op_Inequality(GoRogue.Radius,GoRogue.Radius)">
            <summary>
            Compares the two Radius instances.
            </summary>
            <param name="lhs"/>
            <param name="rhs"/>
            <returns>True if the two given Radius instances do NOT have the same Type, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.Radius.op_Implicit(GoRogue.Radius)~GoRogue.AdjacencyRule">
            <summary>
            Allows implicit casting to the <see cref="T:GoRogue.AdjacencyRule"/> type.
            </summary>
            <remarks>
            The rule corresponding to the proper definition of distance that creates the
            radius shape casted will be returned.
            </remarks>
            <param name="radius">Radius type being casted.</param>
        </member>
        <member name="M:GoRogue.Radius.op_Implicit(GoRogue.Radius)~GoRogue.Distance">
            <summary>
            Allows implicit casting to the <see cref="T:GoRogue.Distance"/> type.
            </summary>
            <remarks>
            The <see cref="T:GoRogue.Distance"/> instance corresponding to the proper definition of
            distance that creates the radius shape casted will be returned.
            </remarks>
            <param name="radius">Radius type being casted.</param>
        </member>
        <member name="M:GoRogue.Radius.ToRadius(GoRogue.Radius.Types)">
            <summary>
            Gets the Radius class instance representing the radius type specified.
            </summary>
            <param name="radiusType">The enum value for the radius shape.</param>
            <returns>The radius class representing the given radius shape.</returns>
        </member>
        <member name="M:GoRogue.Radius.ToString">
            <summary>
            Returns a string representation of the Radius.
            </summary>
            <returns>A string representation of the Radius.</returns>
        </member>
        <member name="T:GoRogue.RadiusAreaProvider">
            <summary>
            Class containing functions capable of returning all unique positions inside of a given radius
            and (optional) bounds.
            </summary>
            <remarks>
            In the case that MANHATTAN/CHEBYSHEV distance, or DIAMOND/SQUARE/OCTAHEDRON/CUBE radius shapes
            are used, positions returned are guaranteed to be returned in order of distance from the center,
            from least to greatest. This guarantee does NOT hold if EUCLIDEAN distance, or CIRCLE/SPHERE radius
            shapes are specified. If no bounds are specified, the IEnumerable returned by the
            <see cref="M:GoRogue.RadiusAreaProvider.CalculatePositions"/> function will contain each coordinate within the radius. Otherwise, it
            will contain each coordinate in the radius that is also within the bounds of the rectangle. If the same
            radius length is being used multiple times (even from different center points), it is recommended to use
            only one RadiusAreaProvider, as the class allocates measurable memory, and using only one instance
            if the radius is used multiple times prevents reallocation. When the Radius value is
            changed, reallocation must be performed, however the overhead should be insignificant on
            everything but extremely large radiuses.
            </remarks>
        </member>
        <member name="M:GoRogue.RadiusAreaProvider.#ctor(GoRogue.Coord,System.Int32,GoRogue.Distance,GoRogue.Rectangle)">
            <summary>
            Constructor.
            </summary>
            <param name="center">The center point of the radius.</param>
            <param name="radius">The length of the radius.</param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to a distance method, eg. <see cref="P:GoRogue.RadiusAreaProvider.Radius"/>).
            </param>
            <param name="bounds">The bounds to constrain the returned locations to.</param>
        </member>
        <member name="M:GoRogue.RadiusAreaProvider.#ctor(System.Int32,System.Int32,System.Int32,GoRogue.Distance,GoRogue.Rectangle)">
            <summary>
            Constructor.
            </summary>
            <param name="centerX">The x-value of the center point of the radius.</param>
            <param name="centerY">The y-value of the center point of the radius.</param>
            <param name="radius">The length of the radius.</param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to a distance method, eg. <see cref="P:GoRogue.RadiusAreaProvider.Radius"/>).
            </param>
            <param name="bounds">The bounds to constrain the returned locations to.</param>
        </member>
        <member name="M:GoRogue.RadiusAreaProvider.#ctor(GoRogue.Coord,System.Int32,GoRogue.Distance)">
            <summary>
            Constructor.
            </summary>
            <param name="center">The center point of the radius.</param>
            <param name="radius">The length of the radius.</param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to a distance method, eg. <see cref="P:GoRogue.RadiusAreaProvider.Radius"/>).
            </param>
        </member>
        <member name="M:GoRogue.RadiusAreaProvider.#ctor(System.Int32,System.Int32,System.Int32,GoRogue.Distance)">
            <summary>
            Constructor.
            </summary>
            <param name="centerX">The x-value of the center point of the radius.</param>
            <param name="centerY">The y-value of the center point of the radius.</param>
            <param name="radius">The length of the radius.</param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to a distance method, eg. <see cref="P:GoRogue.RadiusAreaProvider.Radius"/>).
            </param>
        </member>
        <member name="P:GoRogue.RadiusAreaProvider.Bounds">
            <summary>
            The bounds to constrain the returned locations to. Set to <see cref="F:GoRogue.Rectangle.EMPTY"/>
            to indicate that there are no bounds.
            </summary>
        </member>
        <member name="P:GoRogue.RadiusAreaProvider.Center">
            <summary>
            The center point of the radius.
            </summary>
        </member>
        <member name="P:GoRogue.RadiusAreaProvider.CenterX">
            <summary>
            The X-value of the center point of the radius.
            </summary>
        </member>
        <member name="P:GoRogue.RadiusAreaProvider.CenterY">
            <summary>
            The Y-value of the center point of the radius.
            </summary>
        </member>
        <member name="P:GoRogue.RadiusAreaProvider.DistanceCalc">
            <summary>
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to a distance method, eg. <see cref="P:GoRogue.RadiusAreaProvider.Radius"/>).
            </summary>
        </member>
        <member name="P:GoRogue.RadiusAreaProvider.Radius">
            <summary>
            The length of the radius, eg. the number of tiles from the center point (as defined by the distance
            calculation/radius shape given) to which the radius extends.
            </summary>
            <remarks>
            When this value is changed, reallocation of an underlying array is performed, however overhead should
            be relatively small in most cases.
            </remarks>
        </member>
        <member name="M:GoRogue.RadiusAreaProvider.AsReadOnly">
            <summary>
            Returns a read-only representation of this RadiusAreaProvider.
            </summary>
            <returns>A read-only representation of the RadiusAreaProvider</returns>
        </member>
        <member name="M:GoRogue.RadiusAreaProvider.CalculatePositions">
            <summary>
            Calculates the new radius, and returns an IEnumerable of all unique locations within that
            radius and bounds specified (as applicable).
            </summary>
            <remarks>
            In the case that MANHATTAN/CHEBYSHEV distance, or DIAMOND/SQUARE/OCTAHEDRON/CUBE radius shapes
            are specified via <see cref="P:GoRogue.RadiusAreaProvider.DistanceCalc"/>, positions returned are guaranteed to be returned
            in order of distance from the center, from least to greatest. This guarantee does NOT hold if
            EUCLIDEAN distance, or CIRCLE/SPHERE radius shapes are specified.
            </remarks>
            <returns>Enumerable of all unique positions within the radius and bounds specified.</returns>
        </member>
        <member name="M:GoRogue.RadiusAreaProvider.Equals(System.Object)">
            <summary>
            Compares the current RadiusAreaProvider to the one given.
            </summary>
            <param name="obj"/>
            <returns>True if the given object is a RadiusAreaProvider that represents the same radius/Bounds, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.RadiusAreaProvider.Equals(GoRogue.RadiusAreaProvider)">
            <summary>
            Compares the current RadiusAreaProvider to the one given.
            </summary>
            <param name="other"/>
            <returns>True if the given RadiusAreaProvider represents the same radius/Bounds, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.RadiusAreaProvider.GetHashCode">
            <summary>
            Returns a hash-value for this object.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.RadiusAreaProvider.op_Equality(GoRogue.RadiusAreaProvider,GoRogue.RadiusAreaProvider)">
            <summary>
            Compares the two RadiusAreaProvider instances.
            </summary>
            <param name="lhs"/>
            <param name="rhs"/>
            <returns>True if the two given RadiusAreaProvider instances represents the same radius/Bounds, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.RadiusAreaProvider.op_Inequality(GoRogue.RadiusAreaProvider,GoRogue.RadiusAreaProvider)">
            <summary>
            Compares the two RadiusAreaProvider instances.
            </summary>
            <param name="lhs"/>
            <param name="rhs"/>
            <returns>True if the two given RadiusAreaProvider instances do NOT represent the same radius/Bounds, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.RadiusAreaProvider.ToString">
            <summary>
            Returns a string representation of the parameters of the RadiusAreaProvider.
            </summary>
            <returns>A string representation of the RadiusAreaProvider.</returns>
        </member>
        <member name="T:GoRogue.Random.DiscreteConverter`1">
            <summary>
            Wraps a continuous distribution and allows it to be used as discrete, by rounding double
            values produced by <see cref="M:GoRogue.Random.DiscreteConverter`1.NextDouble"/> to the nearest int. Its minimum, maximum, mean, median, variance,
            and mode(s) are exactly the same as its underlying <see cref="T:Troschuetz.Random.IContinuousDistribution"/>.
            </summary>
            <remarks>
            Takes a value of type T so that its <see cref="P:GoRogue.Random.DiscreteConverter`1.ContinuousDistribution"/> can return a value of the
            exact wrapped type, which still enables access to any distribution-specified fields, etc.
            </remarks>
            <typeparam name="T">
            The type of continuous distribution being wrapped. Must implement <see cref="T:Troschuetz.Random.IContinuousDistribution"/>.
            </typeparam>
        </member>
        <member name="M:GoRogue.Random.DiscreteConverter`1.#ctor(`0)">
            <summary>
            Constructor. Takes the continuous distribution to wrap.
            </summary>
            <param name="continuousDistribution">Continuous distribution instance to wrap around.</param>
        </member>
        <member name="P:GoRogue.Random.DiscreteConverter`1.CanReset">
            <summary>
            Gets a value indicating whether the underlying random number distribution can be reset,
            so that it produces the same random number sequence again.
            </summary>
        </member>
        <member name="P:GoRogue.Random.DiscreteConverter`1.ContinuousDistribution">
            <summary>
            The continuous distribution being wrapped.
            </summary>
        </member>
        <member name="P:GoRogue.Random.DiscreteConverter`1.Generator">
            <summary>
            Gets the <see cref="T:Troschuetz.Random.IGenerator"/> object that is used as underlying random number generator.
            </summary>
        </member>
        <member name="P:GoRogue.Random.DiscreteConverter`1.Maximum">
            <summary>
            Gets the maximum possible value of distributed random numbers for the underlying distribution.
            </summary>
        </member>
        <member name="P:GoRogue.Random.DiscreteConverter`1.Mean">
            <summary>
            Gets the mean of distributed random numbers for the underlying distribution.
            </summary>
        </member>
        <member name="P:GoRogue.Random.DiscreteConverter`1.Median">
            <summary>
            Gets the median of distributed random numbers for the underlying distribution.
            </summary>
        </member>
        <member name="P:GoRogue.Random.DiscreteConverter`1.Minimum">
            <summary>
            Gets the minimum possible value of distributed random numbers for the underlying distribution.
            </summary>
        </member>
        <member name="P:GoRogue.Random.DiscreteConverter`1.Mode">
            <summary>
            Gets the mode of distributed random numbers.
            </summary>
        </member>
        <member name="P:GoRogue.Random.DiscreteConverter`1.Variance">
            <summary>
            Gets the variance of distributed random numbers for the underlying distribution.
            </summary>
        </member>
        <member name="M:GoRogue.Random.DiscreteConverter`1.Next">
            <summary>
            Returns the result of the underlying continuous distribution's <see cref="M:GoRogue.Random.DiscreteConverter`1.NextDouble"/> function, but
            rounded to the nearest integer.
            </summary>
            <returns>
            The result of the underlying continuous distribution's <see cref="M:GoRogue.Random.DiscreteConverter`1.NextDouble"/> function, rounded to
            the nearest integer.
            </returns>
        </member>
        <member name="M:GoRogue.Random.DiscreteConverter`1.NextDouble">
            <summary>
            Returns a distributed floating point random number from the underlying continuous generator.
            </summary>
            <returns>A distributed double-precision floating point number.</returns>
        </member>
        <member name="M:GoRogue.Random.DiscreteConverter`1.Reset">
            <summary>
            Resets the random number distribution, so that it produces the same random number
            sequence again.
            </summary>
            <returns>true if the random number distribution was reset; otherwise, false.</returns>
        </member>
        <member name="T:GoRogue.Random.DistributionHelpers">
            <summary>
            Defines functions that assist in dealing with RNG distributions.
            </summary>
        </member>
        <member name="M:GoRogue.Random.DistributionHelpers.CreateNormalDistribution(System.Double,System.Double,System.Double)">
            <summary>
            Creates a normal distribution based on a lower and upper value, and a distance to place
            those points from the mean. The mean is placed precisely in between the upper and lower
            values given, and the upper and lower values will both be exactly <paramref name="deviationsFromMean"/>
            deviations away from the mean.
            </summary>
            <param name="lower">Lower value by which to define the distribution.</param>
            <param name="upper">Upper value by which to define the distribution.</param>
            <param name="deviationsFromMean">
            Number of deviations from the mean at which to place the lower and upper values given.
            </param>
            <returns>
            A <see cref="T:Troschuetz.Random.Distributions.Continuous.NormalDistribution"/> constructed such that the mean is precisely in between the lower and
            upper values given, and the lower and upper values are exatly the specified number of
            deviations away from the mean.
            </returns>
        </member>
        <member name="M:GoRogue.Random.DistributionHelpers.CreateNormalDistribution(System.UInt32,System.Double,System.Double,System.Double)">
            <summary>
            Creates a normal distribution based on a lower and upper value, and a distance to place
            those points from the mean. The mean is placed precisely in between the upper and lower
            values given, and the upper and lower values will both be exactly <paramref name="deviationsFromMean"/>
            deviations away from the mean.
            </summary>
            <param name="seed">The seed to pass the default <see cref="T:Troschuetz.Random.Generators.XorShift128Generator"/> that is created.</param>
            <param name="lower">Lower value by which to define the distribution.</param>
            <param name="upper">Upper value by which to define the distribution.</param>
            <param name="deviationsFromMean">
            Number of deviations from the mean at which to place the lower and upper values given.
            </param>
            <returns>
            A <see cref="T:Troschuetz.Random.Distributions.Continuous.NormalDistribution"/> constructed such that the mean is precisely in between the lower and
            upper values given, and the lower and upper values are exatly the specified number of
            deviations away from the mean.
            </returns>
        </member>
        <member name="M:GoRogue.Random.DistributionHelpers.CreateNormalDistribution(Troschuetz.Random.IGenerator,System.Double,System.Double,System.Double)">
            <summary>
            Creates a normal distribution based on a lower and upper value, and a distance to place
            those points from the mean. The mean is placed precisely in between the upper and lower
            values given, and the upper and lower values will both be exactly <paramref name="deviationsFromMean"/>
            deviations away from the mean.
            </summary>
            <param name="generator">
            Generator to use. If null is specified, the <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/> will be used.
            </param>
            <param name="lower">Lower value by which to define the distribution.</param>
            <param name="upper">Upper value by which to define the distribution.</param>
            <param name="deviationsFromMean">
            Number of deviations from the mean at which to place the lower and upper values given.
            </param>
            <returns>
            A <see cref="T:Troschuetz.Random.Distributions.Continuous.NormalDistribution"/> constructed such that the mean is precisely in between the lower and
            upper values given, and the lower and upper values are exatly the specified number of
            deviations away from the mean.
            </returns>
        </member>
        <member name="T:GoRogue.Random.KnownSeriesGenerator">
            <summary>
            "Random number generator" that takes in a series of values, and simply returns them
            sequentially when RNG functions are called.
            </summary>
            <remarks>
            This class may be useful for testing, when you want to specify the numbers returned by an RNG
            without drastically modifying any code using the RNG.
            </remarks>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.UInt32},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Boolean},System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            Creates a new known series generator, with parameters to indicate which series to use for
            the integer, unsigned integer, double, bool, and byte-based RNG functions. If null is
            specified, no values of that type may be returned, and functions that try to return a
            value of that type will throw an exception.
            </summary>
        </member>
        <member name="P:GoRogue.Random.KnownSeriesGenerator.CanReset">
            <summary>
            Whether or not the RNG is capable of resetting, such that it will return the same series
            of values again.
            </summary>
        </member>
        <member name="P:GoRogue.Random.KnownSeriesGenerator.Seed">
            <summary>
            Since this RNG returns a known series of values, this field will always return 0.
            </summary>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.Next(System.Int32)">
            <summary>
            Gets the next number in the underlying int series. If the value is less than 0 or greater
            than/equal to <paramref name="maxValue"/>, throws an exception.
            </summary>
            <param name="maxValue">Maximum allowable number that can be returned (exclusive).</param>
            <returns>The appropriate number from the series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.Next(System.Int32,System.Int32)">
            <summary>
            Gets the next number in the underlying series. If the value is less than <paramref name="minValue"/> or
            greater than/equal to <paramref name="maxValue"/>, throws an exception.
            </summary>
            <param name="minValue">Minimum allowable number that can be returned.</param>
            <param name="maxValue">Maximum allowable number that can be returned (exclusive).</param>
            <returns>The appropriate number from the series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.Next">
            <summary>
            Gets the next integer in the underlying series. If the integer is equal to <see cref="F:System.Int32.MaxValue"/>,
            throws an exception.
            </summary>
            <returns>The next integer in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextBoolean">
            <summary>
            Returns the next boolean in the underlying series.
            </summary>
            <returns>The next boolean value in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextBytes(System.Byte[])">
            <summary>
            Fills the specified buffer with values from the underlying byte series.
            </summary>
            <param name="buffer">Buffer to fill.</param>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextDouble">
            <summary>
            Returns the next double in the underlying series. If the double is less than 0.0 or
            greater than/equal to 1.0, throws an exception.
            </summary>
            <returns>The next double in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextDouble(System.Double)">
            <summary>
            Returns the next double in the underlying series. If the double is less than 0.0 or
            greater than/equal to <paramref name="maxValue"/>, throws an exception.
            </summary>
            <param name="maxValue">The maximum value for the returned value, exclusive.</param>
            <returns>The next double in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextDouble(System.Double,System.Double)">
            <summary>
            Returns the next double in the underlying series. If the double is less than <paramref name="minValue"/>
            or greater than/equal to <paramref name="maxValue"/>, throws an exception.
            </summary>
            <param name="minValue">Minimum value for the returned number, inclusive.</param>
            <param name="maxValue">Maximum value for the returned number, exclusive.</param>
            <returns>The next double in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextInclusiveMaxValue">
            <summary>
            Returns the next integer in the underlying series. If the value is less than 0, throws an exception.
            </summary>
            <returns>The next integer in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextUInt">
            <summary>
            Returns the next unsigned integer in the underlying series. If the value is equal to
            <see cref="F:System.UInt32.MaxValue"/>, throws an exception.
            </summary>
            <returns>The next unsigned integer in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextUInt(System.UInt32)">
            <summary>
            Returns the next unsigned integer in the underlying series. If the value is greater than
            or equal to <paramref name="maxValue"/>, throws an exception.
            </summary>
            <param name="maxValue">The maximum value for the returned number, exclusive.</param>
            <returns>The next unsigned integer in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextUInt(System.UInt32,System.UInt32)">
            <summary>
            Returns the next unsigned integer in the underlying series. If the value is less than
            <paramref name="minValue"/>, or greater than/equal to <paramref name="maxValue"/>, throws an exception.
            </summary>
            <param name="minValue">The minimum value for the returned number, inclusive.</param>
            <param name="maxValue">The maximum value for the returned number, exclusive.</param>
            <returns>The next unsigned integer in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextUIntExclusiveMaxValue">
            <summary>
            Returns the next unsigned integer in the underlying series. If the value is equal to
            <see cref="F:System.UInt32.MaxValue"/>, throws an exception.
            </summary>
            <returns>The next unsigned integer in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextUIntInclusiveMaxValue">
            <summary>
            Returns the next unsigned integer in the underlying series.
            </summary>
            <returns>The next unsinged integer in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.Reset">
            <summary>
            Resets the random number generator, such that it starts returning values from the
            beginning of the underlying series.
            </summary>
            <returns>True, since the reset cannot fail.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.Reset(System.UInt32)">
            <summary>
            Resets the random number generator, such that it starts returning the values from the
            beginning of the underlying series.
            </summary>
            <param name="seed">Unused, since there is no seed for a known-series RNG.</param>
            <returns>True, since the reset cannot fail.</returns>
        </member>
        <member name="T:GoRogue.Random.MaxRandom">
            <summary>
            A "random" number generator that always returns the maxValue parameter given. Again this may
            be useful in testing, testing the upper range or repeatedly returning a value. Also used in
            <see cref="T:GoRogue.DiceNotation.DiceExpression"/> instances for certain max roll functions.
            </summary>
        </member>
        <member name="P:GoRogue.Random.MaxRandom.CanReset">
            <summary>
            Whether or not the RNG is capable of resetting, such that it will return the same series
            of values again.
            </summary>
        </member>
        <member name="P:GoRogue.Random.MaxRandom.Seed">
             <summary>
             Since this RNG returns the maximum possible value, this field will always return 0.
            </summary>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.Next">
            <summary>
            Returns <see cref="F:System.Int32.MaxValue"/> - 1.
            </summary>
            <returns><see cref="F:System.Int32.MaxValue"/> - 1.</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.Next(System.Int32)">
            <summary>
            Returns <paramref name="maxValue"/> - 1.
            </summary>
            <param name="maxValue">Maximum bound of the returned number, exclusive.</param>
            <returns><paramref name="maxValue"/> - 1.</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.Next(System.Int32,System.Int32)">
            <summary>
            Returns <paramref name="maxValue"/> - 1.
            </summary>
            <param name="minValue">
            The minimum value that can be returned (unused since this generator always returns the maximum).
            </param>
            <param name="maxValue">The maximum value of the returned number, exclusive.</param>
            <returns><paramref name="maxValue"/> - 1.</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextBoolean">
            <summary>
            Returns true.
            </summary>
            <returns>true</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextBytes(System.Byte[])">
            <summary>
            Fills the given buffer with bytes of value <see cref="F:System.Byte.MaxValue"/>.
            </summary>
            <param name="buffer">Buffer to fill.</param>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextDouble">
            <summary>
            Returns a number very close to (but still less than) 1.0.
            </summary>
            <remarks>Value returned is 0.99999999999999978.</remarks>
            <returns>A number very close to (but still less than) 1.0.</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextDouble(System.Double)">
            <summary>
            Returns a double very close to (but still less than) <paramref name="maxValue"/>.
            </summary>
            <param name="maxValue">Maximum value for the returned value (exclusive).</param>
            <returns>A double very close to (but still less than) <paramref name="maxValue"/>.</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextDouble(System.Double,System.Double)">
            <summary>
            Returns a double very close to (but still less than) <paramref name="maxValue"/>.
            </summary>
            <param name="minValue">
            Minimum value for the returned value. Unused since this generator always returns the
            maximum value.
            </param>
            <param name="maxValue">Maximum value for the returned value (exclusive).</param>
            <returns>A double very close to (but still less than) <paramref name="maxValue"/>.</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextInclusiveMaxValue">
            <summary>
            Returns <see cref="F:System.Int32.MaxValue"/>.
            </summary>
            <returns>int.MaxValue</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextUInt">
            <summary>
            Returns <see cref="F:System.UInt32.MaxValue"/>.
            </summary>
            <returns><see cref="F:System.UInt32.MaxValue"/> - 1.</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextUInt(System.UInt32)">
            <summary>
            Returns <paramref name="maxValue"/> - 1.
            </summary>
            <param name="maxValue">The maximum bound for the returned number, exclusive.</param>
            <returns><paramref name="maxValue"/> - 1</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextUInt(System.UInt32,System.UInt32)">
            <summary>
            Returns <paramref name="maxValue"/> - 1.
            </summary>
            <param name="minValue">
            The minimum value that can be returned (unused since this generator always returns the maximum).
            </param>
            <param name="maxValue">The maximum bound for the returned number, exclusive.</param>
            <returns><paramref name="maxValue"/> - 1</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextUIntExclusiveMaxValue">
            <summary>
            Returns <see cref="F:System.UInt32.MaxValue"/> - 1.
            </summary>
            <returns><see cref="F:System.UInt32.MaxValue"/> - 1.</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextUIntInclusiveMaxValue">
            <summary>
            Returns <see cref="F:System.UInt32.MaxValue"/>.
            </summary>
            <returns><see cref="F:System.UInt32.MaxValue"/>.</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.Reset">
            <summary>
            Simply returns true, since this generator has no state.
            </summary>
            <returns>true</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.Reset(System.UInt32)">
            <summary>
            Simply returns true, since this generator has no state.
            </summary>
            <param name="seed">Unused, since this generator has no seed.</param>
            <returns>true</returns>
        </member>
        <member name="T:GoRogue.Random.MinRandom">
            <summary>
            A "random" number generator that always returns the minValue parameter given, or 0 on the
            Next overload that only takes maxValue. Again, may be useful for testing. Also used in
            <see cref="T:GoRogue.DiceNotation.DiceExpression"/> for certain minimum roll functions.
            </summary>
        </member>
        <member name="P:GoRogue.Random.MinRandom.CanReset">
            <summary>
            Whether or not the RNG is capable of resetting, such that it will return the same series
            of values again.
            </summary>
        </member>
        <member name="P:GoRogue.Random.MinRandom.Seed">
             <summary>
             Since this RNG returns the maximum possible value, this field will always return 0.
            </summary>
        </member>
        <member name="M:GoRogue.Random.MinRandom.Next">
            <summary>
            Returns 0.0
            </summary>
            <returns>0.0</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.Next(System.Int32)">
            <summary>
            Returns 0.0
            </summary>
            <returns>0.0</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.Next(System.Int32,System.Int32)">
            <summary>
            Returns <paramref name="minValue"/>.
            </summary>
            <param name="minValue">
            The minimum value for the returned number (which is always returned by this generator)
            </param>
            <param name="maxValue">
            The maximum value for the returned number (which is unused since this generator always
            returns the minimum.
            </param>
            <returns><paramref name="minValue"/></returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextBoolean">
            <summary>
            Returns false.
            </summary>
            <returns>false</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextBytes(System.Byte[])">
            <summary>
            Fills the given buffer with bytes of value 0.
            </summary>
            <param name="buffer">The buffer to fill.</param>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextDouble">
            <summary>
            Returns 0.0.
            </summary>
            <returns>0.0</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextDouble(System.Double)">
            <summary>
            Returns 0.0.
            </summary>
            <param name="maxValue">
            The maximum value for the returned number, exclusive. Unused since this function always
            returns the minimum.
            </param>
            <returns>0.0</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextDouble(System.Double,System.Double)">
            <summary>
            Returns <paramref name="minValue"/>.
            </summary>
            <param name="minValue">
            The minimum value for the returned number (always returned since this function always
            returns the minimum).
            </param>
            <param name="maxValue">The maximum vlaue for the returned number (unused).</param>
            <returns><paramref name="minValue"/></returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextInclusiveMaxValue">
            <summary>
            Returns 0.
            </summary>
            <returns>0</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextUInt">
            <summary>
            Returns 0.
            </summary>
            <returns>0</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextUInt(System.UInt32)">
            <summary>
            Returns 0.
            </summary>
            <param name="maxValue">
            The maximum value for the returned number (unused since this generator always returns the minimum).
            </param>
            <returns>0</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextUInt(System.UInt32,System.UInt32)">
            <summary>
            Returns <paramref name="minValue"/>.
            </summary>
            <param name="minValue">
            The minimum value for the returned number (this generator always returns the minimum value).
            </param>
            <param name="maxValue">The maximum value for the returned number (unused).</param>
            <returns><paramref name="minValue"/></returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextUIntExclusiveMaxValue">
            <summary>
            Returns 0.
            </summary>
            <returns>0</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextUIntInclusiveMaxValue">
            <summary>
            Returns 0.
            </summary>
            <returns>0</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.Reset">
            <summary>
            Simply returns true, since this generator has no state.
            </summary>
            <returns>true</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.Reset(System.UInt32)">
            <summary>
            Simply returns true, since this generator has no state.
            </summary>
            <param name="seed">Unused, since this generator has no seed.</param>
            <returns>true</returns>
        </member>
        <member name="T:GoRogue.Random.SingletonRandom">
            <summary>
            Static class that contains 1 variable, which is a an RNG instance that is used as the default
            rng by other features (dice, etc) wherever needed, and can also be used if you need a random
            number generator for your own code.
            </summary>
        </member>
        <member name="F:GoRogue.Random.SingletonRandom.DefaultRNG">
            <summary>
            Settable field that specifies what <see cref="T:Troschuetz.Random.IGenerator"/> instance should be considered the default
            RNG. Defaults to an <see cref="T:Troschuetz.Random.Generators.XorShift128Generator"/> with a time-dependent value used as a seed.
            </summary>
        </member>
        <member name="T:GoRogue.Rectangle">
            <summary>
            Represents a rectangle in terms of grid squares. Provides numerous static functions that enable
            creation and common operations involving rectangles, as well as implicit conversion operators that
            enable interoperability with rectangle representations from other libraries.
            </summary>
            <remarks>
            Rectangle is designed to be extremely efficient and interoperable with equivalent representations in other libraries,
            so in general, in an environment where you have multiple rectangle representations defined, it is best to prefer
            Rectangle where possible, as something that accepts or works with Rectangle will generally work with other supported types
            as well.
            </remarks>
        </member>
        <member name="F:GoRogue.Rectangle.EMPTY">
            <summary>
            The empty rectangle. Has origin of (0, 0) with 0 width and height.
            </summary>
        </member>
        <member name="M:GoRogue.Rectangle.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="x">Minimum x coordinate that is inside the rectangle.</param>
            <param name="y">Minimum y coordinate that is inside the rectangle.</param>
            <param name="width">Width of the rectangle.</param>
            <param name="height">Height of the rectangle.</param>
        </member>
        <member name="M:GoRogue.Rectangle.#ctor(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Constructor.
            </summary>
            <param name="minExtent">Minimum x and y values that are considered inside the rectangle.</param>
            <param name="maxExtent">Maximum x and y values that are considered inside the rectangle.</param>
        </member>
        <member name="M:GoRogue.Rectangle.#ctor(GoRogue.Coord,System.Int32,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="center">The center point of the rectangle.</param>
            <param name="horizontalRadius">
            Number of units to the left and right of the center point that are included within the rectangle.
            </param>
            <param name="verticalRadius">
            Number of units to the top and bottom of the center point that are included within the rectangle.
            </param>
        </member>
        <member name="P:GoRogue.Rectangle.Area">
            <summary>
            Calculates the area of the rectangle.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.Center">
            <summary>
            The center coordinate of the rectangle, rounded up if the exact center is between two
            positions. The center of a rectangle with width/height 1 is its <see cref="P:GoRogue.Rectangle.Position"/>.
            </summary>
        </member>
        <member name="F:GoRogue.Rectangle.Height">
            <summary>
            The height of the rectangle.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.IsEmpty">
            <summary>
            Whether or not this rectangle is empty (has width and height of 0).
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.MaxExtent">
            <summary>
            The maximum X and Y coordinates that are included in the rectangle.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.MaxExtentX">
            <summary>
            The maximum X-coordinate that is included in the rectangle.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.MaxExtentY">
            <summary>
            The maximum Y-coordinate that is included in the rectangle.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.MinExtent">
            <summary>
            Minimum extent of the rectangle (minimum x and y values that are included within it).
            Identical to <see cref="P:GoRogue.Rectangle.Position"/> because we define the rectangle's position by its
            minimum extent.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.MinExtentX">
            <summary>
            X-value of the minimum extent of the rectangle (minimum x value that is included within
            it). Identical to the <see cref="F:GoRogue.Rectangle.X"/> value because we define the rectangle's position
            by its minimum extent.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.MinExtentY">
            <summary>
            Y-value of the minimum extent of the rectangle (minimum y value that is included within
            it). Identical to the <see cref="F:GoRogue.Rectangle.Y"/> value because we define the rectangle's position
            by its minimum extent.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.Perimeter">
            <summary>
            Calculates the perimeter length of the rectangle.  This is equal to the mathematical
            perimeter, NOT the number of grid squares around the perimiter.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.Position">
            <summary>
            Coord representing the position (min x- and y-values) of the rectangle.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.Size">
            <summary>
            Returns a coordinate (Width, Height), which represents the size of the rectangle.
            </summary>
        </member>
        <member name="F:GoRogue.Rectangle.Width">
            <summary>
            The width of the rectangle.
            </summary>
        </member>
        <member name="F:GoRogue.Rectangle.X">
            <summary>
            X-coordinate of position of the rectangle.
            </summary>
        </member>
        <member name="F:GoRogue.Rectangle.Y">
            <summary>
            Y-coordinate of position of the rectangle.
            </summary>
        </member>
        <member name="M:GoRogue.Rectangle.WithExtents(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a rectangle with the given minimum and maximum extents. Effectively a
            constructor, but with extra overloads not possible to provide in constructors alone.
            </summary>
            <param name="minX">Minimum x coordinate that is inside the rectangle.</param>
            <param name="minY">Minimum y coordinate that is inside the rectangle.</param>
            <param name="maxX">Maximum x coordinate that is inside the rectangle.</param>
            <param name="maxY">Maximum y coordinate that is inside the rectangle.</param>
            <returns>A new Rectangle with the given minimum and maximum extents.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithExtents(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Creates a rectangle with the given minimum and maximum extents. Effectively a
            constructor, but with extra overloads not possible to provide in constructors alone.
            </summary>
            <param name="minExtent">Minimum (x, y) coordinates that are inside the rectangle.</param>
            <param name="maxExtent">Maximum (x, y) coordinates that are inside the rectangle.</param>
            <returns>A new Rectangle with the given minimum and maximum extents.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithRadius(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a rectangle centered on the given position, with the given horizontal and
            vertical radius values. Effectively a constructor, but with extra overloads not possible
            to provide in constructors alone.
            </summary>
            <param name="centerX">X-value of the center of the rectangle.</param>
            <param name="centerY">Y-value of the center of the rectangle.</param>
            <param name="horizontalRadius">
            Number of units to the left and right of the center point that are included within the rectangle.
            </param>
            <param name="verticalRadius">
            Number of units to the top and bottom of the center point that are included within the rectangle.
            </param>
            <returns>A new rectangle with the given center point and radius values.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithRadius(GoRogue.Coord,System.Int32,System.Int32)">
            <summary>
            Creates a rectangle centered on the given position, with the given horizontal and
            vertical radius values. Effectively a constructor, but with extra overloads not possible
            to provide in constructors alone.
            </summary>
            <param name="center">Center of the rectangle.</param>
            <param name="horizontalRadius">
            Number of units to the left and right of the center point that are included within the rectangle.
            </param>
            <param name="verticalRadius">
            Number of units to the top and bottom of the center point that are included within the rectangle.
            </param>
            <returns>A new rectangle with the given center point and radius values.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithPositionAndSize(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a rectangle with the given position and size. Effectively a constructor, but with
            extra overloads not possible to provide in constructors alone.
            </summary>
            <param name="x">Minimum x coordinate that is inside the rectangle.</param>
            <param name="y">Minimum y coordinate that is inside the rectangle.</param>
            <param name="width">Width of the rectangle.</param>
            <param name="height">Height of the rectangle.</param>
            <returns>A new rectangle at the given position with the given width and height.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithPostionAndSize(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Creates a rectangle with the given position and size. Effectively a constructor, but with
            extra overloads not possible to provide in constructors alone.
            </summary>
            <param name="position">Minimum (x, y) values that are inside the resulting rectangle.</param>
            <param name="size">The size of the rectangle, in form (width, height).</param>
            <returns>A new rectangle at the given position with the given size.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.GetDifference(GoRogue.Rectangle,GoRogue.Rectangle)">
            <summary>
            Gets a <see cref="T:GoRogue.MapGeneration.MapArea"/> representing every location in <paramref name="rect1"/> that
            is NOT in <paramref name="rect2"/>.
            </summary>
            <param name="rect1"/>
            <param name="rect2"/>
            <returns>A <see cref="T:GoRogue.MapGeneration.MapArea"/> representing every location in <paramref name="rect1"/> that
            is NOT in <paramref name="rect2"/>.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.GetExactUnion(GoRogue.Rectangle,GoRogue.Rectangle)">
            <summary>
            Gets a <see cref="T:GoRogue.MapGeneration.MapArea"/> representing the exact union of the specified rectangles, eg.
            a MapArea containing all locations from either rectangle.
            </summary>
            <param name="r1"/>
            <param name="r2"/>
            <returns>A <see cref="T:GoRogue.MapGeneration.MapArea"/> containing every position in either rectangle.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.GetIntersection(GoRogue.Rectangle,GoRogue.Rectangle)">
            <summary>
            Returns the rectangle that represents the intersection of the two rectangles specified,
            or the empty rectangle if the specified rectangles do not intersect.
            </summary>
            <param name="r1"/>
            <param name="r2"/>
            <returns>
            Rectangle representing the intersection of <paramref name="r1"/> and <paramref name="r2"/>, or
            the empty rectangle if the two rectangles do not intersect.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.GetUnion(GoRogue.Rectangle,GoRogue.Rectangle)">
            <summary>
            Gets the smallest possible rectangle that includes the entire area of both <paramref name="r1"/> and
            <paramref name="r2"/>.
            </summary>
            <param name="r1"/>
            <param name="r2"/>
            <returns>
            The smallest possible rectangle that includes the entire area of both <paramref name="r1"/> and
            <paramref name="r2"/>.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.op_Inequality(GoRogue.Rectangle,GoRogue.Rectangle)">
            <summary>
            Returns whether or not the rectangles differ in either their positions or extents.
            </summary>
            <param name="r1"/>
            <param name="r2"/>
            <returns>true if the rectangles do NOT encompass the same area, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.op_Equality(GoRogue.Rectangle,GoRogue.Rectangle)">
            <summary>
            Returns whether or not the rectangles have the same position and extents.
            </summary>
            <param name="r1"/>
            <param name="r2"/>
            <returns>
            true if the area of the two rectangles encompass the exact same area, false otherwise.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithCenter(GoRogue.Coord)">
            <summary>
            Creates and returns a new rectangle that is the same size as the current one, but with
            the center moved to the given position.
            </summary>
            <param name="center">The center-point for the new rectangle.</param>
            <returns>
            A new rectangle that is the same size as the current one, but with the center moved to
            the given location.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithCenter(System.Int32,System.Int32)">
            <summary>
            Creates and returns a new rectangle that is the same size as the current one, but with
            the center moved to the given position.
            </summary>
            <param name="x">X-value for the center-point of the new rectangle.</param>
            <param name="y">Y-value for the center-point of the new rectangle.</param>
            <returns>
            A new rectangle that is the same size as the current one, but with the center moved to
            the given location.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.ChangeHeight(System.Int32)">
            <summary>
            Creates and returns a new rectangle whose position is the same as the current one, but
            has its height changed by the given delta-change value.
            </summary>
            <param name="deltaHeight">Delta-change for the height of the new rectangle.</param>
            <returns>A new rectangle whose height is modified by the given delta-change value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.ChangeSize(System.Int32,System.Int32)">
            <summary>
            Creates and returns a new rectangle whose position is the same as the current one, but
            has its width and height changed by the given delta-change values.
            </summary>
            <param name="deltaWidth">Delta-change for the width of the new rectangle.</param>
            <param name="deltaHeight">Delta-change for the height of the new rectangle.</param>
            <returns>
            A new rectangle whose width/height are modified by the given delta-change values.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.ChangeSize(GoRogue.Coord)">
            <summary>
            Creates and returns a new rectangle whose position is the same as the current one, but
            has its width and height changed by the given delta-change values.
            </summary>
            <param name="deltaChange">
            Vector (deltaWidth, deltaHeight) specifying the delta-change values for the width/height
            of the new Rectangle.
            </param>
            <returns>
            A new rectangle whose width/height are modified by the given delta-change values.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.ChangeWidth(System.Int32)">
            <summary>
            Creates and returns a new rectangle whose position is the same as the current one, but
            has its width changed by the given delta-change value.
            </summary>
            <param name="deltaWidth">Delta-change for the width of the new rectangle.</param>
            <returns>A new rectangle whose width is modified by the given delta-change value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.Contains(GoRogue.Coord)">
            <summary>
            Returns whether or not the specified point is considered within the rectangle.
            </summary>
            <param name="position">The position to check.</param>
            <returns>Whether or not the specified point is considered within the rectangle.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.Contains(System.Int32,System.Int32)">
            <summary>
            Returns whether or not the specified point is considered within the rectangle.
            </summary>
            <param name="x">The x-value position to check.</param>
            <param name="y">The y-value position to check.</param>
            <returns>Whether or not the specified point is considered within the rectangle.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.Contains(GoRogue.Rectangle)">
            <summary>
            Returns whether or not the specified rectangle is considered completely contained within
            the current one.
            </summary>
            <param name="other">The rectangle to check.</param>
            <returns>
            True if the given rectangle is completely contained within the current one, false otherwise.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.Equals(GoRogue.Rectangle)">
            <summary>
            Compares based upon whether or not the areas contained within the rectangle are identical
            in both position and extents.
            </summary>
            <param name="other"/>
            <returns>
            true if the area of the two rectangles encompass the exact same area, false otherwise.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.Equals(System.Object)">
            <summary>
            Compares to an arbitrary object.
            </summary>
            <param name="obj"/>
            <returns>
            true if the object specified is a rectangle instance and encompasses the same area, false otherwise.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.Expand(System.Int32,System.Int32)">
            <summary>
            Returns a new rectangle, expanded to include the additional specified number of tiles on
            the left/right and top/bottom.
            </summary>
            <param name="horizontalChange">
            Number of additional tiles to include on the left/right of the rectangle.
            </param>
            <param name="verticalChange">
            Number of additional tiles to include on the top/bottom of the rectangle.
            </param>
            <returns>A new rectangle, expanded appropriately.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.GetHashCode">
            <summary>
            Simple hashing.
            </summary>
            <returns>Hash code for rectangle.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.Intersects(GoRogue.Rectangle)">
            <summary>
            Returns whether or not the given rectangle intersects the current one.
            </summary>
            <param name="other">The rectangle to check.</param>
            <returns>True if the given rectangle intersects with the current one, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithPosition(GoRogue.Coord)">
            <summary>
            Creates and returns a new rectangle that has its <see cref="P:GoRogue.Rectangle.Position"/> moved to the given position.
            </summary>
            <param name="position">The position for the new rectangle.</param>
            <returns>A new rectangle that has its position changed to the given value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithPosition(System.Int32,System.Int32)">
            <summary>
            Creates and returns a new rectangle that has its position moved to the given position.
            </summary>
            <param name="x">X-value for the position of the new rectangle.</param>
            <param name="y">Y-value for the position of the new rectangle.</param>
            <returns>A new rectangle with the position changed to the given value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.Translate(GoRogue.Direction)">
            <summary>
            Creates and returns a new rectangle that has its position moved in the given direction.
            </summary>
            <param name="direction">The direction to move the new rectangle in.</param>
            <returns>A new rectangle that has its position moved in the given direction.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithX(System.Int32)">
            <summary>
            Creates and returns a new rectangle that has its X value moved to the given x-coordinate.
            </summary>
            <param name="x">The X value for the new rectangle.</param>
            <returns>A new rectangle with X changed to the given value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithY(System.Int32)">
            <summary>
            Creates and returns a new rectangle that has its Y value moved to the given y-coordinate.
            </summary>
            <param name="y">The Y value for the new rectangle.</param>
            <returns>A new rectangle with Y changed to the given value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.Positions">
            <summary>
            Returns all positions in the rectangle.
            </summary>
            <returns>All positions in the rectangle.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.RandomPosition(Troschuetz.Random.IGenerator)">
            <summary>
            Returns a random position from within this rectangle.
            </summary>
            <param name="rng">The rng to use. Defaults to <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>.</param>
            <returns>A random position from within the rectangle.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.RandomPosition(System.Func{GoRogue.Coord,System.Boolean},Troschuetz.Random.IGenerator)">
            <summary>
            Returns a random position from within this rectangle, for which the selector function
            specified returns true.  Random positions will continuously be generated until one that
            qualifies is found.
            </summary>
            <param name="selector">
            Selector function that takes a position, and returns true if it is an acceptable selection,
            and false otherwise.
            </param>
            <param name="rng">The rng to use. Defaults to <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>.</param>
            <returns>
            A random position from within the rectangle, for which the given selector function
            returned true.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.RandomPosition(System.Func{GoRogue.Rectangle,GoRogue.Coord,System.Boolean},Troschuetz.Random.IGenerator)">
            <summary>
            Returns a random position from within this rectangle, for which the selector function
            specified returns true.  Random positions will continuously be generated until one that
            qualifies is found.
            </summary>
            <param name="selector">
            Selector function that takes a position and a rectangle, and returns true if it is an
            acceptable selection, and false otherwise.
            </param>
            <param name="rng">The rng to use. Defaults to <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>.</param>
            <returns>
            A random position from within the rectangle, for which the given selector function
            returned true.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithHeight(System.Int32)">
            <summary>
            Creates and returns a new rectangle that has the same position and width as the current
            one, but with the height changed to the given value.
            </summary>
            <param name="height">The height for the new rectangle.</param>
            <returns>A new rectangle with its height changed to the given value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithMaxExtent(GoRogue.Coord)">
            <summary>
            Creates and returns a new rectangle that has been shrunk/expanded as necessary, such that
            the maximum extent is the specified value.
            </summary>
            <param name="maxExtent">The maximum extent of the new rectangle.</param>
            <returns>A new rectangle that has its maximum extent adjusted to the specified value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithMaxExtent(System.Int32,System.Int32)">
            <summary>
            Creates and returns a new rectangle that has been shrunk/expanded as necessary, such that
            the maximum extent is the specified value.
            </summary>
            <param name="x">The x-value for the minimum extent of the new rectangle.</param>
            <param name="y">The y-value for the minimum extent of the new rectangle.</param>
            <returns>A new rectangle that has its maximum extent adjusted to the specified value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithMaxExtentX(System.Int32)">
            <summary>
            Creates and returns a new rectangle that has been shrunk/expanded as necessary, such that
            the x-value of maximum extent is changed to the specified value.
            </summary>
            <param name="x">The x-coordinate for the maximum extent of the new rectangle.</param>
            <returns>A new rectangle, with its <see cref="P:GoRogue.Rectangle.MaxExtentX"/> adjusted to the specified value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithMaxExtentY(System.Int32)">
            <summary>
            Creates and returns a new rectangle that has been shrunk/expanded as necessary, such that
            the y-value of maximum extent is changed to the specified value.
            </summary>
            <param name="y">The y-coordinate for the maximum extent of the new rectangle.</param>
            <returns>A new rectangle, with its <see cref="P:GoRogue.Rectangle.MaxExtentY"/> adjusted to the specified value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithMinExtent(GoRogue.Coord)">
            <summary>
            Creates and returns a new rectangle that has been shrunk/expanded as necessary, such that
            the minimum extent is the specified value.
            </summary>
            <param name="minExtent">The minimum extent of the new rectangle.</param>
            <returns>A new rectangle that has its minimum extent adjusted to the specified value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithMinExtent(System.Int32,System.Int32)">
            <summary>
            Creates and returns a new rectangle that has been shrunk/expanded as necessary, such that
            the minimum extent is the specified value.
            </summary>
            <param name="x">The x-value for the minimum extent of the new rectangle.</param>
            <param name="y">The y-value for the minimum extent of the new rectangle.</param>
            <returns>A new rectangle that has its minimum extent adjusted to the specified value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithMinExtentX(System.Int32)">
            <summary>
            Creates and returns a new rectangle that has been shrunk/expanded as necessary, such that
            the x-value of minimum extent is changed to the specified value.
            </summary>
            <param name="x">The x-coordinate for the minimum extent of the new rectangle.</param>
            <returns>A new rectangle, with its <see cref="P:GoRogue.Rectangle.MinExtentX"/> adjusted to the specified value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithMinExtentY(System.Int32)">
            <summary>
            Creates and returns a new rectangle that has been shrunk/expanded as necessary, such that
            the y-value of minimum extent is changed to the specified value.
            </summary>
            <param name="y">The y-coordinate for the minimum extent of the new rectangle.</param>
            <returns>A new rectangle, with its <see cref="P:GoRogue.Rectangle.MinExtentY"/> adjusted to the specified value.</returns>
            &gt;
        </member>
        <member name="M:GoRogue.Rectangle.WithSize(System.Int32,System.Int32)">
            <summary>
            Creates and returns a new rectangle whose position is the same as the current one, but
            has the specified width and height.
            </summary>
            <param name="width">The width for the new rectangle.</param>
            <param name="height">The height for the new rectangle.</param>
            <returns>A new rectangle with the given width and height.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithSize(GoRogue.Coord)">
            <summary>
            Creates and returns a new rectangle whose position is the same as the current one, but
            has the specified width and height.
            </summary>
            <param name="size">Vector (width, height) specifying the width/height of the new rectangle.</param>
            <returns>A new rectangle with the given width and height.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.WithWidth(System.Int32)">
            <summary>
            Creates and returns a new rectangle that is exactly the same as the current one, but with
            the width changed to the given value.
            </summary>
            <param name="width">The width for the new rectangle.</param>
            <returns>A new rectangle with its <see cref="F:GoRogue.Rectangle.Width"/> changed to the given value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.ToString">
            <summary>
            Returns a string representing the rectangle, formatted as
            (<see cref="F:GoRogue.Rectangle.X"/>, <see cref="F:GoRogue.Rectangle.Y"/>) -&gt; (<see cref="P:GoRogue.Rectangle.MaxExtentX"/>, <see cref="P:GoRogue.Rectangle.MaxExtentY"/>)
            </summary>
            <returns>String formatted as above.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.Translate(GoRogue.Coord)">
            <summary>
            Creates and returns a new rectangle whose position has been moved by the given
            delta-change values.
            </summary>
            <param name="deltaChange">Delta-x and delta-y values by which to move the new rectangle.</param>
            <returns>
            A new rectangle, whose position has been moved by the given delta-change values.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.Translate(System.Int32,System.Int32)">
            <summary>
            Creates and returns a new rectangle whose position has been moved by the given
            delta-change values.
            </summary>
            <param name="dx">Delta-x value by which to move the new rectangle.</param>
            <param name="dy">Delta-y value by which to move the new rectangle.</param>
            <returns>
            A new rectangle, whose position has been moved by the given delta-change values.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.TranslateX(System.Int32)">
            <summary>
            Creates and returns a new rectangle whose x-position has been moved by the given delta value.
            </summary>
            <param name="dx">Value by which to move the new rectangle's x-position.</param>
            <returns>A new rectangle, whose x-position has been moved by the given delta-x value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.TranslateY(System.Int32)">
            <summary>
            Creates and returns a new rectangle whose y-position has been moved by the given delta value.
            </summary>
            <param name="dy">Value by which to move the new rectangle's y-position.</param>
            <returns>A new rectangle, whose y-position has been moved by the given delta-y value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.op_Implicit(GoRogue.Rectangle)~Microsoft.Xna.Framework.Rectangle">
            <summary>
            Implicitly converts a GoRogue Rectangle to an equivalent MonoGame Rectangle.
            </summary>
            <param name="rect" />
            <returns />
        </member>
        <member name="M:GoRogue.Rectangle.op_Implicit(Microsoft.Xna.Framework.Rectangle)~GoRogue.Rectangle">
            <summary>
            Implicitly converts a MonoGame Rectangle to an equivalent GoRogue Rectangle.
            </summary>
            <param name="rect" />
            <returns />
        </member>
        <member name="M:GoRogue.Rectangle.op_Equality(GoRogue.Rectangle,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            True if the two rectangles represent the same area.
            </summary>
            <param name="r1"></param>
            <param name="r2"></param>
            <returns>True if the two rectangles are equal, false if not.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.op_Inequality(GoRogue.Rectangle,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            True if any of the rectangles' x/y/width/height values are not equal.
            </summary>
            <param name="r1"></param>
            <param name="r2"></param>
            <returns>
            True if any of the x/y/width/height values are not equal, false if they are all equal.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.op_Equality(Microsoft.Xna.Framework.Rectangle,GoRogue.Rectangle)">
            <summary>
            True if the two rectangles represent the same area.
            </summary>
            <param name="r1"></param>
            <param name="r2"></param>
            <returns>True if the two rectangles are equal, false if not.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.op_Inequality(Microsoft.Xna.Framework.Rectangle,GoRogue.Rectangle)">
            <summary>
            True if any of the rectangles' x/y/width/height values are not equal.
            </summary>
            <param name="r1"></param>
            <param name="r2"></param>
            <returns>
            True if any of the x/y/width/height values are not equal, false if they are all equal.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.op_Implicit(GoRogue.Rectangle)~System.Drawing.Rectangle">
            <summary>
            Implicitly converts a GoRogue Rectangle to an equivalent System.Drawing.Rectangle.
            </summary>
            <param name="rect" />
            <returns />
        </member>
        <member name="M:GoRogue.Rectangle.op_Implicit(System.Drawing.Rectangle)~GoRogue.Rectangle">
            <summary>
            Implicitly converts a System.Drawing.Rectangle to an equivalent GoRogue Rectangle.
            </summary>
            <param name="rect" />
            <returns />
        </member>
        <member name="M:GoRogue.Rectangle.op_Implicit(GoRogue.Rectangle)~System.Drawing.RectangleF">
            <summary>
            Implicitly converts a GoRogue Rectangle to an equivalent System.Drawing.RectangleF.
            </summary>
            <param name="rect" />
            <returns />
        </member>
        <member name="M:GoRogue.Rectangle.op_Equality(GoRogue.Rectangle,System.Drawing.Rectangle)">
            <summary>
            True if the two rectangles represent the same area.
            </summary>
            <param name="r1"></param>
            <param name="r2"></param>
            <returns>True if the two rectangles are equal, false if not.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.op_Inequality(GoRogue.Rectangle,System.Drawing.Rectangle)">
            <summary>
            True if any of the rectangles' x/y/width/height values are not equal.
            </summary>
            <param name="r1"></param>
            <param name="r2"></param>
            <returns>
            True if any of the x/y/width/height values are not equal, false if they are all equal.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.op_Equality(System.Drawing.Rectangle,GoRogue.Rectangle)">
            <summary>
            True if the two rectangles represent the same area.
            </summary>
            <param name="r1"></param>
            <param name="r2"></param>
            <returns>True if the two rectangles are equal, false if not.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.op_Inequality(System.Drawing.Rectangle,GoRogue.Rectangle)">
            <summary>
            True if any of the rectangles' x/y/width/height values are not equal.
            </summary>
            <param name="r1"></param>
            <param name="r2"></param>
            <returns>
            True if any of the x/y/width/height values are not equal, false if they are all equal.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.op_Equality(GoRogue.Rectangle,System.Drawing.RectangleF)">
            <summary>
            True if the two rectangles represent the same area.
            </summary>
            <param name="r1"></param>
            <param name="r2"></param>
            <returns>True if the two rectangles are equal, false if not.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.op_Inequality(GoRogue.Rectangle,System.Drawing.RectangleF)">
            <summary>
            True if any of the rectangles' x/y/width/height values are not equal.
            </summary>
            <param name="r1"></param>
            <param name="r2"></param>
            <returns>
            True if any of the x/y/width/height values are not equal, false if they are all equal.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.op_Equality(System.Drawing.RectangleF,GoRogue.Rectangle)">
            <summary>
            True if the two rectangles represent the same area.
            </summary>
            <param name="r1"></param>
            <param name="r2"></param>
            <returns>True if the two rectangles are equal, false if not.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.op_Inequality(System.Drawing.RectangleF,GoRogue.Rectangle)">
            <summary>
            True if any of the rectangles' x/y/width/height values are not equal.
            </summary>
            <param name="r1"></param>
            <param name="r2"></param>
            <returns>
            True if any of the x/y/width/height values are not equal, false if they are all equal.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.op_Implicit(GoRogue.Rectangle)~System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32}">
            <summary>
            Implicitly converts a GoRogue Rectangle to an equivalent tuple of 4 integers (x, y, width, height).
            </summary>
            <param name="rect" />
            <returns />
        </member>
        <member name="M:GoRogue.Rectangle.op_Implicit(System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32})~GoRogue.Rectangle">
            <summary>
            Implicitly converts a tuple of 4 integers (x, y, width, height) to an equivalent GoRogue Rectangle.
            </summary>
            <param name="tuple" />
            <returns />
        </member>
        <member name="M:GoRogue.Rectangle.Deconstruct(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Adds support for C# Deconstruction syntax.
            </summary>
            <param name="x" />
            <param name="y" />
            <param name="width" />
            <param name="height" />
        </member>
        <member name="M:GoRogue.Rectangle.op_Equality(GoRogue.Rectangle,System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32})">
            <summary>
            True if the two rectangles represent the same area.
            </summary>
            <param name="r1"></param>
            <param name="r2"></param>
            <returns>True if the two rectangles are equal, false if not.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.op_Inequality(GoRogue.Rectangle,System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32})">
            <summary>
            True if any of the rectangles' x/y/width/height values are not equal.
            </summary>
            <param name="r1"></param>
            <param name="r2"></param>
            <returns>
            True if any of the x/y/width/height values are not equal, false if they are all equal.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.op_Equality(System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32},GoRogue.Rectangle)">
            <summary>
            True if the two rectangles represent the same area.
            </summary>
            <param name="r1"></param>
            <param name="r2"></param>
            <returns>True if the two rectangles are equal, false if not.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.op_Inequality(System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32},GoRogue.Rectangle)">
            <summary>
            True if any of the rectangles' x/y/width/height values are not equal.
            </summary>
            <param name="r1"></param>
            <param name="r2"></param>
            <returns>
            True if any of the x/y/width/height values are not equal, false if they are all equal.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.Equals(System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32})">
            <summary>
            True if the given position has equal x and y values to the current one.
            </summary>
            <param name="other">Point to compare.</param>
            <returns>True if the two positions are equal, false if not.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.PerimeterPositions">
            <summary>
            Gets all positions that reside on the inner perimeter of the rectangle.
            </summary>
            <returns>IEnumerable of all positions that reside on the inner perimeter of the rectangle.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.MinYPositions">
            <summary>
            Gets all positions that reside on the min-y line of the rectangle.
            </summary>
            <returns>IEnumerable of all positions that lie on the min-y line of the rectangle.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.MaxYPositions">
            <summary>
            Gets all positions that reside on the max-y line of the rectangle.
            </summary>
            <returns>IEnumerable of all positions that lie on the max-y line of the rectangle.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.MinXPositions">
            <summary>
            Gets all positions that reside on the min-x line of the rectangle.
            </summary>
            <returns>IEnumerable of all positions that lie on the min-x line of the rectangle.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.MaxXPositions">
            <summary>
            Gets all positions that reside on the max-x line of the rectangle.
            </summary>
            <returns>IEnumerable of all positions that lie on the max-x line of the rectangle.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.PositionsOnSide(GoRogue.Direction)">
            <summary>
            Gets an IEnumerable of all positions that line on the inner perimiter of the rectangle,
            on the given side of the rectangle.
            </summary>
            <param name="side">Side to get positions for.</param>
            <returns>IEnumerable of all positions that line on the inner perimieter of the rectangle on the given side.</returns>
        </member>
        <member name="T:GoRogue.Reflection">
            <summary>
            Contains a series of functions that complement the reflection capabilities of C#, to conveniently allow for things like
            iterating over all types that a given type can be casted to.
            </summary>
        </member>
        <member name="M:GoRogue.Reflection.GetRuntimeTypeTree(System.Object)">
            <summary>
            Gets the entire inheritanc/interface tree for the actual run-time type of the object passed in.  This will include
            a type representing the actual run-time type of the object, as well as a type representing each superclass
            of that runtime type, and each interface that runtime type or one of its superclasses implement.
            </summary>
            <param name="obj">Object to return type tree for.</param>
            <returns>The complete inheritance/interface tree for the runtime-type of the object passed in, including the runtime type itself,
            and all superclasses of that type, as well as Type objects for each interface that runtime type or its superclasses implement.</returns>
        </member>
        <member name="M:GoRogue.Reflection.GetTypeTree``1">
            <summary>
            Gets the entire inheritance/interface tree for type T.  This will include a Type that represents type T, as well
            as a Type representing each superclass of T, and each interface that T or its superclasses implement.
            </summary>
            <remarks>
            This function may be somewhat expensive to compute, so if you plan to use it frequently it is recommended to cache
            the results.
            </remarks>
            <typeparam name="T">Type to get inheritance/interface tree for.</typeparam>
            <returns>The complete interface/inheritance tree of T, including T, all superclasses, and all interfaces T or its
            superclasses implement.</returns>
        </member>
        <member name="M:GoRogue.Reflection.GetTypeTree(System.Type)">
            <summary>
            Gets the entire inheritance/interface tree for the type specified.  This will include the <paramref name="type"/> itself, 
            as well as a Type representing each superclass of the type represented by <paramref name="type"/>, and each
            interface that <paramref name="type"/> or its superclasses implement.
            </summary>
            <remarks>
            This function may be somewhat expensive to compute, so if you plan to use it frequently it is recommended to cache
            the results.
            </remarks>
            <returns>The complete interface/inheritance for the type represented by <paramref name="type"/>, including <paramref name="type"/>,
            all superclasses, and all interfaces T or its superclasses implement.</returns>
        </member>
        <member name="T:GoRogue.SenseMapping.IReadOnlySenseMap">
            <summary>
            Read-only interface of a <see cref="T:GoRogue.SenseMapping.SenseMap"/>.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.IReadOnlySenseMap.CurrentSenseMap">
            <summary>
            IEnumerable of only positions currently "in" the sense map, eg. all positions that have a
            value other than 0.0.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.IReadOnlySenseMap.NewlyInSenseMap">
            <summary>
            IEnumerable of positions that DO have a non-zero value in the sense map as of the most
            current Calculate call, but DID NOT have a non-zero value after the previous time
            Calculate was called.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.IReadOnlySenseMap.NewlyOutOfSenseMap">
            <summary>
            IEnumerable of positions that DO NOT have a non-zero value in the sense map as of the
            most current Calculate call, but DID have a non-zero value after the previous time
            Calculate was called.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.IReadOnlySenseMap.SenseSources">
            <summary>
            Read-only list of all sources currently considered part of the sense map. Some may have their
            <see cref="P:GoRogue.SenseMapping.SenseSource.Enabled"/> flag set to false, so all of these may or may not be counted
            when Calculate is called.
            </summary>
        </member>
        <member name="T:GoRogue.SenseMapping.SenseMap">
            <summary>
            Class responsible for calculating a map for senses (sound, light, etc), or generally anything
            that can be modeled as sources propegating through a map that has degrees of resistance to spread.
            </summary>
            <remarks>
            Generally, this class can be used to model the result of applying ripple-like or shadowcasting-like
            "spreading" of values from one or more sources through a map.  This can include modeling the spreading
            of light, sound, heat for a heatmap, etc. through a map.  You create one or more <see cref="T:GoRogue.SenseMapping.SenseSource"/>
            instances representing your various sources, add them to the SenseMap, and call <see cref="M:GoRogue.SenseMapping.SenseMap.Calculate"/>
            when you wish to re-calculate the SenseMap.
            
            Like most GoRogue algorithm implementations, SenseMap takes as a construction parameter an IMapView that represents
            the map.  Specifically, it takes an <see cref="T:GoRogue.MapViews.IMapView`1"/>, where the double value at each location
            represents the "resistance" that location has to the passing of source values through it.  The values must be >= 0.0,
            where 0.0 means that a location has no resistance to spreading of source values, and greater values represent greater
            resistance.  The scale of this resistance is arbitrary, and is related to the <see cref="P:GoRogue.SenseMapping.SenseSource.Intensity"/> of
            your sources.  As a source spreads through a given location, a value equal to the resistance value of that location
            is subtracted from the source's value (plus the normal fallof for distance).
            
            The map can be calculated by calling the <see cref="M:GoRogue.SenseMapping.SenseMap.Calculate"/> function.
            
            This class exposes the resulting sensory values values to you via indexers -- SenseMap implements
            <see cref="T:GoRogue.MapViews.IMapView`1"/>, where 0.0 indicates no sources were able to spread to the given location (eg, either it was
            stopped or fell off due to distance), and a value greater than 0.0 indicates the combined intensity of any sources
            that reached the given location.
            </remarks>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.#ctor(GoRogue.MapViews.IMapView{System.Double})">
            <summary>
            Constructor. Takes the resistance map to use for calculations.
            </summary>
            <param name="resMap">The resistance map to use for calculations.</param>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.CurrentSenseMap">
            <summary>
            IEnumerable of only positions currently "in" the SenseMap, eg. all positions that have a
            value other than 0.0.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.Height">
            <summary>
            Height of sense map.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.NewlyInSenseMap">
            <summary>
            IEnumerable of positions that DO have a non-zero value in the sense map as of the most
            current <see cref="M:GoRogue.SenseMapping.SenseMap.Calculate"/> call, but DID NOT have a non-zero value after the previous time
            <see cref="M:GoRogue.SenseMapping.SenseMap.Calculate"/> was called.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.NewlyOutOfSenseMap">
            <summary>
            IEnumerable of positions that DO NOT have a non-zero value in the sense map as of the
            most current <see cref="M:GoRogue.SenseMapping.SenseMap.Calculate"/> call, but DID have a non-zero value after the previous time
            <see cref="M:GoRogue.SenseMapping.SenseMap.Calculate"/> was called.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.SenseSources">
            <summary>
            Read-only list of all sources currently considered part of the SenseMap. Some may have their
            <see cref="P:GoRogue.SenseMapping.SenseSource.Enabled"/> flag set to false, so all of these may or may not be counted
            when <see cref="M:GoRogue.SenseMapping.SenseMap.Calculate"/> is called.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.Width">
            <summary>
            Width of the sense map.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.Item(System.Int32)">
            <summary>
            Returns the "sensory value" for the given position.
            </summary>
            <param name="index1D">Position to return the sensory value for, as a 1d-index-style value.</param>
            <returns>The sense-map value for the given position.</returns>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.Item(GoRogue.Coord)">
            <summary>
            Returns the "sensory value" for the given position.
            </summary>
            <param name="pos">The position to return the sensory value for.</param>
            <returns>The sensory value for the given position.</returns>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.Item(System.Int32,System.Int32)">
            <summary>
            Returns the "sensory value" for the given position.
            </summary>
            <param name="x">X-coordinate of the position to return the sensory value for.</param>
            <param name="y">Y-coordinate of the position to return the sensory value for.</param>
            <returns>The sensory value for the given position.</returns>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.AddSenseSource(GoRogue.SenseMapping.SenseSource)">
            <summary>
            Adds the given source to the list of sources. If the source has its
            <see cref="P:GoRogue.SenseMapping.SenseSource.Enabled"/> flag set when <see cref="M:GoRogue.SenseMapping.SenseMap.Calculate"/> is next called, then
            it will be counted as a source.
            </summary>
            <param name="senseSource">The source to add.</param>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.AsReadOnly">
            <summary>
            Returns a read-only representation of the SenseMap.
            </summary>
            <returns>This SenseMap object as <see cref="T:GoRogue.SenseMapping.IReadOnlySenseMap"/>.</returns>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.Calculate">
            <summary>
            Calcuates the map.  For each enabled source in the source list, it calculates
            the source's spreading, and puts them all together in the sense map's output.
            </summary>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.GetEnumerator">
            <summary>
            Enumerator, in case you want to use this as a list of doubles.
            </summary>
            <returns>Enumerable of doubles (the sensory values).</returns>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.ToString(System.Char,System.Char,System.Char)">
            <summary>
            ToString that customizes the characters used to represent the map.
            </summary>
            <param name="normal">The character used for any location not in the SenseMap.</param>
            <param name="center">
            The character used for any location that is the center-point of a source.
            </param>
            <param name="sourceValue">
            The character used for any location that is in range of a source, but not a center point.
            </param>
            <returns>The string representation of the SenseMap, using the specified characters.</returns>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.ToString">
            <summary>
            Returns a string representation of the map, where any location not in the SenseMap is
            represented by a '-' character, any position that is the center of some source is
            represented by a 'C' character, and any position that has a non-zero value but is not a
            center is represented by an 'S'.
            </summary>
            <returns>A (multi-line) string representation of the SenseMap.</returns>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.ToString(System.Int32)">
            <summary>
            Returns a string representation of the map, with the actual values in the SenseMap,
            rounded to the given number of decimal places.
            </summary>
            <param name="decimalPlaces">The number of decimal places to round to.</param>
            <returns>
            A string representation of the map, rounded to the given number of decimal places.
            </returns>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Generic enumerator.
            </summary>
            <returns>Enumerator for looping.</returns>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.RemoveSenseSource(GoRogue.SenseMapping.SenseSource)">
            <summary>
            Removes the given source from the list of sources. Genearlly, use this if a source is permanently removed
            from a map. For temporary disabling, you should generally use the <see cref="P:GoRogue.SenseMapping.SenseSource.Enabled"/> flag.
            </summary>
            <remarks>
            The source values that this sense source was responsible for are NOT removed from the sensory output values
            until <see cref="M:GoRogue.SenseMapping.SenseMap.Calculate"/> is next called.
            </remarks>
            <param name="senseSource">The source to remove.</param>
        </member>
        <member name="T:GoRogue.SenseMapping.SourceType">
            <summary>
            Different types of algorithms that model how source values spread from their source's location.
            </summary>
        </member>
        <member name="F:GoRogue.SenseMapping.SourceType.RIPPLE">
            <summary>
            Performs calculation by pushing values out from the source location. Source values spread
            around corners a bit.
            </summary>
        </member>
        <member name="F:GoRogue.SenseMapping.SourceType.RIPPLE_LOOSE">
            <summary>
            Similar to <see cref="F:GoRogue.SenseMapping.SourceType.RIPPLE"/> but with different spread mechanics. Values spread around edges like
            smoke or water, but maintains a tendency to curl towards the start position as it goes around edges.
            </summary>
        </member>
        <member name="F:GoRogue.SenseMapping.SourceType.RIPPLE_TIGHT">
            <summary>
            Similar to <see cref="F:GoRogue.SenseMapping.SourceType.RIPPLE"/>, but values spread around corners only very slightly.
            </summary>
        </member>
        <member name="F:GoRogue.SenseMapping.SourceType.RIPPLE_VERY_LOOSE">
            <summary>
            Similar to <see cref="F:GoRogue.SenseMapping.SourceType.RIPPLE"/>, but values spread around corners a lot.
            </summary>
        </member>
        <member name="F:GoRogue.SenseMapping.SourceType.SHADOW">
            <summary>
            Uses a Shadowcasting algorithm. All partially resistant grid locations are treated as
            being fully transparent (it's on-off blocking, where a value greater than or equal to the
            source's <see cref="P:GoRogue.SenseMapping.SenseSource.Intensity"/> in the resistance map blocks, and all lower
            values don't).
            </summary>
        </member>
        <member name="T:GoRogue.SenseMapping.SenseSource">
            <summary>
            Represents a source location to be used in a <see cref="T:GoRogue.SenseMapping.SenseMap"/>. 
            </summary>
            <remarks>
            Typically, you create these, and then call <see cref="M:GoRogue.SenseMapping.SenseMap.AddSenseSource(GoRogue.SenseMapping.SenseSource)"/>
            to add them to a sensory map, and perhaps retain a reference for the sake of moving it
            around or toggling it on-off.  Note that changing values such as <see cref="P:GoRogue.SenseMapping.SenseSource.Position"/> and
            <see cref="P:GoRogue.SenseMapping.SenseSource.Radius"/> after the source is created is possible, however changes will not be
            reflected in any <see cref="T:GoRogue.SenseMapping.SenseMap"/> instances using this source until their next call
            to <see cref="M:GoRogue.SenseMapping.SenseMap.Calculate"/>.
            </remarks>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseSource.#ctor(GoRogue.SenseMapping.SourceType,GoRogue.Coord,System.Double,GoRogue.Distance,System.Double)">
            <summary>
            Constructor.
            </summary>
            <param name="type">The spread mechanics to use for source values.</param>
            <param name="position">The position on a map that the source is located at.</param>
            <param name="radius">
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:GoRogue.Distance"/>, such as <see cref="P:GoRogue.SenseMapping.SenseSource.Radius"/>).
            </param>
            <param name="intensity">The starting intensity value of the source. Defaults to 1.0.</param>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseSource.#ctor(GoRogue.SenseMapping.SourceType,GoRogue.Coord,System.Double,GoRogue.Distance,System.Double,System.Double,System.Double)">
            <summary>
            Constructor.  Creates a source whose spreading is restricted to a certain angle and span.
            </summary>
            <param name="type">The spread mechanics to use for source values.</param>
            <param name="position">The position on a map that the source is located at.</param>
            <param name="radius">
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:GoRogue.Distance"/>, such as <see cref="P:GoRogue.SenseMapping.SenseSource.Radius"/>).
            </param>
            <param name="angle">The angle in degrees that specifies the outermost center point of the cone formed
            by the source's values. 0 degrees points right.</param>
            <param name="span">
            The angle, in degrees, that specifies the full arc contained in the cone formed by the source's values --
            <paramref name="angle"/> / 2 degrees are included on either side of the cone's center line.
            </param>
            <param name="intensity">The starting intensity value of the source. Defaults to 1.0.</param>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseSource.#ctor(GoRogue.SenseMapping.SourceType,System.Int32,System.Int32,System.Double,GoRogue.Distance,System.Double,System.Double,System.Double)">
            <summary>
            Constructor.  Creates a source whose spread is restricted to a certain angle and span.
            </summary>
            <param name="type">The spread mechanics to use for source values.</param>
            <param name="positionX">The x-value for the position on a map that the source is located at.</param>
            <param name="positionY">The y-value for the position on a map that the source is located at.</param>
            <param name="radius">
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:GoRogue.Distance"/>, such as <see cref="P:GoRogue.SenseMapping.SenseSource.Radius"/>).
            </param>
            <param name="angle">The angle in degrees that specifies the outermost center point of the cone formed
            by the source's values. 0 degrees points right.</param>
            <param name="span">
            The angle, in degrees, that specifies the full arc contained in the cone formed by the source's values --
            <paramref name="angle"/> / 2 degrees are included on either side of the cone's center line.
            </param>
            <param name="intensity">The starting intensity value of the source. Defaults to 1.0.</param>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseSource.#ctor(GoRogue.SenseMapping.SourceType,System.Int32,System.Int32,System.Double,GoRogue.Distance,System.Double)">
            <summary>
            Constructor.
            </summary>
            <param name="type">The spread mechanics to use for source values.</param>
            <param name="positionX">
            The X-value of the position on a map that the source is located at.
            </param>
            <param name="positionY">
            The Y-value of the position on a map that the source is located at.
            </param>
            <param name="radius">
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:GoRogue.Distance"/>, such as <see cref="P:GoRogue.SenseMapping.SenseSource.Radius"/>).
            </param>
            <param name="intensity">The starting intensity value of the source. Defaults to 1.0.</param>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseSource.DistanceCalc">
            <summary>
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:GoRogue.Distance"/>, such as <see cref="T:GoRogue.Radius"/>).
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseSource.Enabled">
            <summary>
            Whether or not this source is enabled. If a source is disabled when <see cref="M:GoRogue.SenseMapping.SenseMap.Calculate"/>
            is called, the source does not calculate values and is effectively assumed to be "off".
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseSource.Position">
            <summary>
            The position on a map that the source is located at.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseSource.IsAngleRestricted">
            <summary>
            Whether or not the spreading of values from this source is restricted to an angle and span.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseSource.Intensity">
            <summary>
            The starting value of the source to spread.  Defaults to 1.0.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseSource.Angle">
            <summary>
            If <see cref="P:GoRogue.SenseMapping.SenseSource.IsAngleRestricted"/> is true, the angle in degrees that represents a line from the source's start to
            the outermost center point of the cone formed by the source's calculated values.  0 degrees points right.
            Otherwise, this will be 0.0 degrees.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseSource.Span">
            <summary>
            If <see cref="P:GoRogue.SenseMapping.SenseSource.IsAngleRestricted"/> is true, the angle in degrees that represents the full arc of the cone formed by
            the source's calculated values.  Otherwise, it will be 360 degrees.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseSource.Radius">
            <summary>
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed. Changing this will trigger
            resizing (re-allocation) of the underlying arrays.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseSource.Type">
            <summary>
            The spread mechanics to use for source values.
            </summary>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseSource.ToString">
            <summary>
            Returns a string representation of the configuration of this SenseSource.
            </summary>
            <returns>A string representation of the configuration of this SenseSource.</returns>
        </member>
        <member name="T:GoRogue.AdvancedSpatialMap`1">
            <summary>
            A more complex version of <see cref="T:GoRogue.SpatialMap`1"/> that does not require the items in it to implement
            <see cref="T:GoRogue.IHasID"/>, instead requiring the specification of a custom <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>
            to use for hashing and comparison of items.
            </summary>
            <remarks>
            This class is useful for cases where you do not want to implement <see cref="T:GoRogue.IHasID"/>, or if you need
            to use a value type in a spatial map. For simple cases, it is recommended to use <see cref="T:GoRogue.SpatialMap`1"/>
            instead.
            
            Be mindful of the efficiency of your hashing function specified in the <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> --
            it will in large part determine the performance of AdvancedSpatialMap!
            </remarks>
            <typeparam name="T">The type of object that will be contained by this AdvancedSpatialMap.</typeparam>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="comparer">
            Equality comparer to use for comparison and hashing of type T. Be especially mindful of the
            efficiency of its GetHashCode function, as it will determine the efficiency of many AdvancedSpatialMap
            functions.
            </param>
            <param name="initialCapacity">
            The initial maximum number of elements the AdvancedSpatialMap can hold before it has to
            internally resize data structures. Defaults to 32.
            </param>
        </member>
        <member name="E:GoRogue.AdvancedSpatialMap`1.ItemAdded">
            <summary>
            See <see cref="E:GoRogue.IReadOnlySpatialMap`1.ItemAdded"/>.
            </summary>
        </member>
        <member name="E:GoRogue.AdvancedSpatialMap`1.ItemMoved">
            <summary>
            See <see cref="E:GoRogue.IReadOnlySpatialMap`1.ItemMoved"/>.
            </summary>
        </member>
        <member name="E:GoRogue.AdvancedSpatialMap`1.ItemRemoved">
            <summary>
            See <see cref="E:GoRogue.IReadOnlySpatialMap`1.ItemRemoved"/>.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedSpatialMap`1.Count">
            <summary>
            See <see cref="P:GoRogue.IReadOnlySpatialMap`1.Count"/>.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedSpatialMap`1.Items">
            <summary>
            See <see cref="P:GoRogue.IReadOnlySpatialMap`1.Items"/>.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedSpatialMap`1.Positions">
            <summary>
            See <see cref="P:GoRogue.IReadOnlySpatialMap`1.Positions"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Add(`0,GoRogue.Coord)">
            <summary>
            Adds the given item at the given position, provided the item is not already in the
            spatial map and the position is not already filled. If either of those are the case,
            returns false. Otherwise (if item was successfully added), returns true.
            </summary>
            <param name="newItem">The item to add.</param>
            <param name="position">The position at which to add the new item.</param>
            <returns>True if the item was added, false if adding the item failed.</returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Add(`0,System.Int32,System.Int32)">
            <summary>
            Adds the given item at the given position, provided the item is not already in the
            spatial map and the position is not already filled. If either of those are the case,
            returns false. Otherwise (if item was successfully added), returns true.
            </summary>
            <param name="newItem">The item to add.</param>
            <param name="x">X-value of the position to add item to.</param>
            <param name="y">Y-value of the position to add item to.</param>
            <returns>True if the item was added, false if adding the item failed.</returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.AsReadOnly">
            <summary>
            See <see cref="M:GoRogue.IReadOnlySpatialMap`1.AsReadOnly"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Clear">
            <summary>
            See <see cref="M:GoRogue.ISpatialMap`1.Clear"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Contains(`0)">
            <summary>
            See <see cref="M:GoRogue.IReadOnlySpatialMap`1.Contains(`0)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Contains(GoRogue.Coord)">
            <summary>
            See <see cref="M:GoRogue.IReadOnlySpatialMap`1.Contains(GoRogue.Coord)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Contains(System.Int32,System.Int32)">
            <summary>
            See <see cref="M:GoRogue.IReadOnlySpatialMap`1.Contains(System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.GetEnumerator">
            <summary>
            Used by foreach loop, so that the class will give ISpatialTuple objects when used in a
            foreach loop. Generally should never be called explicitly.
            </summary>
            <returns>An enumerator for the spatial map</returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Generic iterator used internally by foreach loops.
            </summary>
            <returns>Enumerator to ISpatialTuple instances.</returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.GetItem(GoRogue.Coord)">
            <summary>
            Gets the item at the given position, or default(T) if no item exists.
            </summary>
            <remarks>
            Intended to be a more convenient function as compared to <see cref="M:GoRogue.AdvancedSpatialMap`1.GetItems(GoRogue.Coord)"/>, since
            this spatial map implementation only allows a single item to at any given location at a time.
            </remarks>
            <param name="position">The postiion to return the item for.</param>
            <returns>
            The item at the given position, or default(T) if no item exists at that location.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.GetItem(System.Int32,System.Int32)">
            <summary>
            Gets the item at the given position, or default(T) if no item exists.
            </summary>
            <remarks>
            Intended to be a more convenient function as compared to <see cref="M:GoRogue.AdvancedSpatialMap`1.GetItems(System.Int32,System.Int32)"/>, since
            this spatial map implementation only allows a single item to at any given location at a time.
            </remarks>
            <param name="x">The x-value of the position to return the item for.</param>
            <param name="y">The y-value of the position to return the item for.</param>
            <returns>
            The item at the given position, or default(T) if no item exists at that location.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.GetItems(GoRogue.Coord)">
            <summary>
            Gets the item at the given position as a 1-element enumerable if there is any item there,
            or nothing if there is nothing at that position.
            </summary>
            <remarks>
            Since this implementation guarantees that only one item can be at any given
            location at once, the return value is guaranteed to be at most one element. You may find it
            more convenient to use the <see cref="M:GoRogue.AdvancedSpatialMap`1.GetItems(GoRogue.Coord)"/> function when you know you are
            dealing with a SpatialMap/AdvancedSpatialMap instance.
            </remarks>
            <param name="position">The position to return the item for.</param>
            <returns>
            The item at the given position as a 1-element enumerable, if there is an item there, or
            nothing if there is no item there.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.GetItems(System.Int32,System.Int32)">
            <summary>
            Gets the item at the given position as a 1-element enumerable if there is any item there,
            or nothing if there is nothing at that position.
            </summary>
            <remarks>
            Since this implementation guarantees that only one item can be at any given
            location at once, the return value is guaranteed to be at most one element. You may find it
            more convenient to use the <see cref="M:GoRogue.AdvancedSpatialMap`1.GetItems(System.Int32,System.Int32)"/> function when you know you are
            dealing with a SpatialMap/AdvancedSpatialMap instance.
            </remarks>
            <param name="x">The x-value of the position to return the item(s) for.</param>
            <param name="y">The y-value of the position to return the item(s) for.</param>
            <returns>
            The item at the given position as a 1-element enumerable, if there is an item there, or
            nothing if there is no item there.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.GetPosition(`0)">
            <summary>
            See <see cref="M:GoRogue.IReadOnlySpatialMap`1.GetPosition(`0)"/>.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Move(`0,GoRogue.Coord)">
            <summary>
            Moves the item specified to the position specified. If the item does not exist
            in the spatial map, or the position is already filled by some other item, the
            function does nothing and returns false. Otherwise, returns true.
            </summary>
            <param name="item">The item to move.</param>
            <param name="target">The position to move it to.</param>
            <returns>True if the item was moved, false if the move operation failed.</returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Move(`0,System.Int32,System.Int32)">
            <summary>
            Moves the item specified to the position specified. If the item does not exist
            in the spatial map, or the position is already filled by some other item, the
            function does nothing and returns false. Otherwise, returns true.
            </summary>
            <param name="item">The item to move.</param>
            <param name="targetX">X-value of the location to move item to.</param>
            <param name="targetY">Y-value of the location to move item to.</param>
            <returns>True if the item was moved, false if not.</returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Move(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Moves whatever is at position current, if anything, to the target position. If something was
            moved, returns what was moved. If nothing was moved, eg. either there was nothing at
            <paramref name="current"/> or already something at <paramref name="target"/>, returns nothing.
            </summary>
            <remarks>
            Since this implementation of ISpatialMap guarantees that only one item may be at any
            given location at a time, the returned values will either be none, or a single value.
            </remarks>
            <param name="current">The position of the item to move.</param>
            <param name="target">The position to move the item to.</param>
            <returns>
            The item moved as a 1-element IEnumerable if something was moved, or nothing if no item
            was moved.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Move(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Moves whatever is at the "current" position specified, if anything, to the "target" position. If something was
            moved, returns what was moved. If nothing was moved, eg. either there was nothing at
            the "current" position given, or already something at the "target" position given, returns nothing.
            </summary>
            <remarks>
            Since this implementation of ISpatialMap guarantees that only one item may be at any
            given location at a time, the returned values will either be none, or a single value.
            </remarks>
            <param name="currentX">X-value of the location to move item from.</param>
            <param name="currentY">Y-value of the location to move item from.</param>
            <param name="targetX">X-value of the location to move item to.</param>
            <param name="targetY">Y-value of the location to move item to.</param>
            <returns>
            The item moved as a 1-element IEnumerable if something was moved, or nothing if no item
            was moved.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Remove(`0)">
            <summary>
            Removes the item specified, if it exists, and returns true. Returns false if the item was
            not in the spatial map.
            </summary>
            <param name="item">The item to remove.</param>
            <returns>True if the item was removed, false if the item was not found.</returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Remove(GoRogue.Coord)">
            <summary>
            Removes whatever is at the given position, if anything, and returns the item removed as a
            1-element IEnumerable. Returns nothing if no item was at the position specified.
            </summary>
            <remarks>
            Since this implementation of ISpatialMap guarantees that only one item can be at any given
            location at a time, the returned value is guaranteed to be either nothing or a single element.
            </remarks>
            <param name="position">The position of the item to remove.</param>
            <returns>
            The item removed as a 1-element IEnumerable, if something was removed; nothing if no item
            was found at that position.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Remove(System.Int32,System.Int32)">
            <summary>
            Removes whatever is at the given position, if anything, and returns the item removed as a
            1-element IEnumerable. Returns nothing if no item was at the position specified.
            </summary>
            <remarks>
            Since this implementation guarantees that only one item can be at any given
            location at a time, the returned value is guaranteed to be either nothing or a single element.
            </remarks>
            <param name="x">X-value of the position to remove item from.</param>
            <param name="y">Y-value of the position to remove item from.</param>
            <returns>
            The item removed as a 1-element IEnumerable, if something was removed; nothing if no item
            was found at that position.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.ToString">
            <summary>
            Returns a string representation of the spatial map.
            </summary>
            <returns>A string representation of the spatial map.</returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.ToString(System.Func{`0,System.String})">
            <summary>
            Returns a string representation of the spatial map, allowing display of the spatial map's
            items in a specified way.
            </summary>
            <param name="itemStringifier">Function that turns an item into a string.</param>
            <returns>A string representation of the spatial map.</returns>
        </member>
        <member name="T:GoRogue.SpatialMap`1">
            <summary>
            An implementation of <see cref="T:GoRogue.ISpatialMap`1"/> that allows only one item at each position
            at a time.  If you need multiple items to be able to reside at one location at the same time,
            use <see cref="T:GoRogue.MultiSpatialMap`1"/> or <see cref="T:GoRogue.LayeredSpatialMap`1"/> instead.
            </summary>
            <remarks>
            See the <see cref="T:GoRogue.ISpatialMap`1"/> for documentation on the practical purpose of spatial
            maps.
            
            
            The objects stored in a SpatialMap must implement <see cref="T:GoRogue.IHasID"/>. This is used
            internally to keep track of the objects, since uints are easily (and efficiently) hashable.
            </remarks>
            <typeparam name="T">
            The type of object that will be contained by this SpatialMap. Must implement <see cref="T:GoRogue.IHasID"/>
            and be a reference-type.
            </typeparam>
        </member>
        <member name="M:GoRogue.SpatialMap`1.#ctor(System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="initialCapacity">
            The initial maximum number of elements the SpatialMap can hold before it has to
            internally resize data structures. Defaults to 32.
            </param>
        </member>
        <member name="T:GoRogue.Utility">
            <summary>
            Static class containing extension helper methods for various built-in C# classes, as well as a
            static helper method for "swapping" references.
            </summary>
        </member>
        <member name="M:GoRogue.Utility.AsReadOnly``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Adds an AsReadOnly method to <see cref="T:System.Collections.Generic.IDictionary`2"/>, similar to the AsReadOnly method of
            <see cref="T:System.Collections.Generic.IList`1"/>, that returns a read-only reference to the dictionary.
            </summary>
            <typeparam name="K">Type of keys of the dictionary.</typeparam>
            <typeparam name="V">Type of values of the dictionary.</typeparam>
            <param name="dictionary"/>
            <returns>A ReadOnlyDictionary instance for the specified dictionary.</returns>
        </member>
        <member name="M:GoRogue.Utility.ExtendToString``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String},System.String,System.String)">
            <summary>
            Extension method for <see cref="T:System.Collections.Generic.IEnumerable`1"/> that allows retrieving a string
            representing the contents.
            </summary>
            <remarks>
            Built-in C# data structures like <see cref="T:System.Collections.Generic.List`1"/> implement <see cref="T:System.Collections.Generic.IEnumerable`1"/>,
            and as such this method can be used to stringify the contents of C# built-in data structures.
            
            When no customization paramters are specified, it defaults to a representation looking something
            like [elem1, elem2, elem3].
            </remarks>
            <typeparam name="T"/>
            <param name="enumerable"/>
            <param name="begin">Character(s) that should precede the string representation of the IEnumerable's elements.</param>
            <param name="elementStringifier">
            Function to use to get the string representation of each element. Specifying null uses the ToString
            function of type T.
            </param>
            <param name="separator">Characters to separate the IEnumerable's elements by.</param>
            <param name="end">Character(s) that should follow the string representation of the IEnumerable's elements.</param>
            <returns>A string representation of the IEnumerable.</returns>
        </member>
        <member name="M:GoRogue.Utility.ExtendToString``1(System.Collections.Generic.ISet{``0},System.String,System.Func{``0,System.String},System.String,System.String)">
            <summary>
            Extension method for <see cref="T:System.Collections.Generic.ISet`1"/> that allows retrieving a string representing the
            contents.
            </summary>
            <remarks>
            Built-in C# data structures like <see cref="T:System.Collections.Generic.HashSet`1"/> implement <see cref="T:System.Collections.Generic.ISet`1"/>,
            and as such this method can be used to stringify the contents of C# built-in set structures.
            
            When no customization paramters are specified, it defaults to a representation looking something
            like set(elem1, elem2, elem3).
            </remarks>
            <typeparam name="T"/>
            <param name="set"/>
            <param name="begin">Character(s) that should precede the string representation of the set's elements.</param>
            <param name="elementStringifier">
            Function to use to get the string representation of each element. Specifying null uses the ToString
            function of type T.
            </param>
            <param name="separator">Characters to separate the set's items by.</param>
            <param name="end">Character(s) that should follow the string representation of the set's elements.</param>
            <returns>A string representation of the ISet.</returns>
        </member>
        <member name="M:GoRogue.Utility.ExtendToString``2(System.Collections.Generic.IDictionary{``0,``1},System.String,System.Func{``0,System.String},System.Func{``1,System.String},System.String,System.String,System.String)">
            <summary>
            Extension method for dictionaries that allows retrieving a string representing the dictionary's contents.
            </summary>
            <remarks>
            Built-in C# data structures like <see cref="T:System.Collections.Generic.Dictionary`2"/> implement <see cref="T:System.Collections.Generic.IDictionary`2"/>,
            and as such this method can be used to stringify the contents of C# built-in dictionary structures.
            
            When no customization paramters are specified, it defaults to a representation looking something
            like {key1 : value, key2 : value}.
            </remarks>
            <typeparam name="K"/>
            <typeparam name="V"/>
            <param name="dictionary"/>
            <param name="begin">Character(s) that should precede the string representation of the dictionary's elements.</param>
            <param name="keyStringifier">
            Function to use to get the string representation of each key. Specifying null uses the ToString
            function of type K.
            </param>
            <param name="valueStringifier">
            Function to use to get the string representation of each value. Specifying null uses the ToString
            function of type V.
            </param>
            <param name="kvSeparator">Characters used to separate each value from its key.</param>
            <param name="pairSeparator">Characters used to separate each key-value pair from the next.</param>
            <param name="end">Character(s) that should follow the string representation of the dictionary's elements.</param>
            <returns>A string representation of the IDictionary.</returns>
        </member>
        <member name="M:GoRogue.Utility.ExtendToString``1(``0[0:,0:],System.String,System.String,System.Func{``0,System.String},System.String,System.String,System.String,System.String)">
            <summary>
            Extension method for 2D arrays that allows retrieving a string representing the contents.
            </summary>
            <typeparam name="T"/>
            <param name="array"/>
            <param name="begin">Character(s) that should precede the string representation of the 2D array.</param>
            <param name="beginRow">Character(s) that should precede the string representation of each row.</param>
            <param name="elementStringifier">
            Function to use to get the string representation of each value. Specifying null uses the ToString
            function of type T.
            </param>
            <param name="rowSeparator">Character(s) used to separate each row from the next.</param>
            <param name="elementSeparator">Character(s) used to separate each element from the next.</param>
            <param name="endRow">Character(s) that should follow the string representation of each row.</param>
            <param name="end">Character(s) that should follow the string representation of the 2D array.</param>
            <returns>A string representation of the 2D array.</returns>
        </member>
        <member name="M:GoRogue.Utility.ExtendToStringGrid``1(``0[0:,0:],System.String,System.String,System.Func{``0,System.String},System.String,System.String,System.String,System.String)">
            <summary>
            Extension method for 2D arrays that allows retrieving a string representing the contents,
            formatted as if the 2D array represents a coordinate plane/grid.
            </summary>
            <remarks>
            This differs from <see cref="M:GoRogue.Utility.ExtendToString``1(``0[0:,0:],System.String,System.String,System.Func{``0,System.String},System.String,System.String,System.String,System.String)"/>
            in that this method prints the array
            such that array[x+1, y] is printed to the RIGHT of array[x, y], rather than BELOW it.
            Effectively it assumes the indexes being used are grid/coordinate plane coordinates.
            </remarks>
            <typeparam name="T"/>
            <param name="array"/>
            <param name="begin">Character(s) that should precede the string representation of the 2D array.</param>
            <param name="beginRow">Character(s) that should precede the string representation of each row.</param>
            <param name="elementStringifier">
            Function to use to get the string representation of each value. Specifying null uses the ToString
            function of type T.
            </param>
            <param name="rowSeparator">Character(s) used to separate each row from the next.</param>
            <param name="elementSeparator">Character(s) used to separate each element from the next.</param>
            <param name="endRow">Character(s) that should follow the string representation of each row.</param>
            <param name="end">Character(s) that should follow the string representation of the 2D array.</param>
            <returns>
            A string representation of the 2D array, formatted as if the array represents a 2D coordinate plane/grid map.
            </returns>
        </member>
        <member name="M:GoRogue.Utility.ExtendToStringGrid``1(``0[0:,0:],System.Int32,System.String,System.String,System.Func{``0,System.String},System.String,System.String,System.String,System.String)">
            <summary>
            Extension method for 2D arrays that allows retrieving a string representing the contents,
            formatted as if the 2D array represents a coordinate plane/grid.
            </summary>
            <remarks>
            This differs from <see cref="M:GoRogue.Utility.ExtendToString``1(``0[0:,0:],System.String,System.String,System.Func{``0,System.String},System.String,System.String,System.String,System.String)"/>
            in that this method prints the array such that array[x+1, y] is printed to the RIGHT of array[x, y], rather than BELOW it.
            Effectively it assumes the indexes being used are grid/coordinate plane coordinates.
            </remarks>
            <typeparam name="T"/>
            <param name="array"/>
            <param name="fieldSize">
            The amount of space each element should take up in characters. A positive number aligns
            the text to the right of the space, while a negative number aligns the text to the left.
            </param>
            <param name="begin">Character(s) that should precede the string representation of the 2D array.</param>
            <param name="beginRow">Character(s) that should precede the string representation of each row.</param>
            <param name="elementStringifier">
            Function to use to get the string representation of each value. Specifying null uses the ToString
            function of type T.
            </param>
            <param name="rowSeparator">Character(s) used to separate each row from the next.</param>
            <param name="elementSeparator">Character(s) used to separate each element from the next.</param>
            <param name="endRow">Character(s) that should follow the string representation of each row.</param>
            <param name="end">Character(s) that should follow the string representation of the 2D array.</param>
            <returns>
            A string representation of the 2D array, formatted as if the array represents a 2D coordinate plane/grid map.
            </returns>
        </member>
        <member name="M:GoRogue.Utility.FisherYatesShuffle``1(System.Collections.Generic.IList{``0},Troschuetz.Random.IGenerator)">
            <summary>
            Extension method for <see cref="T:System.Collections.Generic.IList`1"/> that implements a fisher-yates shuffle. Modifies the list it is
            called on to randomly rearrange the elements therein.
            </summary>
            <typeparam name="T"/>
            <param name="list"/>
            <param name="rng">RNG to use.  Specifying null causes <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>
            to be used</param>
        </member>
        <member name="M:GoRogue.Utility.Multiply(System.String,System.Int32)">
            <summary>
            "Multiplies", aka repeats, a string the given number of times.
            </summary>
            <param name="str"/>
            <param name="numTimes">The number of times to repeat the string.</param>
            <returns>The current string repeated <paramref name="numTimes"/> times.</returns>
        </member>
        <member name="M:GoRogue.Utility.RandomIndex``1(System.Collections.Generic.IReadOnlyList{``0},Troschuetz.Random.IGenerator)">
            <summary>
            Extension method that selects and returns a random valid index from the list, using the
            rng specified. -1 is returned if the list is empty.
            </summary>
            <typeparam name="T"/>
            <param name="list"/>
            <param name="rng">RNG to use.  Specifying null causes <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>
            to be used.</param>
            <returns>The index selected.</returns>
        </member>
        <member name="M:GoRogue.Utility.RandomIndex``1(System.Collections.Generic.IReadOnlyList{``0},System.Func{System.Int32,System.Boolean},Troschuetz.Random.IGenerator)">
            <summary>
            Extension method that selects and returns a random valid index from the list for which
            the selector function given returns true, using the rng specified. Indices are repeatedly
            selected until a qualifying index is found. -1 is returned if the list is empty.
            </summary>
            <typeparam name="T"/>
            <param name="list"/>
            <param name="selector">
            Function that returns true if the given index is valid selection, false otherwise.
            </param>
            <param name="rng">RNG to use.  Specifying null causes <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>
            to be used.</param>
            <returns>Index selected.</returns>
        </member>
        <member name="M:GoRogue.Utility.RandomItem``1(System.Collections.Generic.IReadOnlyList{``0},Troschuetz.Random.IGenerator)">
            <summary>
            Extension method that selects and returns a random item from the list, using the rng
            specified. default(T) is returned if the list is empty.
            </summary>
            <typeparam name="T"/>
            <param name="list"/>
            <param name="rng">RNG to use.  Specifying null causes <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>
            to be used.</param>
            <returns>Item selected.</returns>
        </member>
        <member name="M:GoRogue.Utility.RandomItem``1(System.Collections.Generic.IReadOnlyList{``0},System.Func{``0,System.Boolean},Troschuetz.Random.IGenerator)">
            <summary>
            Extension method that selects and returns a random item from the list for which the given
            selector returns true, using the rng specified. Items are repeatedly selected until a
            qualifying item is found. default(T) is returned if the list is empty.
            </summary>
            <typeparam name="T"/>
            <param name="list"/>
            <param name="selector">Function that returns true if the given item is valid selection, false otherwise.</param>
            <param name="rng">RNG to use.  Specifying null causes <see cref="F:GoRogue.Random.SingletonRandom.DefaultRNG"/>
            to be used.</param>
            <returns>Item selected.</returns>
        </member>
        <member name="M:GoRogue.Utility.Swap``1(``0@,``0@)">
            <summary>
            Swaps the values pointed to by <paramref name="lhs"/> and <paramref name="rhs"/>.
            </summary>
            <typeparam name="T"/>
            <param name="lhs"/>
            <param name="rhs"/>
        </member>
        <member name="M:GoRogue.Utility.Yield``1(``0)">
            <summary>
            Convenience function that yields the given item as a single-item IEnumerable.
            </summary>
            <typeparam name="T"/>
            <param name="item"/>
            <returns>An IEnumerable containing only the item the function is called on.</returns>
        </member>
        <member name="M:GoRogue.Utility.Yield``1(``0[])">
            <summary>
            Takes multiple parameters and converts them to an IEnumerable.
            </summary>
            <typeparam name="T"/>
            <param name="values">Parameters (specified as multiple parameters to the function).</param>
            <returns>
            An IEnumerable of all of the given items, in the order they were given to the function.
            </returns>
        </member>
    </members>
</doc>
